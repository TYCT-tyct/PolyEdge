diff --git a/crates/app_runner/Cargo.toml b/crates/app_runner/Cargo.toml
index 96a6ae7..8ac7493 100644
--- a/crates/app_runner/Cargo.toml
+++ b/crates/app_runner/Cargo.toml
@@ -8,11 +8,15 @@ license.workspace = true
 anyhow.workspace = true
 axum.workspace = true
 chrono.workspace = true
+dashmap.workspace = true
 core_types = { path = "../core_types" }
+direction_detector = { path = "../direction_detector" }
+exit_manager = { path = "../exit_manager" }
 execution_clob = { path = "../execution_clob" }
 fair_value = { path = "../fair_value" }
 feed_polymarket = { path = "../feed_polymarket" }
 feed_reference = { path = "../feed_reference" }
+feed_udp = { path = "../feed_udp" }
 futures.workspace = true
 infra_bus = { path = "../infra_bus" }
 market_discovery = { path = "../market_discovery" }
@@ -21,12 +25,25 @@ metrics-exporter-prometheus.workspace = true
 observability = { path = "../observability" }
 paper_executor = { path = "../paper_executor" }
 portfolio = { path = "../portfolio" }
+probability_engine = { path = "../probability_engine" }
 reqwest.workspace = true
 risk_engine = { path = "../risk_engine" }
 rustls.workspace = true
 serde.workspace = true
 serde_json.workspace = true
+settlement_compounder = { path = "../settlement_compounder" }
 sha2.workspace = true
+smol_str.workspace = true
 strategy_maker = { path = "../strategy_maker" }
+taker_sniper = { path = "../taker_sniper" }
+timeframe_router = { path = "../timeframe_router" }
 tokio.workspace = true
 tracing.workspace = true
+toml.workspace = true
+mimalloc = "0.1"
+poly_wire = { path = "../poly_wire" }
+tokio-tungstenite.workspace = true
+tracing-subscriber.workspace = true
+socket2 = "0.6.2"
+flate2 = "1.0"
+rusqlite = { version = "0.31", features = ["bundled"] }
diff --git a/crates/app_runner/src/bin/bench_feed.rs b/crates/app_runner/src/bin/bench_feed.rs
new file mode 100644
index 0000000..6708db4
--- /dev/null
+++ b/crates/app_runner/src/bin/bench_feed.rs
@@ -0,0 +1,261 @@
+use anyhow::Result;
+use futures::StreamExt;
+use poly_wire::{
+    decode_auto, WirePacket, WIRE_BOOK_TOP24_SIZE, WIRE_MAX_PACKET_SIZE, WIRE_MOMENTUM_TICK32_SIZE,
+    WIRE_RELAY_TICK40_SIZE,
+};
+use serde::Deserialize;
+use std::collections::HashMap;
+use std::io::Write;
+use std::sync::Arc;
+use std::time::{SystemTime, UNIX_EPOCH};
+use tokio::net::UdpSocket;
+use tokio::sync::Mutex;
+use tokio_tungstenite::connect_async;
+use tokio_tungstenite::tungstenite::Message;
+use tracing::{info, warn};
+use tracing_subscriber::FmtSubscriber;
+
+#[derive(Debug, Deserialize)]
+struct BookTicker {
+    #[serde(default, rename = "E")]
+    event_time_ms: u64,
+}
+
+fn now_micros() -> u64 {
+    SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .unwrap()
+        .as_micros() as u64
+}
+
+#[inline]
+fn percentile(sorted: &[f64], q: f64) -> f64 {
+    let idx = (((sorted.len() - 1) as f64) * q.clamp(0.0, 1.0)).round() as usize;
+    sorted[idx]
+}
+
+#[tokio::main]
+async fn main() -> Result<()> {
+    rustls::crypto::ring::default_provider()
+        .install_default()
+        .unwrap();
+    tracing::subscriber::set_global_default(
+        FmtSubscriber::builder()
+            .with_max_level(tracing::Level::INFO)
+            .finish(),
+    )
+    .expect("setting default subscriber failed");
+
+    let symbol = std::env::var("SYMBOL").unwrap_or_else(|_| "btcusdt".to_string());
+    let udp_port = 6666;
+
+    info!("üöÄ Starting Feed Benchmark (Symbol: {})", symbol);
+    info!("   - Direct: Binance WS (Ireland)");
+    info!("   - Relay:  UDP Port {} (Tokyo)", udp_port);
+
+    // 1. Setup UDP Listener (Optimized)
+    use socket2::{Domain, Protocol, Socket, Type};
+    use std::net::SocketAddr;
+
+    let socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;
+    let _ = socket.set_recv_buffer_size(8 * 1024 * 1024); // 8MB
+    let _ = socket.set_nonblocking(true);
+    let addr_str = format!("0.0.0.0:{}", udp_port);
+    let addr: SocketAddr = addr_str.parse()?;
+    #[cfg(target_os = "linux")]
+    let _ = socket.set_reuse_port(true);
+    let _ = socket.set_reuse_address(true);
+    socket.bind(&addr.into())?;
+
+    let socket = UdpSocket::from_std(socket.into())?;
+
+    info!("‚úÖ UDP Listening on {} (Buffer: 8MB)", addr_str);
+
+    // 2. Setup WS Listener
+    let ws_url = format!(
+        "wss://stream.binance.com:9443/ws/{}@bookTicker",
+        symbol.to_lowercase()
+    );
+    let (ws_stream, _) = connect_async(&ws_url).await?;
+    info!("‚úÖ WS Connected to {}", ws_url);
+    let (_, mut read) = ws_stream.split();
+
+    // 3. Shared State
+    // Map<event_ts_ms, (ws_recv_ts, udp_recv_ts)>
+    let tracker: Arc<Mutex<HashMap<u64, (Option<u64>, Option<u64>)>>> =
+        Arc::new(Mutex::new(HashMap::new()));
+
+    // I/O Thread Setup
+    struct LogEntry {
+        id: u64,
+        udp: u64,
+        ws: u64,
+        delta: f64,
+        faster: &'static str,
+    }
+
+    let (tx_log, rx_log) = std::sync::mpsc::channel::<LogEntry>();
+    let tx_log_udp = tx_log.clone();
+    let tx_log_ws = tx_log.clone();
+    let (tx_delta, rx_delta) = std::sync::mpsc::channel::<f64>();
+    let tx_delta_udp = tx_delta.clone();
+    let tx_delta_ws = tx_delta.clone();
+
+    // Spawn Writer Thread
+    std::thread::spawn(move || {
+        let file = std::fs::File::create("latency_report.csv").unwrap();
+        let mut writer = std::io::BufWriter::new(file);
+        writeln!(writer, "event_ts_ms,udp_ts,ws_ts,delta_ms,faster_source").unwrap();
+
+        while let Ok(entry) = rx_log.recv() {
+            writeln!(
+                writer,
+                "{},{},{},{:.3},{}",
+                entry.id, entry.udp, entry.ws, entry.delta, entry.faster
+            )
+            .unwrap();
+        }
+    });
+
+    let tracker_udp = tracker.clone();
+    let tracker_ws = tracker.clone();
+
+    // 4. UDP Task
+    tokio::spawn(async move {
+        let mut buf = [0u8; WIRE_MAX_PACKET_SIZE];
+        let mut last_event_ts_ms = 0_u64;
+        loop {
+            match socket.recv_from(&mut buf).await {
+                Ok((amt, _)) => {
+                    let recv_ts = now_micros();
+                    if amt != WIRE_BOOK_TOP24_SIZE
+                        && amt != WIRE_MOMENTUM_TICK32_SIZE
+                        && amt != WIRE_RELAY_TICK40_SIZE
+                    {
+                        continue;
+                    }
+                    if let Ok(packet) = decode_auto(&buf[..amt]) {
+                        let event_ts_ms = match packet {
+                            WirePacket::BookTop24(v) => v.ts_micros / 1_000,
+                            WirePacket::MomentumTick32(v) => v.ts_micros / 1_000,
+                            WirePacket::RelayTick40(v) => v.ts_micros / 1_000,
+                        };
+                        if last_event_ts_ms > 0 && event_ts_ms < last_event_ts_ms {
+                            warn!(
+                                "‚ö†Ô∏è UDP timestamp backjump: {} -> {}",
+                                last_event_ts_ms, event_ts_ms
+                            );
+                        }
+                        last_event_ts_ms = event_ts_ms;
+                        let mut map = tracker_udp.lock().await;
+                        let entry = map.entry(event_ts_ms).or_insert((None, None));
+                        entry.1 = Some(recv_ts);
+
+                        // Check match inside lock, but do NOT do I/O
+                        let match_found = entry.0;
+
+                        if let Some(ws_ts) = match_found {
+                            map.remove(&event_ts_ms);
+
+                            let delta = (recv_ts as i64) - (ws_ts as i64);
+                            let ms = delta as f64 / 1000.0;
+                            let faster = if ms < 0.0 { "UDP" } else { "WS" };
+
+                            let _ = tx_log_udp.send(LogEntry {
+                                id: event_ts_ms,
+                                udp: recv_ts,
+                                ws: ws_ts,
+                                delta: ms,
+                                faster,
+                            });
+                            let _ = tx_delta_udp.send(ms);
+                        }
+
+                        // Prune (Optimized: Check size less often?)
+                        if map.len() > 5000 {
+                            map.retain(|k, _| *k > event_ts_ms.saturating_sub(10_000));
+                        }
+                    }
+                }
+                Err(e) => warn!("UDP Error: {}", e),
+            }
+        }
+    });
+
+    // 5. WS Loop
+    let mut last_stat_time = std::time::Instant::now();
+    let mut stats_window: Vec<f64> = Vec::with_capacity(16_384);
+
+    while let Some(msg) = read.next().await {
+        match msg {
+            Ok(Message::Text(text)) => {
+                let recv_ts = now_micros();
+                if let Ok(ticker) = serde_json::from_str::<BookTicker>(&text) {
+                    if ticker.event_time_ms == 0 {
+                        continue;
+                    }
+                    let mut map = tracker_ws.lock().await;
+                    let entry = map.entry(ticker.event_time_ms).or_insert((None, None));
+                    entry.0 = Some(recv_ts);
+
+                    let match_found = entry.1;
+
+                    if let Some(udp_ts) = match_found {
+                        map.remove(&ticker.event_time_ms);
+
+                        let delta = (udp_ts as i64) - (recv_ts as i64);
+                        let ms = delta as f64 / 1000.0;
+                        let faster = if ms < 0.0 { "UDP" } else { "WS" };
+
+                        let _ = tx_log_ws.send(LogEntry {
+                            id: ticker.event_time_ms,
+                            udp: udp_ts,
+                            ws: recv_ts,
+                            delta: ms,
+                            faster,
+                        });
+                        let _ = tx_delta_ws.send(ms);
+                    }
+
+                    if map.len() > 5000 {
+                        map.retain(|k, _| *k > ticker.event_time_ms.saturating_sub(10_000));
+                    }
+                }
+            }
+            Ok(Message::Ping(_)) => {}
+            _ => {}
+        }
+
+        // Periodic Stats Log (Every 10s)
+        if last_stat_time.elapsed().as_secs() >= 10 {
+            while let Ok(delta) = rx_delta.try_recv() {
+                stats_window.push(delta);
+            }
+            if !stats_window.is_empty() {
+                stats_window.sort_by(|a, b| a.total_cmp(b));
+                let len = stats_window.len();
+                let p50 = percentile(&stats_window, 0.50);
+                let p90 = percentile(&stats_window, 0.90);
+                let p99 = percentile(&stats_window, 0.99);
+                let udp_fast_count = stats_window.iter().filter(|&&x| x < 0.0).count();
+
+                info!(
+                    "üìä STATS (Last 10s): Count={} | P50={:.3}ms | P90={:.3}ms | P99={:.3}ms | UDP Faster: {}/{} ({:.1}%)",
+                    len,
+                    p50,
+                    p90,
+                    p99,
+                    udp_fast_count,
+                    len,
+                    (udp_fast_count as f64 / len as f64) * 100.0
+                );
+
+                stats_window.clear();
+            }
+            last_stat_time = std::time::Instant::now();
+        }
+    }
+
+    Ok(())
+}
diff --git a/crates/app_runner/src/bootstrap.rs b/crates/app_runner/src/bootstrap.rs
new file mode 100644
index 0000000..930e6f2
--- /dev/null
+++ b/crates/app_runner/src/bootstrap.rs
@@ -0,0 +1,373 @@
+use std::collections::HashMap;
+use std::net::SocketAddr;
+use std::sync::{Arc, RwLock as StdRwLock};
+use std::time::Duration;
+
+use anyhow::{Context, Result};
+use dashmap::DashMap;
+use direction_detector::DirectionDetector;
+use execution_clob::{ClobExecution, ExecutionMode};
+use exit_manager::ExitManager;
+use infra_bus::RingBus;
+use observability::{init_metrics, init_tracing};
+use paper_executor::ShadowExecutor;
+use portfolio::PortfolioBook;
+use probability_engine::ProbabilityEngine;
+use reqwest::Client;
+use risk_engine::DefaultRiskManager;
+use settlement_compounder::SettlementCompounder;
+use taker_sniper::TakerSniper;
+use timeframe_router::TimeframeRouter;
+use tokio::sync::{mpsc, RwLock};
+
+use crate::config_loader::{
+    load_edge_model_config, load_execution_config, load_exit_config, load_fair_value_config,
+    load_fusion_config, load_perf_profile_config, load_predator_c_config, load_risk_limits_config,
+    load_seat_config, load_settlement_config, load_source_health_config, load_strategy_config,
+    load_universe_config,
+};
+use crate::feed_runtime::{spawn_market_feed, spawn_reference_feed, spawn_settlement_feed};
+use crate::paper_runtime::{set_global_paper_runtime, PaperRuntimeHandle};
+use crate::report_io::{ensure_dataset_dirs, init_jsonl_writer};
+use crate::seat_runtime::SeatRuntimeHandle;
+use crate::state::{
+    settlement_live_gate_status, to_exit_manager_config, AllocatorConfig, AppState, EngineShared,
+    ShadowStats, StrategyIngressMsg, ToxicityConfig,
+};
+use crate::{control_api, orchestration, spawn_detached, spawn_strategy_engine};
+
+fn env_flag_enabled(name: &str) -> bool {
+    std::env::var(name)
+        .ok()
+        .map(|v| {
+            let normalized = v.trim().to_ascii_lowercase();
+            matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
+        })
+        .unwrap_or(false)
+}
+
+pub(super) async fn async_main() -> Result<()> {
+    let _guard = init_tracing("app_runner");
+    let prometheus = init_metrics();
+    ensure_dataset_dirs();
+    let control_port = std::env::var("POLYEDGE_CONTROL_PORT")
+        .ok()
+        .and_then(|v| v.parse::<u16>().ok())
+        .unwrap_or(8080);
+    tracing::info!(control_port, "resolved control port");
+    std::env::set_var("POLYEDGE_CONTROL_PORT", control_port.to_string());
+    let mut seat_cfg = load_seat_config();
+    if seat_cfg.control_base_url.trim().is_empty() {
+        seat_cfg.control_base_url = format!("http://127.0.0.1:{control_port}");
+    }
+    let seat = SeatRuntimeHandle::spawn(seat_cfg);
+    let seat_fill_counter = seat.live_fill_counter();
+    let paper_enabled = std::env::var("POLYEDGE_PAPER_ENABLED")
+        .ok()
+        .map(|v| !matches!(v.trim().to_ascii_lowercase().as_str(), "0" | "false" | "off" | "no"))
+        .unwrap_or(true);
+    let paper_initial_capital = std::env::var("POLYEDGE_PAPER_INITIAL_CAPITAL")
+        .ok()
+        .and_then(|v| v.parse::<f64>().ok())
+        .unwrap_or(100.0)
+        .max(1.0);
+    let paper_run_id = std::env::var("POLYEDGE_PAPER_RUN_ID")
+        .ok()
+        .filter(|v| !v.trim().is_empty())
+        .unwrap_or_else(|| format!("paper-{}", chrono::Utc::now().format("%Y%m%d%H%M%S")));
+    let paper_sqlite_enabled = std::env::var("POLYEDGE_PAPER_SQLITE_ENABLED")
+        .ok()
+        .map(|v| !matches!(v.trim().to_ascii_lowercase().as_str(), "0" | "false" | "off" | "no"))
+        .unwrap_or(true);
+    let paper = PaperRuntimeHandle::new(
+        paper_enabled,
+        paper_run_id,
+        paper_initial_capital,
+        paper_sqlite_enabled,
+        seat.clone(),
+    );
+    set_global_paper_runtime(paper.clone());
+
+    let execution_cfg = load_execution_config();
+    let universe_cfg = load_universe_config();
+    let settlement_cfg_boot = load_settlement_config();
+    let bus_capacity = std::env::var("POLYEDGE_BUS_CAPACITY")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok())
+        .unwrap_or(32_768)
+        .clamp(4_096, 262_144);
+    let bus = RingBus::new(bus_capacity);
+    let portfolio = Arc::new(PortfolioBook::default());
+    let live_armed = env_flag_enabled("POLYEDGE_LIVE_ARMED");
+    let force_paper = env_flag_enabled("POLYEDGE_FORCE_PAPER");
+    let live_gate = settlement_live_gate_status(&settlement_cfg_boot);
+    let exec_mode = if force_paper {
+        if execution_cfg.mode.eq_ignore_ascii_case("live") {
+            tracing::warn!(
+                "POLYEDGE_FORCE_PAPER is enabled; forcing paper mode despite execution.mode=live"
+            );
+        }
+        ExecutionMode::Paper
+    } else if execution_cfg.mode.eq_ignore_ascii_case("live") {
+        if !live_armed {
+            tracing::warn!(
+                "execution.mode=live but POLYEDGE_LIVE_ARMED is not true; forcing paper mode"
+            );
+            ExecutionMode::Paper
+        } else if !live_gate.ready {
+            tracing::warn!(
+                reason = %live_gate.reason,
+                "execution.mode=live requested but settlement live gate failed; forcing paper mode"
+            );
+            ExecutionMode::Paper
+        } else {
+            ExecutionMode::Live
+        }
+    } else {
+        ExecutionMode::Paper
+    };
+    let execution = Arc::new(ClobExecution::new_with_order_routing(
+        exec_mode,
+        execution_cfg.clob_endpoint.clone(),
+        execution_cfg.order_endpoint.clone(),
+        execution_cfg.order_backup_endpoint.clone(),
+        Duration::from_millis(execution_cfg.http_timeout_ms),
+        Duration::from_millis(execution_cfg.order_failover_timeout_ms.max(10)),
+    ));
+
+    // Optional: prewarm the execution HTTP client pool to reduce first-ack latency spikes.
+    // Uses the *same* reqwest client inside the execution layer (unlike ad-hoc curl probes).
+    if let Ok(raw) = std::env::var("POLYEDGE_HTTP_PREWARM_URLS") {
+        let urls = raw
+            .split(',')
+            .map(str::trim)
+            .filter(|u| u.starts_with("http://") || u.starts_with("https://"))
+            .map(|u| u.to_string())
+            .collect::<Vec<_>>();
+        if !urls.is_empty() {
+            tracing::info!(count = urls.len(), "prewarming execution http pool");
+            let exec = execution.clone();
+            spawn_detached("execution_http_prewarm", false, async move {
+                exec.prewarm_urls(&urls).await;
+            });
+        }
+    }
+    let shadow = Arc::new(ShadowExecutor::default());
+    let strategy_cfg = Arc::new(RwLock::new(Arc::new(load_strategy_config())));
+    let settlement_cfg = Arc::new(RwLock::new(settlement_cfg_boot));
+    let fusion_cfg = Arc::new(RwLock::new(load_fusion_config()));
+    let source_health_cfg = Arc::new(RwLock::new(load_source_health_config()));
+    let edge_model_cfg = Arc::new(RwLock::new(load_edge_model_config()));
+    let exit_cfg = Arc::new(RwLock::new(load_exit_config()));
+    let exit_cfg0 = exit_cfg.read().await.clone();
+    let fair_value_cfg = Arc::new(StdRwLock::new(load_fair_value_config()));
+    let toxicity_cfg = Arc::new(RwLock::new(Arc::new(ToxicityConfig::default())));
+    let risk_limits = Arc::new(StdRwLock::new(load_risk_limits_config()));
+    let perf_profile = Arc::new(RwLock::new(load_perf_profile_config()));
+    let allocator_cfg = {
+        let strategy = strategy_cfg.read().await.clone();
+        let tox = toxicity_cfg.read().await.clone();
+        Arc::new(RwLock::new(AllocatorConfig {
+            capital_fraction_kelly: strategy.capital_fraction_kelly,
+            variance_penalty_lambda: strategy.variance_penalty_lambda,
+            active_top_n_markets: tox.active_top_n_markets,
+            ..AllocatorConfig::default()
+        }))
+    };
+    let tox_state = Arc::new(RwLock::new(HashMap::new()));
+    let shadow_stats = Arc::new(ShadowStats::new());
+    let paused = Arc::new(RwLock::new(false));
+    let universe_symbols = Arc::new(universe_cfg.assets.clone());
+    let universe_market_types = Arc::new(universe_cfg.market_types.clone());
+    let universe_timeframes = Arc::new(universe_cfg.timeframes.clone());
+    init_jsonl_writer(perf_profile.clone()).await;
+
+    let risk_manager = Arc::new(DefaultRiskManager::new(risk_limits.clone()));
+    let predator_cfg = Arc::new(RwLock::new(load_predator_c_config()));
+    let predator_cfg0 = predator_cfg.read().await.clone();
+    let predator_direction_detector = Arc::new(RwLock::new(DirectionDetector::new(
+        predator_cfg0.direction_detector.clone(),
+    )));
+    let predator_latest_direction = Arc::new(RwLock::new(HashMap::new()));
+    let predator_latest_probability = Arc::new(RwLock::new(HashMap::new()));
+    let predator_probability_engine = Arc::new(RwLock::new(ProbabilityEngine::new(
+        predator_cfg0.probability_engine.clone(),
+    )));
+    let predator_taker_sniper = Arc::new(RwLock::new(TakerSniper::new(
+        predator_cfg0.taker_sniper.clone(),
+    )));
+    let predator_d_last_fire_ms = Arc::new(RwLock::new(HashMap::new()));
+    let predator_router = Arc::new(RwLock::new(TimeframeRouter::new(
+        predator_cfg0.router.clone(),
+    )));
+    let predator_compounder = Arc::new(RwLock::new(SettlementCompounder::new(
+        predator_cfg0.compounder.clone(),
+    )));
+    let predator_exit_manager = Arc::new(RwLock::new(ExitManager::new(to_exit_manager_config(
+        &exit_cfg0,
+    ))));
+    let shared = Arc::new(EngineShared {
+        latest_books: Arc::new(RwLock::new(HashMap::new())),
+        latest_signals: Arc::new(DashMap::new()),
+        latest_fast_ticks: Arc::new(DashMap::new()),
+        latest_anchor_ticks: Arc::new(DashMap::new()),
+        market_to_symbol: Arc::new(RwLock::new(HashMap::new())),
+        token_to_symbol: Arc::new(RwLock::new(HashMap::new())),
+        market_to_timeframe: Arc::new(RwLock::new(HashMap::new())),
+        symbol_to_markets: Arc::new(RwLock::new(HashMap::new())),
+        fee_cache: Arc::new(RwLock::new(HashMap::new())),
+        fee_refresh_inflight: Arc::new(RwLock::new(HashMap::new())),
+        scoring_cache: Arc::new(RwLock::new(HashMap::new())),
+        http: Client::new(),
+        clob_endpoint: execution_cfg.clob_endpoint.clone(),
+        strategy_cfg,
+        settlement_cfg: settlement_cfg.clone(),
+        source_health_cfg: source_health_cfg.clone(),
+        source_health_latest: Arc::new(RwLock::new(HashMap::new())),
+        settlement_prices: Arc::new(RwLock::new(HashMap::new())),
+        fusion_cfg: fusion_cfg.clone(),
+        edge_model_cfg: edge_model_cfg.clone(),
+        exit_cfg: exit_cfg.clone(),
+        fair_value_cfg,
+        toxicity_cfg,
+        risk_manager,
+        risk_limits: risk_limits.clone(),
+        universe_symbols: universe_symbols.clone(),
+        universe_market_types: universe_market_types.clone(),
+        universe_timeframes: universe_timeframes.clone(),
+        rate_limit_rps: execution_cfg.rate_limit_rps.max(0.1),
+        tox_state,
+        shadow_stats,
+        predator_cfg: predator_cfg.clone(),
+        predator_direction_detector,
+        predator_latest_direction,
+        predator_latest_probability,
+        predator_probability_engine,
+        predator_taker_sniper,
+        predator_d_last_fire_ms,
+        predator_router,
+        predator_compounder,
+        predator_exit_manager,
+        // WSS User Channel: live Ê®°Âºè‰∏ãÂêØÂä®ÂÆûÊó∂ fill ÈÄöÁü•
+        // paper Ê®°Âºè‰∏ã wss_fill_tx = NoneÔºåexit lifecycle ÂõûÈÄÄÂà∞Á∫Ø timer Ë∑ØÂæÑ
+        wss_fill_tx: {
+            let is_live = matches!(exec_mode, ExecutionMode::Live);
+            let api_key = std::env::var("POLYEDGE_CLOB_API_KEY").unwrap_or_default();
+            if is_live && !api_key.is_empty() {
+                let wss_url = std::env::var("POLYEDGE_WSS_USER_URL").unwrap_or_else(|_| {
+                    "wss://ws-subscriptions-clob.polymarket.com/ws/user".to_string()
+                });
+                let (tx, _rx) = tokio::sync::broadcast::channel::<
+                    execution_clob::wss_user_feed::WssFillEvent,
+                >(64);
+                let tx = Arc::new(tx);
+                let tx_clone = tx.clone();
+                let fill_counter = seat_fill_counter.clone();
+                tokio::spawn(async move {
+                    execution_clob::wss_user_feed::run_wss_loop_with_sender(
+                        tx_clone, wss_url, api_key,
+                    )
+                    .await;
+                });
+                let mut fill_rx = tx.subscribe();
+                let execution_for_fill = execution.clone();
+                spawn_detached("seat_live_fill_counter", false, async move {
+                    loop {
+                        match fill_rx.recv().await {
+                            Ok(event) => {
+                                if event.event_type == "trade" {
+                                    fill_counter.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
+                                    execution_for_fill.mark_order_closed_local(&event.order_id);
+                                }
+                            }
+                            Err(tokio::sync::broadcast::error::RecvError::Lagged(_)) => continue,
+                            Err(tokio::sync::broadcast::error::RecvError::Closed) => break,
+                        }
+                    }
+                });
+                Some(tx)
+            } else {
+                None
+            }
+        },
+    });
+    let strategy_input_queue_cap = std::env::var("POLYEDGE_STRATEGY_INPUT_QUEUE_CAP")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok())
+        .unwrap_or(512)
+        .clamp(128, 5_760);
+    let (strategy_ingress_tx, strategy_ingress_rx) =
+        mpsc::channel::<StrategyIngressMsg>(strategy_input_queue_cap);
+
+    let state = AppState {
+        paused: paused.clone(),
+        bus: bus.clone(),
+        portfolio: portfolio.clone(),
+        execution: execution.clone(),
+        _shadow: shadow.clone(),
+        prometheus,
+        strategy_cfg: shared.strategy_cfg.clone(),
+        fair_value_cfg: shared.fair_value_cfg.clone(),
+        toxicity_cfg: shared.toxicity_cfg.clone(),
+        allocator_cfg: allocator_cfg.clone(),
+        risk_limits: risk_limits.clone(),
+        tox_state: shared.tox_state.clone(),
+        shadow_stats: shared.shadow_stats.clone(),
+        perf_profile: perf_profile.clone(),
+        shared: shared.clone(),
+        seat: seat.clone(),
+        paper: paper.clone(),
+    };
+
+    spawn_reference_feed(
+        bus.clone(),
+        shared.shadow_stats.clone(),
+        (*universe_symbols).clone(),
+        shared.fusion_cfg.clone(),
+        shared.clone(),
+        strategy_ingress_tx.clone(),
+    );
+    spawn_settlement_feed(shared.clone());
+    spawn_market_feed(
+        bus.clone(),
+        shared.shadow_stats.clone(),
+        (*universe_symbols).clone(),
+        (*universe_market_types).clone(),
+        (*universe_timeframes).clone(),
+        strategy_ingress_tx,
+    );
+    spawn_strategy_engine(
+        bus.clone(),
+        portfolio,
+        execution.clone(),
+        shadow,
+        paused.clone(),
+        shared.clone(),
+        strategy_ingress_rx,
+    );
+    orchestration::spawn_periodic_report_persistor(
+        shared.shadow_stats.clone(),
+        shared.tox_state.clone(),
+        execution.clone(),
+        shared.toxicity_cfg.clone(),
+    );
+    orchestration::spawn_data_reconcile_task(
+        bus.clone(),
+        paused.clone(),
+        shared.shadow_stats.clone(),
+    );
+
+    let app = control_api::build_router(state);
+
+    let addr: SocketAddr = format!("0.0.0.0:{control_port}").parse()?;
+    tracing::info!(%addr, "control api started");
+    let listener = tokio::net::TcpListener::bind(addr)
+        .await
+        .with_context(|| format!("bind control api listener at {addr}"))?;
+    axum::serve(listener, app).await?;
+    Ok(())
+}
+
+pub(super) fn install_rustls_provider() {
+    let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
+}
diff --git a/crates/app_runner/src/config_loader.rs b/crates/app_runner/src/config_loader.rs
new file mode 100644
index 0000000..b3b967d
--- /dev/null
+++ b/crates/app_runner/src/config_loader.rs
@@ -0,0 +1,1841 @@
+use std::fs;
+use std::path::{Path, PathBuf};
+
+use fair_value::BasisMrConfig;
+use risk_engine::RiskLimits;
+use serde::{Deserialize, Serialize};
+use strategy_maker::MakerConfig;
+
+use crate::seat_types::SeatConfig;
+use crate::state::{
+    EdgeModelConfig, ExecutionConfig, ExitConfig, FusionConfig, PerfProfile, PredatorCConfig,
+    PredatorCPriority, SettlementConfig, SourceHealthConfig,
+};
+
+fn strategy_config_path() -> PathBuf {
+    std::env::var("POLYEDGE_STRATEGY_CONFIG_PATH")
+        .ok()
+        .filter(|v| !v.trim().is_empty())
+        .map(PathBuf::from)
+        .unwrap_or_else(|| PathBuf::from("configs/strategy.toml"))
+}
+
+pub(super) fn load_fair_value_config() -> BasisMrConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return BasisMrConfig::default();
+    };
+
+    let mut cfg = BasisMrConfig::default();
+    let mut in_section = false;
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            in_section = line == "[fair_value.basis_mr]";
+            continue;
+        }
+        if !in_section {
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        match key {
+            "enabled" => {
+                if let Ok(parsed) = val.parse::<bool>() {
+                    cfg.enabled = parsed;
+                }
+            }
+            "alpha_mean" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.alpha_mean = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "alpha_var" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.alpha_var = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "alpha_ret" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.alpha_ret = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "alpha_vol" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.alpha_vol = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "k_revert" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.k_revert = parsed.clamp(0.0, 5.0);
+                }
+            }
+            "z_cap" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.z_cap = parsed.clamp(0.5, 8.0);
+                }
+            }
+            "min_confidence" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.min_confidence = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "warmup_ticks" => {
+                if let Ok(parsed) = val.parse::<usize>() {
+                    cfg.warmup_ticks = parsed.max(1);
+                }
+            }
+            _ => {}
+        }
+    }
+    cfg
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(super) struct UniverseConfig {
+    pub(super) assets: Vec<String>,
+    pub(super) market_types: Vec<String>,
+    pub(super) timeframes: Vec<String>,
+    pub(super) tier_whitelist: Vec<String>,
+    pub(super) tier_blacklist: Vec<String>,
+}
+
+impl Default for UniverseConfig {
+    fn default() -> Self {
+        Self {
+            assets: vec![
+                "BTCUSDT".to_string(),
+                "ETHUSDT".to_string(),
+                "SOLUSDT".to_string(),
+                "XRPUSDT".to_string(),
+            ],
+            market_types: vec![
+                "updown".to_string(),
+                "above_below".to_string(),
+                "range".to_string(),
+            ],
+            timeframes: vec![
+                "5m".to_string(),
+                "15m".to_string(),
+                "1h".to_string(),
+                "1d".to_string(),
+            ],
+            tier_whitelist: Vec::new(),
+            tier_blacklist: Vec::new(),
+        }
+    }
+}
+
+fn parse_toml_array_of_strings(val: &str) -> Vec<String> {
+    let trimmed = val.trim();
+    if !(trimmed.starts_with('[') && trimmed.ends_with(']')) {
+        return Vec::new();
+    }
+    let inner = &trimmed[1..trimmed.len() - 1];
+    inner
+        .split(',')
+        .map(|s| s.trim().trim_matches('"').trim_matches('\'').to_string())
+        .filter(|s| !s.is_empty())
+        .collect::<Vec<_>>()
+}
+
+#[cfg(test)]
+pub(crate) fn parse_toml_array_for_key(raw: &str, key: &str) -> Option<Vec<String>> {
+    let Ok(value) = toml::from_str::<toml::Value>(raw) else {
+        return None;
+    };
+    let arr = value.get(key)?.as_array()?;
+    let parsed = arr
+        .iter()
+        .filter_map(|v| v.as_str().map(ToString::to_string))
+        .collect::<Vec<_>>();
+    if parsed.is_empty() {
+        None
+    } else {
+        Some(parsed)
+    }
+}
+
+fn parse_gatling_symbol_section(section: &str) -> Option<String> {
+    const PREFIX: &str = "[predator_c.gatling_symbols.";
+    if !(section.starts_with(PREFIX) && section.ends_with(']')) {
+        return None;
+    }
+    let inner = &section[PREFIX.len()..section.len() - 1];
+    let symbol = inner.trim();
+    if symbol.is_empty() {
+        None
+    } else {
+        Some(symbol.to_string())
+    }
+}
+
+pub(super) fn load_strategy_config() -> MakerConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return MakerConfig::default();
+    };
+    let mut cfg = MakerConfig::default();
+    let mut in_maker = false;
+    let mut in_taker = false;
+    let mut in_online = false;
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            in_maker = line == "[maker]";
+            in_taker = line == "[taker]";
+            in_online = line == "[online_calibration]";
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        if in_maker {
+            match key {
+                "base_quote_size" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.base_quote_size = parsed.max(0.01);
+                    }
+                }
+                "min_edge_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.min_edge_bps = parsed.max(0.0);
+                    }
+                }
+                "inventory_skew" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.inventory_skew = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_spread" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.max_spread = parsed.max(0.0001);
+                    }
+                }
+                "ttl_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.ttl_ms = parsed.max(50);
+                    }
+                }
+                _ => {}
+            }
+        } else if in_taker {
+            match key {
+                "trigger_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_trigger_bps = parsed.max(0.0);
+                    }
+                }
+                "max_slippage_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_max_slippage_bps = parsed.max(0.0);
+                    }
+                }
+                "stale_tick_filter_ms" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.stale_tick_filter_ms = parsed.clamp(50.0, 5_000.0);
+                    }
+                }
+                "market_tier_profile" => {
+                    cfg.market_tier_profile = val.to_string();
+                }
+                _ => {}
+            }
+        } else if in_online {
+            match key {
+                "capital_fraction_kelly" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.capital_fraction_kelly = parsed.clamp(0.01, 1.0);
+                    }
+                }
+                "variance_penalty_lambda" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.variance_penalty_lambda = parsed.clamp(0.0, 5.0);
+                    }
+                }
+                "min_eval_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.min_eval_notional_usdc = parsed.max(0.0);
+                    }
+                }
+                "min_expected_edge_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.min_expected_edge_usdc = parsed.max(0.0);
+                    }
+                }
+                _ => {}
+            }
+        }
+    }
+    cfg
+}
+
+pub(super) fn load_fusion_config() -> FusionConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        let cfg = FusionConfig::default();
+        std::env::set_var(
+            "POLYEDGE_UDP_LOCAL_ONLY",
+            if cfg.udp_local_only { "true" } else { "false" },
+        );
+        return cfg;
+    };
+
+    #[derive(Default)]
+    struct FusionPatch {
+        enable_udp: Option<bool>,
+        mode: Option<String>,
+        udp_port: Option<u16>,
+        dedupe_window_ms: Option<i64>,
+        dedupe_price_bps: Option<f64>,
+        udp_share_cap: Option<f64>,
+        jitter_threshold_ms: Option<f64>,
+        fallback_arm_duration_ms: Option<u64>,
+        fallback_cooldown_sec: Option<u64>,
+        udp_local_only: Option<bool>,
+    }
+
+    impl FusionPatch {
+        fn apply_to(self, cfg: &mut FusionConfig) {
+            if let Some(v) = self.enable_udp {
+                cfg.enable_udp = v;
+            }
+            if let Some(v) = self.mode {
+                cfg.mode = v;
+            }
+            if let Some(v) = self.udp_port {
+                cfg.udp_port = v.max(1);
+            }
+            if let Some(v) = self.dedupe_window_ms {
+                cfg.dedupe_window_ms = v.clamp(0, 2_000);
+            }
+            if let Some(v) = self.dedupe_price_bps {
+                cfg.dedupe_price_bps = v.clamp(0.0, 50.0);
+            }
+            if let Some(v) = self.udp_share_cap {
+                cfg.udp_share_cap = v.clamp(0.05, 0.95);
+            }
+            if let Some(v) = self.jitter_threshold_ms {
+                cfg.jitter_threshold_ms = v.clamp(1.0, 2_000.0);
+            }
+            if let Some(v) = self.fallback_arm_duration_ms {
+                cfg.fallback_arm_duration_ms = v.clamp(200, 15_000);
+            }
+            if let Some(v) = self.fallback_cooldown_sec {
+                cfg.fallback_cooldown_sec = v.clamp(0, 3_600);
+            }
+            if let Some(v) = self.udp_local_only {
+                cfg.udp_local_only = v;
+            }
+        }
+    }
+
+    #[derive(Clone, Copy, PartialEq, Eq)]
+    enum Section {
+        None,
+        Fusion,
+        Transport,
+    }
+
+    let mut cfg = FusionConfig::default();
+    let mut fusion_patch = FusionPatch::default();
+    let mut transport_patch = FusionPatch::default();
+    let mut section = Section::None;
+    let mut saw_fusion = false;
+    let mut saw_transport = false;
+
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            section = match line {
+                "[fusion]" => {
+                    saw_fusion = true;
+                    Section::Fusion
+                }
+                "[transport]" => {
+                    saw_transport = true;
+                    Section::Transport
+                }
+                _ => Section::None,
+            };
+            continue;
+        }
+        if section == Section::None {
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        let target = if section == Section::Transport {
+            &mut transport_patch
+        } else {
+            &mut fusion_patch
+        };
+        match key {
+            "enable_udp" => {
+                if let Ok(parsed) = val.parse::<bool>() {
+                    target.enable_udp = Some(parsed);
+                }
+            }
+            "mode" => {
+                let norm = val.to_ascii_lowercase();
+                if matches!(
+                    norm.as_str(),
+                    "active_active" | "direct_only" | "udp_only" | "websocket_primary"
+                ) {
+                    target.mode = Some(norm);
+                }
+            }
+            "udp_port" => {
+                if let Ok(parsed) = val.parse::<u16>() {
+                    target.udp_port = Some(parsed.max(1));
+                }
+            }
+            "dedupe_window_ms" => {
+                if let Ok(parsed) = val.parse::<i64>() {
+                    target.dedupe_window_ms = Some(parsed.clamp(0, 2_000));
+                }
+            }
+            "dedupe_price_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    target.dedupe_price_bps = Some(parsed.clamp(0.0, 50.0));
+                }
+            }
+            "udp_share_cap" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    target.udp_share_cap = Some(parsed.clamp(0.05, 0.95));
+                }
+            }
+            "jitter_threshold_ms" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    target.jitter_threshold_ms = Some(parsed.clamp(1.0, 2_000.0));
+                }
+            }
+            "fallback_arm_duration_ms" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    target.fallback_arm_duration_ms = Some(parsed.clamp(200, 15_000));
+                }
+            }
+            "fallback_cooldown_sec" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    target.fallback_cooldown_sec = Some(parsed.clamp(0, 3_600));
+                }
+            }
+            "udp_local_only" => {
+                if let Ok(parsed) = val.parse::<bool>() {
+                    target.udp_local_only = Some(parsed);
+                }
+            }
+            _ => {}
+        }
+    }
+
+    fusion_patch.apply_to(&mut cfg);
+    if saw_transport {
+        transport_patch.apply_to(&mut cfg);
+    }
+    if cfg.mode == "websocket_primary" {
+        cfg.udp_local_only = true;
+        cfg.udp_share_cap = cfg.udp_share_cap.clamp(0.05, 0.35);
+        cfg.jitter_threshold_ms = cfg.jitter_threshold_ms.max(25.0);
+        cfg.fallback_arm_duration_ms = cfg.fallback_arm_duration_ms.max(8_000);
+        cfg.fallback_cooldown_sec = cfg.fallback_cooldown_sec.max(300);
+    }
+    if let Ok(raw) = std::env::var("POLYEDGE_UDP_PORT") {
+        if let Ok(parsed) = raw.parse::<u16>() {
+            cfg.udp_port = parsed.max(1);
+        }
+    }
+    if saw_fusion && saw_transport {
+        tracing::warn!(
+            "both [fusion] and [transport] are present; [transport] now takes precedence"
+        );
+    }
+    std::env::set_var(
+        "POLYEDGE_UDP_LOCAL_ONLY",
+        if cfg.udp_local_only { "true" } else { "false" },
+    );
+    cfg
+}
+
+pub(super) fn load_source_health_config() -> SourceHealthConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return SourceHealthConfig::default();
+    };
+    let mut cfg = SourceHealthConfig::default();
+    let mut in_section = false;
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            in_section = line == "[source_health]";
+            continue;
+        }
+        if !in_section {
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        match key {
+            "min_samples" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    cfg.min_samples = parsed.max(1);
+                }
+            }
+            "gap_window_ms" => {
+                if let Ok(parsed) = val.parse::<i64>() {
+                    cfg.gap_window_ms = parsed.clamp(50, 60_000);
+                }
+            }
+            "jitter_limit_ms" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.jitter_limit_ms = parsed.clamp(0.1, 2_000.0);
+                }
+            }
+            "deviation_limit_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.deviation_limit_bps = parsed.clamp(0.1, 10_000.0);
+                }
+            }
+            "freshness_limit_ms" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.freshness_limit_ms = parsed.clamp(50.0, 60_000.0);
+                }
+            }
+            "min_score_for_trading" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.min_score_for_trading = parsed.clamp(0.0, 1.0);
+                }
+            }
+            _ => {}
+        }
+    }
+    cfg
+}
+
+pub(super) fn load_edge_model_config() -> EdgeModelConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return EdgeModelConfig::default();
+    };
+    let mut cfg = EdgeModelConfig::default();
+    let mut in_section = false;
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            in_section = line == "[edge_model]";
+            continue;
+        }
+        if !in_section {
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        match key {
+            "model" => cfg.model = val.to_string(),
+            "gate_mode" => cfg.gate_mode = val.to_string(),
+            "version" => cfg.version = val.to_string(),
+            "base_gate_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.base_gate_bps = parsed.max(0.0);
+                }
+            }
+            "congestion_penalty_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.congestion_penalty_bps = parsed.max(0.0);
+                }
+            }
+            "latency_penalty_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.latency_penalty_bps = parsed.max(0.0);
+                }
+            }
+            "fail_cost_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.fail_cost_bps = parsed.max(0.0);
+                }
+            }
+            _ => {}
+        }
+    }
+    cfg
+}
+
+pub(super) fn load_exit_config() -> ExitConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return ExitConfig::default();
+    };
+    let mut cfg = ExitConfig::default();
+    let mut in_section = false;
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            in_section = line == "[exit]" || line == "[predator_c.exit]";
+            continue;
+        }
+        if !in_section {
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+        match key {
+            "enabled" => {
+                if let Ok(parsed) = val.parse::<bool>() {
+                    cfg.enabled = parsed;
+                }
+            }
+            "t300ms_reversal_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t300ms_reversal_bps = parsed;
+                }
+            }
+            "t100ms_reversal_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t100ms_reversal_bps = parsed;
+                }
+            }
+            "convergence_exit_ratio" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.convergence_exit_ratio = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "time_stop_ms" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    cfg.time_stop_ms = parsed.clamp(50, 600_000);
+                }
+            }
+            "edge_decay_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.edge_decay_bps = parsed;
+                }
+            }
+            "adverse_move_bps" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.adverse_move_bps = parsed;
+                }
+            }
+            "flatten_on_trigger" => {
+                if let Ok(parsed) = val.parse::<bool>() {
+                    cfg.flatten_on_trigger = parsed;
+                }
+            }
+            "t3_take_ratio" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t3_take_ratio = parsed.clamp(0.0, 5.0);
+                }
+            }
+            "t15_min_unrealized_usdc" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t15_min_unrealized_usdc = parsed;
+                }
+            }
+            "t60_true_prob_floor" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t60_true_prob_floor = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "t300_force_exit_ms" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    cfg.t300_force_exit_ms = parsed.clamp(1_000, 1_800_000);
+                }
+            }
+            "t300_hold_prob_threshold" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.t300_hold_prob_threshold = parsed.clamp(0.0, 1.0);
+                }
+            }
+            "t300_hold_time_to_expiry_ms" => {
+                if let Ok(parsed) = val.parse::<u64>() {
+                    cfg.t300_hold_time_to_expiry_ms = parsed.clamp(1_000, 1_800_000);
+                }
+            }
+            "max_single_trade_loss_usdc" => {
+                if let Ok(parsed) = val.parse::<f64>() {
+                    cfg.max_single_trade_loss_usdc = parsed.max(0.0);
+                }
+            }
+            _ => {}
+        }
+    }
+    cfg
+}
+
+pub(super) fn load_predator_c_config() -> PredatorCConfig {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        return PredatorCConfig::default();
+    };
+
+    let mut cfg = PredatorCConfig::default();
+
+    let mut in_root = false;
+    let mut in_dir = false;
+    let mut in_prob = false;
+    let mut in_sniper = false;
+    let mut in_gatling = false;
+    let mut in_strategy_d = false;
+    let mut in_regime = false;
+    let mut in_cross = false;
+    let mut in_router = false;
+    let mut in_compounder = false;
+    let mut in_v52_time_phase = false;
+    let mut in_v52_execution = false;
+    let mut in_v52_dual_arb = false;
+    let mut in_v52_reversal = false;
+    let mut gatling_symbol_section: Option<String> = None;
+
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            gatling_symbol_section = parse_gatling_symbol_section(line);
+            in_root = line == "[predator_c]";
+            in_dir = line == "[predator_c.direction_detector]";
+            in_prob = line == "[predator_c.probability_engine]";
+            in_sniper = line == "[predator_c.taker_sniper]";
+            in_gatling = line == "[predator_c.gatling]";
+            in_strategy_d = line == "[predator_c.strategy_d]";
+            in_regime = line == "[predator_c.regime]";
+            in_cross = line == "[predator_c.cross_symbol]";
+            in_router = line == "[predator_c.router]";
+            in_compounder = line == "[predator_c.compounder]";
+            in_v52_time_phase = line == "[v52.time_phase]" || line == "[predator_c.v52.time_phase]";
+            in_v52_execution = line == "[v52.execution]" || line == "[predator_c.v52.execution]";
+            in_v52_dual_arb = line == "[v52.dual_arb]" || line == "[predator_c.v52.dual_arb]";
+            in_v52_reversal = line == "[v52.reversal]" || line == "[predator_c.v52.reversal]";
+            continue;
+        }
+        if !(in_root
+            || in_dir
+            || in_prob
+            || in_sniper
+            || in_gatling
+            || in_strategy_d
+            || in_regime
+            || in_cross
+            || in_router
+            || in_compounder
+            || in_v52_time_phase
+            || in_v52_execution
+            || in_v52_dual_arb
+            || in_v52_reversal
+            || gatling_symbol_section.is_some())
+        {
+            continue;
+        }
+
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+
+        if in_root {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.enabled = parsed;
+                    }
+                }
+                "priority" => {
+                    let norm = val.trim().to_ascii_lowercase();
+                    cfg.priority = match norm.as_str() {
+                        "maker_first" => PredatorCPriority::MakerFirst,
+                        "taker_first" => PredatorCPriority::TakerFirst,
+                        "taker_only" => PredatorCPriority::TakerOnly,
+                        _ => cfg.priority.clone(),
+                    };
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_dir {
+            match key {
+                "window_max_sec" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.direction_detector.window_max_sec = parsed.max(10);
+                    }
+                }
+                "threshold_5m_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.threshold_5m_pct = parsed.max(0.0);
+                    }
+                }
+                "threshold_15m_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.threshold_15m_pct = parsed.max(0.0);
+                    }
+                }
+                "threshold_1h_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.threshold_1h_pct = parsed.max(0.0);
+                    }
+                }
+                "threshold_1d_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.threshold_1d_pct = parsed.max(0.0);
+                    }
+                }
+                "lookback_short_sec" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.direction_detector.lookback_short_sec = parsed.max(1);
+                    }
+                }
+                "lookback_long_sec" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.direction_detector.lookback_long_sec = parsed.max(1);
+                    }
+                }
+                "min_sources_for_high_confidence" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.direction_detector.min_sources_for_high_confidence = parsed.max(1);
+                    }
+                }
+                "min_ticks_for_signal" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.direction_detector.min_ticks_for_signal = parsed.max(1);
+                    }
+                }
+                "min_consecutive_ticks" => {
+                    if let Ok(parsed) = val.parse::<u8>() {
+                        cfg.direction_detector.min_consecutive_ticks = parsed.max(1);
+                    }
+                }
+                "min_velocity_bps_per_sec" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.min_velocity_bps_per_sec = parsed.max(0.0);
+                    }
+                }
+                "min_acceleration" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.min_acceleration = parsed.max(0.0);
+                    }
+                }
+                "momentum_spike_multiplier" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.momentum_spike_multiplier = parsed.max(1.0);
+                    }
+                }
+                "min_tick_rate_spike_ratio" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.direction_detector.min_tick_rate_spike_ratio = parsed.max(1.0);
+                    }
+                }
+                "tick_rate_short_ms" => {
+                    if let Ok(parsed) = val.parse::<i64>() {
+                        cfg.direction_detector.tick_rate_short_ms = parsed.clamp(50, 10_000);
+                    }
+                }
+                "tick_rate_long_ms" => {
+                    if let Ok(parsed) = val.parse::<i64>() {
+                        cfg.direction_detector.tick_rate_long_ms = parsed.clamp(100, 60_000);
+                    }
+                }
+                "enable_source_vote_gate" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.direction_detector.enable_source_vote_gate = parsed;
+                    }
+                }
+                "require_secondary_confirmation" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.direction_detector.require_secondary_confirmation = parsed;
+                    }
+                }
+                "source_vote_max_age_ms" => {
+                    if let Ok(parsed) = val.parse::<i64>() {
+                        cfg.direction_detector.source_vote_max_age_ms = parsed.clamp(50, 60_000);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_prob {
+            match key {
+                "momentum_gain" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.momentum_gain = parsed.clamp(0.0, 20.0);
+                    }
+                }
+                "lag_penalty_per_ms" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.lag_penalty_per_ms = parsed.clamp(0.0, 0.1);
+                    }
+                }
+                "confidence_floor" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.confidence_floor = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "sigma_annual" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.sigma_annual = parsed.clamp(0.05, 5.0);
+                    }
+                }
+                "horizon_sec" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.horizon_sec = parsed.clamp(1.0, 900.0);
+                    }
+                }
+                "drift_annual" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.drift_annual = parsed.clamp(-10.0, 10.0);
+                    }
+                }
+                "velocity_drift_gain" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.velocity_drift_gain = parsed.clamp(0.0, 5.0);
+                    }
+                }
+                "acceleration_drift_gain" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.acceleration_drift_gain = parsed.clamp(0.0, 5.0);
+                    }
+                }
+                "fair_blend_weight" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.probability_engine.fair_blend_weight = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_sniper || in_gatling {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.taker_sniper.gatling_enabled = parsed;
+                    }
+                }
+                "min_direction_confidence" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_sniper.min_direction_confidence = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "min_edge_net_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_sniper.min_edge_net_bps = parsed.max(0.0);
+                    }
+                }
+                "max_spread" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_sniper.max_spread = parsed.max(0.0001);
+                    }
+                }
+                "cooldown_ms_per_market" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.taker_sniper.cooldown_ms_per_market = parsed;
+                    }
+                }
+                "gatling_enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.taker_sniper.gatling_enabled = parsed;
+                    }
+                }
+                "chunk_notional_usdc" | "gatling_chunk_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.taker_sniper.gatling_chunk_notional_usdc = parsed.max(0.1);
+                    }
+                }
+                "min_chunks" | "gatling_min_chunks" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.taker_sniper.gatling_min_chunks = parsed.max(1);
+                    }
+                }
+                "max_chunks" | "gatling_max_chunks" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.taker_sniper.gatling_max_chunks = parsed.max(1);
+                    }
+                }
+                "spacing_ms" | "gatling_spacing_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.taker_sniper.gatling_spacing_ms = parsed.min(250);
+                    }
+                }
+                "stop_on_reject" | "gatling_stop_on_reject" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.taker_sniper.gatling_stop_on_reject = parsed;
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_strategy_d {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.strategy_d.enabled = parsed;
+                    }
+                }
+                "min_gap_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.strategy_d.min_gap_bps = parsed.max(0.0);
+                    }
+                }
+                "min_edge_net_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.strategy_d.min_edge_net_bps = parsed.max(0.0);
+                    }
+                }
+                "min_confidence" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.strategy_d.min_confidence = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.strategy_d.max_notional_usdc = parsed.max(0.0);
+                    }
+                }
+                "cooldown_ms_per_market" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.strategy_d.cooldown_ms_per_market = parsed;
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if let Some(symbol) = gatling_symbol_section.as_deref() {
+            let entry = cfg
+                .taker_sniper
+                .gatling_by_symbol
+                .entry(symbol.to_ascii_uppercase())
+                .or_default();
+            match key {
+                "enabled" | "gatling_enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        entry.enabled = Some(parsed);
+                    }
+                }
+                "chunk_notional_usdc" | "gatling_chunk_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        entry.chunk_notional_usdc = Some(parsed.max(0.01));
+                    }
+                }
+                "min_chunks" | "gatling_min_chunks" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        entry.min_chunks = Some(parsed.max(1));
+                    }
+                }
+                "max_chunks" | "gatling_max_chunks" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        entry.max_chunks = Some(parsed.max(1));
+                    }
+                }
+                "spacing_ms" | "gatling_spacing_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        entry.spacing_ms = Some(parsed.min(1_000));
+                    }
+                }
+                "stop_on_reject" | "gatling_stop_on_reject" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        entry.stop_on_reject = Some(parsed);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_regime {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.regime.enabled = parsed;
+                    }
+                }
+                "active_min_confidence" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.active_min_confidence = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "active_min_magnitude_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.active_min_magnitude_pct = parsed.max(0.0);
+                    }
+                }
+                "defend_tox_score" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.defend_tox_score = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "defend_on_toxic_danger" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.regime.defend_on_toxic_danger = parsed;
+                    }
+                }
+                "defend_min_source_health" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.defend_min_source_health = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "quiet_min_edge_multiplier" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.quiet_min_edge_multiplier = parsed.clamp(1.0, 10.0);
+                    }
+                }
+                "quiet_chunk_scale" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.regime.quiet_chunk_scale = parsed.clamp(0.05, 1.0);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_cross {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.cross_symbol.enabled = parsed;
+                    }
+                }
+                "leader_symbol" => {
+                    cfg.cross_symbol.leader_symbol = val.trim().to_string();
+                }
+                "follower_symbols" => {
+                    let parsed = parse_toml_array_of_strings(v.trim());
+                    if !parsed.is_empty() {
+                        cfg.cross_symbol.follower_symbols = parsed;
+                    }
+                }
+                "min_leader_confidence" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.cross_symbol.min_leader_confidence = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "min_leader_magnitude_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.cross_symbol.min_leader_magnitude_pct = parsed.max(0.0);
+                    }
+                }
+                "follower_stale_confidence_max" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.cross_symbol.follower_stale_confidence_max = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_correlated_positions" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.cross_symbol.max_correlated_positions = parsed.max(1);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_router {
+            match key {
+                "max_locked_pct_5m" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_locked_pct_5m = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_locked_pct_15m" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_locked_pct_15m = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_locked_pct_1h" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_locked_pct_1h = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_locked_pct_1d" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_locked_pct_1d = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "max_concurrent_positions" => {
+                    if let Ok(parsed) = val.parse::<usize>() {
+                        cfg.router.max_concurrent_positions = parsed.max(1);
+                    }
+                }
+                "liquidity_reserve_pct" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.liquidity_reserve_pct = parsed.clamp(0.0, 0.95);
+                    }
+                }
+                "max_order_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_order_notional_usdc = parsed.max(0.0);
+                    }
+                }
+                "max_total_notional_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.router.max_total_notional_usdc = parsed.max(0.0);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_compounder {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.compounder.enabled = parsed;
+                    }
+                }
+                "initial_capital_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.compounder.initial_capital_usdc = parsed.max(0.0);
+                    }
+                }
+                "compound_ratio" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.compounder.compound_ratio = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "position_fraction" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.compounder.position_fraction = parsed.clamp(0.0, 1.0);
+                    }
+                }
+                "min_quote_size" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.compounder.min_quote_size = parsed.max(0.0);
+                    }
+                }
+                "daily_loss_cap_usdc" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.compounder.daily_loss_cap_usdc = parsed.max(0.0);
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_v52_time_phase {
+            match key {
+                "early_min_ratio" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.time_phase.early_min_ratio = parsed;
+                    }
+                }
+                "late_max_ratio" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.time_phase.late_max_ratio = parsed;
+                    }
+                }
+                "early_size_scale" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.time_phase.early_size_scale = parsed;
+                    }
+                }
+                "maturity_size_scale" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.time_phase.maturity_size_scale = parsed;
+                    }
+                }
+                "late_size_scale" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.time_phase.late_size_scale = parsed;
+                    }
+                }
+                "allow_timeframes" => {
+                    let parsed = parse_toml_array_of_strings(v.trim())
+                        .into_iter()
+                        .map(|s| s.to_ascii_lowercase())
+                        .collect::<Vec<_>>();
+                    if !parsed.is_empty() {
+                        cfg.v52.time_phase.allow_timeframes = parsed;
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_v52_execution {
+            match key {
+                "late_force_taker_remaining_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.v52.execution.late_force_taker_remaining_ms = parsed;
+                    }
+                }
+                "maker_wait_ms_before_force" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.v52.execution.maker_wait_ms_before_force = parsed;
+                    }
+                }
+                "apply_force_taker_in_maturity" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.execution.apply_force_taker_in_maturity = parsed;
+                    }
+                }
+                "apply_force_taker_in_late" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.execution.apply_force_taker_in_late = parsed;
+                    }
+                }
+                "alpha_window_enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.execution.alpha_window_enabled = parsed;
+                    }
+                }
+                "alpha_window_move_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.execution.alpha_window_move_bps = parsed;
+                    }
+                }
+                "alpha_window_poll_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.v52.execution.alpha_window_poll_ms = parsed;
+                    }
+                }
+                "alpha_window_max_wait_ms" => {
+                    if let Ok(parsed) = val.parse::<u64>() {
+                        cfg.v52.execution.alpha_window_max_wait_ms = parsed;
+                    }
+                }
+                "require_compounder_when_live" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.execution.require_compounder_when_live = parsed;
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_v52_dual_arb {
+            match key {
+                "enabled" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.dual_arb.enabled = parsed;
+                    }
+                }
+                "safety_margin_bps" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.dual_arb.safety_margin_bps = parsed;
+                    }
+                }
+                "threshold" => {
+                    if let Ok(parsed) = val.parse::<f64>() {
+                        cfg.v52.dual_arb.threshold = parsed;
+                    }
+                }
+                "fee_buffer_mode" => {
+                    cfg.v52.dual_arb.fee_buffer_mode = val.trim().to_ascii_lowercase();
+                }
+                _ => {}
+            }
+            continue;
+        }
+
+        if in_v52_reversal {
+            match key {
+                "same_market_opposite_first" => {
+                    if let Ok(parsed) = val.parse::<bool>() {
+                        cfg.v52.reversal.same_market_opposite_first = parsed;
+                    }
+                }
+                _ => {}
+            }
+            continue;
+        }
+    }
+
+    cfg.v52.time_phase.early_min_ratio = cfg.v52.time_phase.early_min_ratio.clamp(0.11, 0.99);
+    cfg.v52.time_phase.late_max_ratio = cfg.v52.time_phase.late_max_ratio.clamp(0.01, 0.54);
+    cfg.v52.time_phase.early_size_scale = cfg.v52.time_phase.early_size_scale.clamp(0.10, 5.0);
+    cfg.v52.time_phase.maturity_size_scale =
+        cfg.v52.time_phase.maturity_size_scale.clamp(0.10, 5.0);
+    cfg.v52.time_phase.late_size_scale = cfg.v52.time_phase.late_size_scale.clamp(0.10, 5.0);
+    if cfg.v52.time_phase.late_max_ratio >= cfg.v52.time_phase.early_min_ratio {
+        cfg.v52.time_phase.late_max_ratio = 0.10;
+        cfg.v52.time_phase.early_min_ratio = 0.55;
+    }
+    cfg.v52.time_phase.allow_timeframes = cfg
+        .v52
+        .time_phase
+        .allow_timeframes
+        .iter()
+        .map(|s| s.to_ascii_lowercase())
+        .filter(|s| s == "5m" || s == "15m")
+        .collect::<Vec<_>>();
+    if cfg.v52.time_phase.allow_timeframes.is_empty() {
+        cfg.v52.time_phase.allow_timeframes = vec!["5m".to_string(), "15m".to_string()];
+    }
+    cfg.v52.execution.late_force_taker_remaining_ms =
+        cfg.v52.execution.late_force_taker_remaining_ms.clamp(1_000, 60_000);
+    cfg.v52.execution.maker_wait_ms_before_force =
+        cfg.v52.execution.maker_wait_ms_before_force.clamp(50, 10_000);
+    cfg.v52.execution.alpha_window_move_bps =
+        cfg.v52.execution.alpha_window_move_bps.clamp(0.1, 50.0);
+    cfg.v52.execution.alpha_window_poll_ms = cfg.v52.execution.alpha_window_poll_ms.clamp(1, 200);
+    cfg.v52.execution.alpha_window_max_wait_ms =
+        cfg.v52.execution.alpha_window_max_wait_ms.clamp(50, 5_000);
+    cfg.v52.dual_arb.safety_margin_bps = cfg.v52.dual_arb.safety_margin_bps.clamp(0.0, 100.0);
+    cfg.v52.dual_arb.threshold = cfg.v52.dual_arb.threshold.clamp(0.50, 1.10);
+    if cfg.v52.dual_arb.fee_buffer_mode != "conservative_taker" {
+        cfg.v52.dual_arb.fee_buffer_mode = "conservative_taker".to_string();
+    }
+
+    cfg
+}
+
+pub(super) fn load_risk_limits_config() -> RiskLimits {
+    let path = strategy_config_path();
+    let Ok(raw) = fs::read_to_string(path) else {
+        println!("Warn: strategy.toml not found for risk config, using defaults");
+        return RiskLimits::default();
+    };
+
+    // Conservative fallback values when parsing is partial or malformed.
+    // Keep defaults via struct update syntax to avoid piecemeal re-assignment.
+    let mut cfg = RiskLimits {
+        max_drawdown_pct: 0.20,
+        max_asset_notional: 50.0,
+        max_market_notional: 10.0,
+        ..RiskLimits::default()
+    };
+
+    let mut section = "";
+    for line in raw.lines() {
+        let line = line.trim();
+        if line.is_empty() || line.starts_with('#') {
+            continue;
+        }
+        if line.starts_with('[') && line.ends_with(']') {
+            section = line;
+            continue;
+        }
+        let Some((k, v)) = line.split_once('=') else {
+            continue;
+        };
+        let key = k.trim();
+        let val = v.trim().trim_matches('"');
+
+        match section {
+            "[risk_controls.exposure_limits]" => match key {
+                "max_total_exposure_usdc" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.max_asset_notional = p.max(0.0);
+                    }
+                }
+                "max_per_market_exposure_usdc" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.max_market_notional = p.max(0.0);
+                    }
+                }
+                "max_concurrent_positions" => {
+                    if let Ok(p) = val.parse::<usize>() {
+                        cfg.max_open_orders = p.max(1);
+                    }
+                }
+                _ => {}
+            },
+            "[risk_controls.kill_switch]" => match key {
+                "max_drawdown_pct" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.max_drawdown_pct = p.clamp(0.001, 1.0);
+                    }
+                }
+                "max_loss_streak" => {
+                    if let Ok(p) = val.parse::<u32>() {
+                        cfg.max_loss_streak = p.max(1);
+                    }
+                }
+                "cooldown_sec" => {
+                    if let Ok(p) = val.parse::<u64>() {
+                        cfg.cooldown_sec = p.max(1);
+                    }
+                }
+                _ => {}
+            },
+            "[risk_controls.progressive_limits]" => match key {
+                "enabled" => {
+                    if let Ok(p) = val.parse::<bool>() {
+                        cfg.progressive_enabled = p;
+                    }
+                }
+                "drawdown_tier1_ratio" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.drawdown_tier1_ratio = p.clamp(0.05, 0.99);
+                    }
+                }
+                "drawdown_tier2_ratio" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.drawdown_tier2_ratio = p.clamp(cfg.drawdown_tier1_ratio, 0.999);
+                    }
+                }
+                "tier1_size_scale" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.tier1_size_scale = p.clamp(0.01, 1.0);
+                    }
+                }
+                "tier2_size_scale" => {
+                    if let Ok(p) = val.parse::<f64>() {
+                        cfg.tier2_size_scale = p.clamp(0.01, 1.0);
+                    }
+                }
+                _ => {}
+            },
+            _ => {}
+        }
+    }
+    cfg
+}
+
+pub(super) fn load_execution_config() -> ExecutionConfig {
+    let path = Path::new("configs/execution.toml");
+    let Ok(raw) = fs::read_to_string(path) else {
+        return ExecutionConfig::default();
+    };
+    #[derive(Debug, Deserialize, Default)]
+    struct ExecutionFile {
+        execution: Option<ExecutionSection>,
+    }
+
+    #[derive(Debug, Deserialize, Default)]
+    struct ExecutionSection {
+        mode: Option<String>,
+        rate_limit_rps: Option<f64>,
+        http_timeout_ms: Option<u64>,
+        clob_endpoint: Option<String>,
+        order_endpoint: Option<String>,
+        order_backup_endpoint: Option<String>,
+        order_failover_timeout_ms: Option<u64>,
+    }
+
+    let Ok(parsed) = toml::from_str::<ExecutionFile>(&raw) else {
+        return ExecutionConfig::default();
+    };
+    let Some(section) = parsed.execution else {
+        return ExecutionConfig::default();
+    };
+    let mut cfg = ExecutionConfig::default();
+    if let Some(v) = section.mode {
+        cfg.mode = v;
+    }
+    if let Some(v) = section.rate_limit_rps {
+        cfg.rate_limit_rps = v.max(0.1);
+    }
+    if let Some(v) = section.http_timeout_ms {
+        cfg.http_timeout_ms = v.max(100);
+    }
+    if let Some(v) = section.clob_endpoint {
+        cfg.clob_endpoint = v;
+    }
+    if let Some(v) = section.order_endpoint {
+        cfg.order_endpoint = (!v.trim().is_empty()).then_some(v);
+    }
+    if let Some(v) = section.order_backup_endpoint {
+        cfg.order_backup_endpoint = (!v.trim().is_empty()).then_some(v);
+    }
+    if let Some(v) = section.order_failover_timeout_ms {
+        cfg.order_failover_timeout_ms = v.clamp(10, 5_000);
+    }
+    cfg
+}
+
+pub(super) fn load_settlement_config() -> SettlementConfig {
+    let path = Path::new("configs/settlement.toml");
+    let Ok(raw) = fs::read_to_string(path) else {
+        return SettlementConfig::default();
+    };
+    #[derive(Debug, Deserialize, Default)]
+    struct SettlementFile {
+        settlement: Option<SettlementSection>,
+    }
+
+    #[derive(Debug, Deserialize, Default)]
+    struct SettlementSection {
+        enabled: Option<bool>,
+        endpoint: Option<String>,
+        required_for_live: Option<bool>,
+        poll_interval_ms: Option<u64>,
+        timeout_ms: Option<u64>,
+        symbols: Option<Vec<String>>,
+    }
+
+    let Ok(parsed) = toml::from_str::<SettlementFile>(&raw) else {
+        return SettlementConfig::default();
+    };
+    let Some(section) = parsed.settlement else {
+        return SettlementConfig::default();
+    };
+    let mut cfg = SettlementConfig::default();
+    if let Some(v) = section.enabled {
+        cfg.enabled = v;
+    }
+    if let Some(v) = section.endpoint {
+        cfg.endpoint = v;
+    }
+    if let Some(v) = section.required_for_live {
+        cfg.required_for_live = v;
+    }
+    if let Some(v) = section.poll_interval_ms {
+        cfg.poll_interval_ms = v.clamp(250, 10_000);
+    }
+    if let Some(v) = section.timeout_ms {
+        cfg.timeout_ms = v.clamp(100, 5_000);
+    }
+    if let Some(v) = section.symbols {
+        cfg.symbols = v;
+    }
+    cfg
+}
+
+pub(super) fn load_universe_config() -> UniverseConfig {
+    let path = Path::new("configs/universe.toml");
+    let Ok(raw) = fs::read_to_string(path) else {
+        return UniverseConfig::default();
+    };
+    #[derive(Debug, Deserialize, Default)]
+    struct UniverseFile {
+        assets: Option<Vec<String>>,
+        market_types: Option<Vec<String>>,
+        timeframes: Option<Vec<String>>,
+        tier_whitelist: Option<Vec<String>>,
+        tier_blacklist: Option<Vec<String>>,
+    }
+
+    let Ok(parsed) = toml::from_str::<UniverseFile>(&raw) else {
+        return UniverseConfig::default();
+    };
+    let mut cfg = UniverseConfig::default();
+    if let Some(v) = parsed.assets {
+        cfg.assets = v;
+    }
+    if let Some(v) = parsed.market_types {
+        cfg.market_types = v;
+    }
+    if let Some(v) = parsed.timeframes {
+        cfg.timeframes = v;
+    }
+    if let Some(v) = parsed.tier_whitelist {
+        cfg.tier_whitelist = v;
+    }
+    if let Some(v) = parsed.tier_blacklist {
+        cfg.tier_blacklist = v;
+    }
+    cfg
+}
+
+pub(super) fn load_perf_profile_config() -> PerfProfile {
+    let path = Path::new("configs/latency.toml");
+    let Ok(raw) = fs::read_to_string(path) else {
+        return PerfProfile::default();
+    };
+    #[derive(Debug, Deserialize, Default)]
+    struct LatencyFile {
+        runtime: Option<RuntimeSection>,
+    }
+
+    #[derive(Debug, Deserialize, Default)]
+    struct RuntimeSection {
+        tail_guard: Option<f64>,
+        io_flush_batch: Option<usize>,
+        io_queue_capacity: Option<usize>,
+        json_mode: Option<String>,
+        io_drop_on_full: Option<bool>,
+    }
+
+    let Ok(parsed) = toml::from_str::<LatencyFile>(&raw) else {
+        return PerfProfile::default();
+    };
+    let Some(section) = parsed.runtime else {
+        return PerfProfile::default();
+    };
+    let mut cfg = PerfProfile::default();
+    if let Some(v) = section.tail_guard {
+        cfg.tail_guard = v.clamp(0.50, 0.9999);
+    }
+    if let Some(v) = section.io_flush_batch {
+        cfg.io_flush_batch = v.clamp(1, 4096);
+    }
+    if let Some(v) = section.io_queue_capacity {
+        cfg.io_queue_capacity = v.clamp(256, 262_144);
+    }
+    if let Some(v) = section.json_mode {
+        cfg.json_mode = v;
+    }
+    if let Some(v) = section.io_drop_on_full {
+        cfg.io_drop_on_full = v;
+    }
+    cfg
+}
+
+pub(super) fn load_seat_config() -> SeatConfig {
+    let path = Path::new("configs/seat.toml");
+    let Ok(raw) = fs::read_to_string(path) else {
+        let mut cfg = SeatConfig::default();
+        if let Ok(url) = std::env::var("POLYEDGE_SEAT_OPTIMIZER_URL") {
+            if !url.trim().is_empty() {
+                cfg.optimizer_url = url;
+            }
+        }
+        return cfg;
+    };
+
+    #[derive(Debug, Deserialize, Default)]
+    struct SeatFile {
+        seat: Option<SeatSection>,
+    }
+
+    #[derive(Debug, Deserialize, Default)]
+    struct SeatSection {
+        enabled: Option<bool>,
+        control_base_url: Option<String>,
+        optimizer_url: Option<String>,
+        runtime_tick_sec: Option<u64>,
+        activation_check_sec: Option<u64>,
+        layer1_interval_sec: Option<u64>,
+        layer2_interval_sec: Option<u64>,
+        layer3_interval_sec: Option<u64>,
+        layer2_shadow_sec: Option<u64>,
+        layer3_shadow_sec: Option<u64>,
+        smoothing_sec: Option<u64>,
+        monitor_sec: Option<u64>,
+        rollback_pause_sec: Option<u64>,
+        global_pause_sec: Option<u64>,
+        layer0_lock_sec: Option<u64>,
+        layer1_min_trades: Option<u64>,
+        layer2_min_trades: Option<u64>,
+        layer2_min_uptime_sec: Option<u64>,
+        layer3_min_trades: Option<u64>,
+        layer3_min_uptime_sec: Option<u64>,
+        black_swan_lock_sec: Option<u64>,
+        source_health_floor: Option<f64>,
+        history_retention_days: Option<u32>,
+        objective_drawdown_penalty: Option<f64>,
+    }
+
+    let Ok(parsed) = toml::from_str::<SeatFile>(&raw) else {
+        return SeatConfig::default();
+    };
+    let Some(section) = parsed.seat else {
+        return SeatConfig::default();
+    };
+    let mut cfg = SeatConfig::default();
+    if let Some(v) = section.enabled {
+        cfg.enabled = v;
+    }
+    if let Some(v) = section.control_base_url {
+        cfg.control_base_url = v;
+    }
+    if let Some(v) = section.optimizer_url {
+        cfg.optimizer_url = v;
+    }
+    if let Some(v) = section.runtime_tick_sec {
+        cfg.runtime_tick_sec = v.clamp(5, 300);
+    }
+    if let Some(v) = section.activation_check_sec {
+        cfg.activation_check_sec = v.clamp(60, 86_400);
+    }
+    if let Some(v) = section.layer1_interval_sec {
+        cfg.layer1_interval_sec = v.clamp(60, 86_400);
+    }
+    if let Some(v) = section.layer2_interval_sec {
+        cfg.layer2_interval_sec = v.clamp(300, 86_400);
+    }
+    if let Some(v) = section.layer3_interval_sec {
+        cfg.layer3_interval_sec = v.clamp(900, 7 * 86_400);
+    }
+    if let Some(v) = section.layer2_shadow_sec {
+        cfg.layer2_shadow_sec = v.clamp(60, 8 * 3_600);
+    }
+    if let Some(v) = section.layer3_shadow_sec {
+        cfg.layer3_shadow_sec = v.clamp(6_000, 12 * 3_600);
+    }
+    if let Some(v) = section.smoothing_sec {
+        cfg.smoothing_sec = v.clamp(60, 12 * 3_600);
+    }
+    if let Some(v) = section.monitor_sec {
+        cfg.monitor_sec = v.clamp(60, 24 * 3_600);
+    }
+    if let Some(v) = section.rollback_pause_sec {
+        cfg.rollback_pause_sec = v.clamp(60, 7 * 24 * 3_600);
+    }
+    if let Some(v) = section.global_pause_sec {
+        cfg.global_pause_sec = v.clamp(60, 14 * 24 * 3_600);
+    }
+    if let Some(v) = section.layer0_lock_sec {
+        cfg.layer0_lock_sec = v.clamp(60, 14 * 24 * 3_600);
+    }
+    if let Some(v) = section.layer1_min_trades {
+        cfg.layer1_min_trades = v.max(1);
+    }
+    if let Some(v) = section.layer2_min_trades {
+        cfg.layer2_min_trades = v.max(cfg.layer1_min_trades);
+    }
+    if let Some(v) = section.layer2_min_uptime_sec {
+        cfg.layer2_min_uptime_sec = v.max(3_600);
+    }
+    if let Some(v) = section.layer3_min_trades {
+        cfg.layer3_min_trades = v.max(cfg.layer2_min_trades);
+    }
+    if let Some(v) = section.layer3_min_uptime_sec {
+        cfg.layer3_min_uptime_sec = v.max(24 * 3_600);
+    }
+    if let Some(v) = section.black_swan_lock_sec {
+        cfg.black_swan_lock_sec = v.clamp(60, 14 * 24 * 3_600);
+    }
+    if let Some(v) = section.source_health_floor {
+        cfg.source_health_floor = v.clamp(0.0, 1.0);
+    }
+    if let Some(v) = section.history_retention_days {
+        cfg.history_retention_days = v.clamp(7, 720);
+    }
+    if let Some(v) = section.objective_drawdown_penalty {
+        cfg.objective_drawdown_penalty = v.clamp(0.1, 100.0);
+    }
+    if let Ok(url) = std::env::var("POLYEDGE_SEAT_OPTIMIZER_URL") {
+        if !url.trim().is_empty() {
+            cfg.optimizer_url = url;
+        }
+    }
+    cfg
+}
diff --git a/crates/app_runner/src/control_api.rs b/crates/app_runner/src/control_api.rs
index c707414..a52fada 100644
--- a/crates/app_runner/src/control_api.rs
+++ b/crates/app_runner/src/control_api.rs
@@ -1,25 +1,85 @@
-use super::*;
+use std::collections::HashMap;
+use std::sync::atomic::Ordering;
+
+use axum::extract::{Query, State};
+use axum::http::StatusCode;
+use axum::response::IntoResponse;
+use axum::routing::{get, post};
+use axum::{Json, Router};
+use chrono::Utc;
+use core_types::{ControlCommand, EngineEvent, ExecutionVenue, PaperDailySummary, PaperTradeRecord, ToxicRegime};
+use direction_detector::DirectionConfig;
+use fair_value::BasisMrConfig;
+use probability_engine::ProbabilityEngineConfig;
+use serde::{Deserialize, Serialize};
+use settlement_compounder::{CompounderConfig, SettlementCompounder};
+use taker_sniper::{TakerSniper, TakerSniperConfig};
+use timeframe_router::{RouterConfig, TimeframeRouter};
+
+use crate::report_io::{
+    append_jsonl, dataset_path, persist_engine_pnl_report, persist_final_report_files,
+    persist_live_report_files, persist_toxicity_report_files, JSONL_DROP_ON_FULL,
+};
+use crate::state::{
+    settlement_live_gate_status, to_exit_manager_config, AllocatorConfig, AllocatorReloadReq,
+    AllocatorReloadResp, AppState, EdgeModelConfig, EdgeModelReloadReq, EnginePnlReport,
+    ExitConfig, ExitReloadReq, FusionConfig, FusionReloadReq, HealthResp, PerfProfile,
+    PerfProfileReloadReq, PredatorCConfig, PredatorCPriority, PredatorCrossSymbolConfig,
+    PredatorDConfig, PredatorRegimeConfig, ProbabilityReloadReq, RiskReloadReq, RiskReloadResp,
+    ShadowFinalReport, ShadowLiveReport, SourceHealthConfig, SourceHealthReloadReq,
+    StrategyReloadReq, StrategyReloadResp, TakerReloadReq, TakerReloadResp, ToxicityConfig,
+    ToxicityFinalReport, ToxicityLiveReport, ToxicityReloadReq,
+    V52Config, V52DualArbConfig, V52ExecutionConfig, V52ReversalConfig, V52TimePhaseConfig,
+};
+use crate::seat_types::{SeatForceLayerReq, SeatManualOverrideReq};
+use crate::stats_utils::percentile;
+use crate::toxicity_report::build_toxicity_live_report;
 
 pub(super) fn build_router(state: AppState) -> Router {
     Router::new()
         .route("/health", get(health))
+        .route("/health/latency", get(health_latency)) // P4: lightweight latency probe
         .route("/metrics", get(metrics))
         .route("/state/positions", get(positions))
         .route("/state/pnl", get(pnl))
         .route("/report/shadow/live", get(report_shadow_live))
         .route("/report/shadow/final", get(report_shadow_final))
         .route("/report/pnl/by_engine", get(report_pnl_by_engine))
+        .route("/report/direction", get(report_direction))
+        .route("/report/router", get(report_router))
+        .route("/report/capital", get(report_capital))
         .route("/report/toxicity/live", get(report_toxicity_live))
         .route("/report/toxicity/final", get(report_toxicity_final))
+        .route("/report/seat/status", get(report_seat_status))
+        .route("/report/seat/history", get(report_seat_history))
+        .route("/report/paper/live", get(report_paper_live))
+        .route("/report/paper/history", get(report_paper_history))
+        .route("/report/paper/daily", get(report_paper_daily))
+        .route("/report/paper/summary", get(report_paper_summary))
         .route("/control/pause", post(pause))
         .route("/control/resume", post(resume))
         .route("/control/flatten", post(flatten))
+        .route("/control/arm_live", post(arm_live))
+        .route("/control/seat/pause", post(seat_pause))
+        .route("/control/seat/resume", post(seat_resume))
+        .route("/control/seat/force_layer", post(seat_force_layer))
+        .route("/control/seat/manual_override", post(seat_manual_override))
+        .route("/control/seat/clear_override", post(seat_clear_override))
+        .route("/control/paper/reset", post(reset_paper))
         .route("/control/reset_shadow", post(reset_shadow))
         .route("/control/reload_strategy", post(reload_strategy))
         .route("/control/reload_taker", post(reload_taker))
         .route("/control/reload_allocator", post(reload_allocator))
         .route("/control/reload_toxicity", post(reload_toxicity))
         .route("/control/reload_risk", post(reload_risk))
+        .route("/control/reload_predator_c", post(reload_predator_c))
+        .route("/control/reload_fusion", post(reload_fusion))
+        .route("/control/reload_edge_model", post(reload_edge_model))
+        .route("/control/reload_probability", post(reload_probability))
+        .route("/control/reload_source_health", post(reload_source_health))
+        .route("/control/reload_exit", post(reload_exit))
+        .route("/control/reload_exit_manager", post(reload_exit))
+        .route("/control/reload_regime", post(reload_regime))
         .route("/control/reload_perf_profile", post(reload_perf_profile))
         .with_state(state)
 }
@@ -32,6 +92,22 @@ async fn health(State(state): State<AppState>) -> Json<HealthResp> {
     })
 }
 
+// P4: lightweight latency probe endpoint.
+// Used by storm_test to measure realistic HTTP RTT with minimal server-side work.
+async fn health_latency(State(state): State<AppState>) -> Json<serde_json::Value> {
+    let paused = *state.paused.read().await;
+    let now = std::time::Instant::now();
+
+    // Keep this handler intentionally small and allocation-light.
+    Json(serde_json::json!({
+        "status": "ok",
+        "paused": paused,
+        "timestamp_ms": chrono::Utc::now().timestamp_millis(),
+        "probe_latency_us": now.elapsed().as_micros() as u64,
+        "note": "lightweight endpoint for storm-test RTT probing"
+    }))
+}
+
 async fn metrics(State(state): State<AppState>) -> impl IntoResponse {
     (
         StatusCode::OK,
@@ -82,55 +158,668 @@ async fn flatten(State(state): State<AppState>) -> impl IntoResponse {
     }
 }
 
+#[derive(Debug, Deserialize)]
+struct ArmLiveReq {
+    armed: Option<bool>,
+}
+
+async fn arm_live(State(state): State<AppState>, Json(req): Json<ArmLiveReq>) -> impl IntoResponse {
+    let force_paper = std::env::var("POLYEDGE_FORCE_PAPER")
+        .ok()
+        .map(|v| {
+            let normalized = v.trim().to_ascii_lowercase();
+            matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
+        })
+        .unwrap_or(false);
+    if force_paper {
+        return (
+            StatusCode::BAD_REQUEST,
+            Json(serde_json::json!({
+                "ok": false,
+                "armed": false,
+                "error": "force_paper_guard_enabled",
+            })),
+        )
+            .into_response();
+    }
+
+    let armed = req.armed.unwrap_or(true);
+    if !armed {
+        std::env::set_var("POLYEDGE_LIVE_ARMED", "false");
+        return Json(
+            serde_json::json!({"ok": true, "armed": false, "execution_live": state.execution.is_live()}),
+        )
+        .into_response();
+    }
+
+    let settlement_cfg = state.shared.settlement_cfg.read().await.clone();
+    let gate = settlement_live_gate_status(&settlement_cfg);
+    if !gate.ready {
+        return (
+            StatusCode::BAD_REQUEST,
+            Json(serde_json::json!({
+                "ok": false,
+                "armed": false,
+                "error": "settlement_live_gate_failed",
+                "reason": gate.reason,
+            })),
+        )
+            .into_response();
+    }
+
+    std::env::set_var("POLYEDGE_LIVE_ARMED", "true");
+    let execution_live = state.execution.is_live();
+    let payload = serde_json::json!({
+        "ok": true,
+        "armed": true,
+        "execution_live": execution_live,
+        "restart_required": !execution_live,
+    });
+    if execution_live {
+        Json(payload).into_response()
+    } else {
+        (StatusCode::ACCEPTED, Json(payload)).into_response()
+    }
+}
+
+async fn seat_pause(State(state): State<AppState>) -> impl IntoResponse {
+    let status = state.seat.pause("manual_pause".to_string()).await;
+    Json(serde_json::json!({"ok": true, "status": status}))
+}
+
+async fn seat_resume(State(state): State<AppState>) -> impl IntoResponse {
+    let status = state.seat.resume().await;
+    Json(serde_json::json!({"ok": true, "status": status}))
+}
+
+async fn seat_force_layer(
+    State(state): State<AppState>,
+    Json(req): Json<SeatForceLayerReq>,
+) -> impl IntoResponse {
+    let status = state.seat.force_layer(req).await;
+    Json(serde_json::json!({"ok": true, "status": status}))
+}
+
+async fn seat_manual_override(
+    State(state): State<AppState>,
+    Json(req): Json<SeatManualOverrideReq>,
+) -> impl IntoResponse {
+    match state.seat.manual_override(req).await {
+        Ok(status) => Json(serde_json::json!({"ok": true, "status": status})).into_response(),
+        Err(err) => (
+            StatusCode::BAD_REQUEST,
+            Json(serde_json::json!({"ok": false, "error": err.to_string()})),
+        )
+            .into_response(),
+    }
+}
+
+async fn seat_clear_override(State(state): State<AppState>) -> impl IntoResponse {
+    let status = state.seat.clear_manual_override().await;
+    Json(serde_json::json!({"ok": true, "status": status}))
+}
+
+#[derive(Debug, Deserialize)]
+struct SeatHistoryQuery {
+    limit: Option<usize>,
+}
+
+async fn report_seat_status(State(state): State<AppState>) -> impl IntoResponse {
+    Json(state.seat.status().await)
+}
+
+async fn report_seat_history(
+    State(state): State<AppState>,
+    Query(query): Query<SeatHistoryQuery>,
+) -> impl IntoResponse {
+    let limit = query.limit.unwrap_or(120).clamp(1, 2_000);
+    Json(state.seat.history(limit))
+}
+
+#[derive(Debug, Deserialize)]
+struct PaperHistoryQuery {
+    limit: Option<usize>,
+}
+
+async fn report_paper_live(State(state): State<AppState>) -> impl IntoResponse {
+    Json(state.paper.live_report().await)
+}
+
+async fn report_paper_history(
+    State(state): State<AppState>,
+    Query(query): Query<PaperHistoryQuery>,
+) -> impl IntoResponse {
+    let limit = query.limit.unwrap_or(200).clamp(1, 5000);
+    let rows: Vec<PaperTradeRecord> = state.paper.history(limit).await;
+    Json(rows)
+}
+
+async fn report_paper_daily(State(state): State<AppState>) -> impl IntoResponse {
+    let rows: Vec<PaperDailySummary> = state.paper.daily().await;
+    Json(rows)
+}
+
+async fn report_paper_summary(State(state): State<AppState>) -> impl IntoResponse {
+    Json(state.paper.summary_json().await)
+}
+
+async fn reset_paper(State(state): State<AppState>) -> impl IntoResponse {
+    state.paper.reset().await;
+    Json(serde_json::json!({"ok": true, "paper_reset": true}))
+}
+
 async fn reset_shadow(State(state): State<AppState>) -> impl IntoResponse {
     let window_id = state.shadow_stats.reset().await;
     state.tox_state.write().await.clear();
+    {
+        let mut router = state.shared.predator_router.write().await;
+        *router = TimeframeRouter::new(router.cfg().clone());
+    }
+    {
+        let mut sniper = state.shared.predator_taker_sniper.write().await;
+        *sniper = TakerSniper::new(sniper.cfg().clone());
+    }
+    {
+        let cfg = state.shared.predator_cfg.read().await.clone();
+        let mut compounder = state.shared.predator_compounder.write().await;
+        *compounder = SettlementCompounder::new(cfg.compounder);
+    }
+    state.shared.predator_d_last_fire_ms.write().await.clear();
     Json(serde_json::json!({"ok": true, "shadow_reset": true, "window_id": window_id}))
 }
 
+#[derive(Debug, Deserialize)]
+struct PredatorCReloadReq {
+    enabled: Option<bool>,
+    priority: Option<PredatorCPriority>,
+    direction_detector: Option<DirectionConfig>,
+    taker_sniper: Option<TakerSniperConfig>,
+    strategy_d: Option<PredatorDConfig>,
+    regime: Option<PredatorRegimeConfig>,
+    cross_symbol: Option<PredatorCrossSymbolConfig>,
+    router: Option<RouterConfig>,
+    compounder: Option<CompounderConfig>,
+    v52: Option<V52Config>,
+    v52_time_phase: Option<V52TimePhaseConfig>,
+    v52_execution: Option<V52ExecutionConfig>,
+    v52_dual_arb: Option<V52DualArbConfig>,
+    v52_reversal: Option<V52ReversalConfig>,
+}
+
+#[derive(Debug, Serialize)]
+struct PredatorCReloadResp {
+    predator_c: PredatorCConfig,
+}
+
+fn normalize_v52_config(v52: &mut V52Config) {
+    v52.time_phase.early_min_ratio = v52.time_phase.early_min_ratio.clamp(0.11, 0.99);
+    v52.time_phase.late_max_ratio = v52.time_phase.late_max_ratio.clamp(0.01, 0.54);
+    v52.time_phase.early_size_scale = v52.time_phase.early_size_scale.clamp(0.10, 5.0);
+    v52.time_phase.maturity_size_scale = v52.time_phase.maturity_size_scale.clamp(0.10, 5.0);
+    v52.time_phase.late_size_scale = v52.time_phase.late_size_scale.clamp(0.10, 5.0);
+    if v52.time_phase.late_max_ratio >= v52.time_phase.early_min_ratio {
+        v52.time_phase.late_max_ratio = 0.10;
+        v52.time_phase.early_min_ratio = 0.55;
+    }
+    v52.time_phase.allow_timeframes = v52
+        .time_phase
+        .allow_timeframes
+        .iter()
+        .map(|s| s.to_ascii_lowercase())
+        .filter(|s| s == "5m" || s == "15m")
+        .collect::<Vec<_>>();
+    if v52.time_phase.allow_timeframes.is_empty() {
+        v52.time_phase.allow_timeframes = vec!["5m".to_string(), "15m".to_string()];
+    }
+    v52.execution.late_force_taker_remaining_ms =
+        v52.execution.late_force_taker_remaining_ms.clamp(1_000, 60_000);
+    v52.execution.maker_wait_ms_before_force =
+        v52.execution.maker_wait_ms_before_force.clamp(50, 10_000);
+    v52.execution.alpha_window_move_bps = v52.execution.alpha_window_move_bps.clamp(0.1, 50.0);
+    v52.execution.alpha_window_poll_ms = v52.execution.alpha_window_poll_ms.clamp(1, 200);
+    v52.execution.alpha_window_max_wait_ms =
+        v52.execution.alpha_window_max_wait_ms.clamp(50, 5_000);
+    v52.dual_arb.safety_margin_bps = v52.dual_arb.safety_margin_bps.clamp(0.0, 100.0);
+    v52.dual_arb.threshold = v52.dual_arb.threshold.clamp(0.50, 1.10);
+    v52.dual_arb.fee_buffer_mode = "conservative_taker".to_string();
+}
+
+async fn reload_predator_c(
+    State(state): State<AppState>,
+    Json(req): Json<PredatorCReloadReq>,
+) -> Json<PredatorCReloadResp> {
+    let mut cfg = state.shared.predator_cfg.write().await;
+    if let Some(v) = req.enabled {
+        cfg.enabled = v;
+    }
+    if let Some(v) = req.priority {
+        cfg.priority = v;
+    }
+    if let Some(v) = req.direction_detector {
+        cfg.direction_detector = v;
+    }
+    if let Some(v) = req.taker_sniper {
+        cfg.taker_sniper = v;
+    }
+    if let Some(v) = req.strategy_d {
+        cfg.strategy_d = v;
+    }
+    if let Some(v) = req.regime {
+        cfg.regime = v;
+    }
+    if let Some(v) = req.cross_symbol {
+        cfg.cross_symbol = v;
+    }
+    if let Some(v) = req.router {
+        cfg.router = v;
+    }
+    if let Some(v) = req.compounder {
+        cfg.compounder = v;
+    }
+    if let Some(v) = req.v52 {
+        cfg.v52 = v;
+    }
+    if let Some(v) = req.v52_time_phase {
+        cfg.v52.time_phase = v;
+    }
+    if let Some(v) = req.v52_execution {
+        cfg.v52.execution = v;
+    }
+    if let Some(v) = req.v52_dual_arb {
+        cfg.v52.dual_arb = v;
+    }
+    if let Some(v) = req.v52_reversal {
+        cfg.v52.reversal = v;
+    }
+    normalize_v52_config(&mut cfg.v52);
+    let snapshot = cfg.clone();
+    drop(cfg);
+
+    state.shadow_stats.set_predator_enabled(snapshot.enabled);
+    {
+        let mut det = state.shared.predator_direction_detector.write().await;
+        det.set_cfg(snapshot.direction_detector.clone());
+    }
+    {
+        let mut sniper = state.shared.predator_taker_sniper.write().await;
+        sniper.set_cfg(snapshot.taker_sniper.clone());
+    }
+    {
+        let mut router = state.shared.predator_router.write().await;
+        router.set_cfg(snapshot.router.clone());
+    }
+    {
+        let mut compounder = state.shared.predator_compounder.write().await;
+        compounder.set_cfg(snapshot.compounder.clone());
+    }
+
+    append_jsonl(
+        &dataset_path("reports", "predator_c_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "predator_c": snapshot}),
+    );
+
+    Json(PredatorCReloadResp {
+        predator_c: snapshot,
+    })
+}
+
+async fn reload_regime(
+    State(state): State<AppState>,
+    Json(regime): Json<PredatorRegimeConfig>,
+) -> Json<PredatorRegimeConfig> {
+    let mut cfg = state.shared.predator_cfg.write().await;
+    cfg.regime = regime.clone();
+    let snapshot = cfg.regime.clone();
+    drop(cfg);
+
+    append_jsonl(
+        &dataset_path("reports", "regime_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "regime": snapshot}),
+    );
+
+    Json(regime)
+}
+
+async fn reload_fusion(
+    State(state): State<AppState>,
+    Json(req): Json<FusionReloadReq>,
+) -> Json<FusionConfig> {
+    let mut cfg = state.shared.fusion_cfg.write().await;
+    if let Some(v) = req.enable_udp {
+        cfg.enable_udp = v;
+    }
+    if let Some(v) = req.mode {
+        let norm = v.to_ascii_lowercase();
+        if matches!(
+            norm.as_str(),
+            "active_active" | "direct_only" | "udp_only" | "websocket_primary"
+        ) {
+            cfg.mode = norm;
+        }
+    }
+    if let Some(v) = req.udp_port {
+        cfg.udp_port = v.max(1);
+    }
+    if let Some(v) = req.dedupe_window_ms {
+        cfg.dedupe_window_ms = v.clamp(0, 2_000);
+    }
+    if let Some(v) = req.dedupe_price_bps {
+        cfg.dedupe_price_bps = v.clamp(0.0, 50.0);
+    }
+    if let Some(v) = req.udp_share_cap {
+        cfg.udp_share_cap = v.clamp(0.05, 0.95);
+    }
+    if let Some(v) = req.jitter_threshold_ms {
+        cfg.jitter_threshold_ms = v.clamp(1.0, 2_000.0);
+    }
+    if let Some(v) = req.fallback_arm_duration_ms {
+        cfg.fallback_arm_duration_ms = v.clamp(200, 15_000);
+    }
+    if let Some(v) = req.fallback_cooldown_sec {
+        cfg.fallback_cooldown_sec = v.clamp(0, 3_600);
+    }
+    if let Some(v) = req.udp_local_only {
+        cfg.udp_local_only = v;
+    }
+    if cfg.mode == "websocket_primary" {
+        cfg.udp_local_only = true;
+        cfg.udp_share_cap = cfg.udp_share_cap.clamp(0.05, 0.35);
+        cfg.jitter_threshold_ms = cfg.jitter_threshold_ms.max(25.0);
+        cfg.fallback_arm_duration_ms = cfg.fallback_arm_duration_ms.max(8_000);
+        cfg.fallback_cooldown_sec = cfg.fallback_cooldown_sec.max(300);
+    }
+    let snapshot = cfg.clone();
+    std::env::set_var(
+        "POLYEDGE_UDP_LOCAL_ONLY",
+        if snapshot.udp_local_only {
+            "true"
+        } else {
+            "false"
+        },
+    );
+    append_jsonl(
+        &dataset_path("reports", "fusion_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "fusion": snapshot}),
+    );
+    Json(snapshot)
+}
+
+async fn reload_edge_model(
+    State(state): State<AppState>,
+    Json(req): Json<EdgeModelReloadReq>,
+) -> Json<EdgeModelConfig> {
+    let mut cfg = state.shared.edge_model_cfg.write().await;
+    if let Some(v) = req.model {
+        cfg.model = v;
+    }
+    if let Some(v) = req.gate_mode {
+        cfg.gate_mode = v;
+    }
+    if let Some(v) = req.version {
+        cfg.version = v;
+    }
+    if let Some(v) = req.base_gate_bps {
+        cfg.base_gate_bps = v.max(0.0);
+    }
+    if let Some(v) = req.congestion_penalty_bps {
+        cfg.congestion_penalty_bps = v.max(0.0);
+    }
+    if let Some(v) = req.latency_penalty_bps {
+        cfg.latency_penalty_bps = v.max(0.0);
+    }
+    if let Some(v) = req.fail_cost_bps {
+        cfg.fail_cost_bps = v.max(0.0);
+    }
+    let snapshot = cfg.clone();
+    append_jsonl(
+        &dataset_path("reports", "edge_model_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "edge_model": snapshot}),
+    );
+    Json(snapshot)
+}
+
+async fn reload_probability(
+    State(state): State<AppState>,
+    Json(req): Json<ProbabilityReloadReq>,
+) -> Json<ProbabilityEngineConfig> {
+    let mut engine = state.shared.predator_probability_engine.write().await;
+    let mut cfg = engine.cfg().clone();
+    if let Some(v) = req.momentum_gain {
+        cfg.momentum_gain = v.clamp(0.0, 20.0);
+    }
+    if let Some(v) = req.lag_penalty_per_ms {
+        cfg.lag_penalty_per_ms = v.clamp(0.0, 0.1);
+    }
+    if let Some(v) = req.confidence_floor {
+        cfg.confidence_floor = v.clamp(0.0, 1.0);
+    }
+    if let Some(v) = req.sigma_annual {
+        cfg.sigma_annual = v.clamp(0.05, 5.0);
+    }
+    if let Some(v) = req.horizon_sec {
+        cfg.horizon_sec = v.clamp(1.0, 900.0);
+    }
+    if let Some(v) = req.drift_annual {
+        cfg.drift_annual = v.clamp(-10.0, 10.0);
+    }
+    if let Some(v) = req.velocity_drift_gain {
+        cfg.velocity_drift_gain = v.clamp(0.0, 5.0);
+    }
+    if let Some(v) = req.acceleration_drift_gain {
+        cfg.acceleration_drift_gain = v.clamp(0.0, 5.0);
+    }
+    if let Some(v) = req.fair_blend_weight {
+        cfg.fair_blend_weight = v.clamp(0.0, 1.0);
+    }
+    engine.set_cfg(cfg.clone());
+    drop(engine);
+    append_jsonl(
+        &dataset_path("reports", "probability_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "probability": cfg}),
+    );
+    Json(cfg)
+}
+
+async fn reload_source_health(
+    State(state): State<AppState>,
+    Json(req): Json<SourceHealthReloadReq>,
+) -> Json<SourceHealthConfig> {
+    let mut cfg = state.shared.source_health_cfg.write().await;
+    if let Some(v) = req.min_samples {
+        cfg.min_samples = v.max(1);
+    }
+    if let Some(v) = req.gap_window_ms {
+        cfg.gap_window_ms = v.clamp(50, 60_000);
+    }
+    if let Some(v) = req.jitter_limit_ms {
+        cfg.jitter_limit_ms = v.clamp(0.1, 2_000.0);
+    }
+    if let Some(v) = req.deviation_limit_bps {
+        cfg.deviation_limit_bps = v.clamp(0.1, 10_000.0);
+    }
+    if let Some(v) = req.freshness_limit_ms {
+        cfg.freshness_limit_ms = v.clamp(50.0, 60_000.0);
+    }
+    if let Some(v) = req.min_score_for_trading {
+        cfg.min_score_for_trading = v.clamp(0.0, 1.0);
+    }
+    let snapshot = cfg.clone();
+    append_jsonl(
+        &dataset_path("reports", "source_health_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "source_health": snapshot}),
+    );
+    Json(snapshot)
+}
+
+async fn reload_exit(
+    State(state): State<AppState>,
+    Json(req): Json<ExitReloadReq>,
+) -> Json<ExitConfig> {
+    let mut cfg = state.shared.exit_cfg.write().await;
+    if let Some(v) = req.enabled {
+        cfg.enabled = v;
+    }
+    if let Some(v) = req.t100ms_reversal_bps {
+        cfg.t100ms_reversal_bps = v;
+    }
+    if let Some(v) = req.t300ms_reversal_bps {
+        cfg.t300ms_reversal_bps = v;
+    }
+    if let Some(v) = req.convergence_exit_ratio {
+        cfg.convergence_exit_ratio = v.clamp(0.0, 1.0);
+    }
+    if let Some(v) = req.time_stop_ms {
+        cfg.time_stop_ms = v.clamp(50, 60_000);
+    }
+    if let Some(v) = req.edge_decay_bps {
+        cfg.edge_decay_bps = v;
+    }
+    if let Some(v) = req.adverse_move_bps {
+        cfg.adverse_move_bps = v;
+    }
+    if let Some(v) = req.flatten_on_trigger {
+        cfg.flatten_on_trigger = v;
+    }
+    if let Some(v) = req.t3_take_ratio {
+        cfg.t3_take_ratio = v.clamp(0.0, 5.0);
+    }
+    if let Some(v) = req.t15_min_unrealized_usdc {
+        cfg.t15_min_unrealized_usdc = v;
+    }
+    if let Some(v) = req.t60_true_prob_floor {
+        cfg.t60_true_prob_floor = v.clamp(0.0, 1.0);
+    }
+    if let Some(v) = req.t300_force_exit_ms {
+        cfg.t300_force_exit_ms = v.clamp(1_000, 1_800_000);
+    }
+    if let Some(v) = req.t300_hold_prob_threshold {
+        cfg.t300_hold_prob_threshold = v.clamp(0.0, 1.0);
+    }
+    if let Some(v) = req.t300_hold_time_to_expiry_ms {
+        cfg.t300_hold_time_to_expiry_ms = v.clamp(1_000, 1_800_000);
+    }
+    if let Some(v) = req.max_single_trade_loss_usdc {
+        cfg.max_single_trade_loss_usdc = v.max(0.0);
+    }
+    let manager_cfg = to_exit_manager_config(&cfg);
+    state
+        .shared
+        .predator_exit_manager
+        .write()
+        .await
+        .set_cfg(manager_cfg);
+    let snapshot = cfg.clone();
+    append_jsonl(
+        &dataset_path("reports", "exit_reload.jsonl"),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "exit": snapshot}),
+    );
+    Json(snapshot)
+}
+
+async fn report_direction(State(state): State<AppState>) -> Json<serde_json::Value> {
+    let now = Utc::now().timestamp_millis();
+    let latest = state.shared.predator_latest_direction.read().await.clone();
+    Json(serde_json::json!({"ts_ms": now, "latest": latest}))
+}
+
+async fn report_router(State(state): State<AppState>) -> Json<serde_json::Value> {
+    let now = Utc::now().timestamp_millis();
+    let mut router = state.shared.predator_router.write().await;
+    let locks = router.snapshot_locks(now);
+    let locked_by_tf = router.locked_by_tf_usdc(now);
+    let mut locked_by_tf_usdc = HashMap::<String, f64>::new();
+    for (tf, v) in locked_by_tf {
+        locked_by_tf_usdc.insert(tf.to_string(), v);
+    }
+    Json(serde_json::json!({
+        "ts_ms": now,
+        "locks": locks,
+        "locked_by_tf_usdc": locked_by_tf_usdc,
+        "active_positions": router.active_positions(now),
+        "locked_total_usdc": router.locked_total_usdc(now)
+    }))
+}
+
+async fn report_capital(State(state): State<AppState>) -> Json<serde_json::Value> {
+    let now = Utc::now().timestamp_millis();
+    let compounder = state.shared.predator_compounder.read().await;
+    let cfg = compounder.cfg().clone();
+    Json(serde_json::json!({
+        "ts_ms": now,
+        "cfg": cfg,
+        "available_usdc": compounder.available(),
+        "total_pnl_usdc": compounder.total_pnl(),
+        "daily_pnl_usdc": compounder.daily_pnl(),
+        "halted": compounder.halted(),
+        "win_rate": compounder.win_rate(),
+        "recommended_quote_notional_usdc": compounder.recommended_quote_notional_usdc(),
+    }))
+}
+
 async fn reload_strategy(
     State(state): State<AppState>,
     Json(req): Json<StrategyReloadReq>,
 ) -> Json<StrategyReloadResp> {
-    let mut cfg = state.strategy_cfg.write().await;
+    let cur = state.strategy_cfg.read().await.clone();
+    let mut next = (*cur).clone();
     if let Some(v) = req.min_edge_bps {
-        cfg.min_edge_bps = v.max(0.0);
+        next.min_edge_bps = v.max(0.0);
     }
     if let Some(v) = req.ttl_ms {
-        cfg.ttl_ms = v.max(50);
+        next.ttl_ms = v.max(50);
     }
     if let Some(v) = req.inventory_skew {
-        cfg.inventory_skew = v.clamp(0.0, 1.0);
+        next.inventory_skew = v.clamp(0.0, 1.0);
     }
     if let Some(v) = req.base_quote_size {
-        cfg.base_quote_size = v.max(0.01);
+        next.base_quote_size = v.max(0.01);
     }
     if let Some(v) = req.max_spread {
-        cfg.max_spread = v.max(0.0001);
+        next.max_spread = v.max(0.0001);
     }
     if let Some(v) = req.taker_trigger_bps {
-        cfg.taker_trigger_bps = v.max(0.0);
+        next.taker_trigger_bps = v.max(0.0);
     }
     if let Some(v) = req.taker_max_slippage_bps {
-        cfg.taker_max_slippage_bps = v.max(0.0);
+        next.taker_max_slippage_bps = v.max(0.0);
     }
     if let Some(v) = req.stale_tick_filter_ms {
-        cfg.stale_tick_filter_ms = v.clamp(50.0, 5_000.0);
-    }
-    if let Some(v) = req.market_tier_profile {
-        cfg.market_tier_profile = v;
+        next.stale_tick_filter_ms = v.clamp(50.0, 5_000.0);
     }
     if let Some(v) = req.capital_fraction_kelly {
-        cfg.capital_fraction_kelly = v.clamp(0.01, 1.0);
+        next.capital_fraction_kelly = v.clamp(0.01, 1.0);
     }
     if let Some(v) = req.variance_penalty_lambda {
-        cfg.variance_penalty_lambda = v.clamp(0.0, 5.0);
+        next.variance_penalty_lambda = v.clamp(0.0, 5.0);
     }
     if let Some(v) = req.min_eval_notional_usdc {
-        cfg.min_eval_notional_usdc = v.max(0.0);
+        next.min_eval_notional_usdc = v.max(0.0);
     }
     if let Some(v) = req.min_expected_edge_usdc {
-        cfg.min_expected_edge_usdc = v.max(0.0);
+        next.min_expected_edge_usdc = v.max(0.0);
+    }
+    let v52_cfg = {
+        let mut predator_cfg = state.shared.predator_cfg.write().await;
+        if let Some(v) = req.v52 {
+            predator_cfg.v52 = v;
+        }
+        if let Some(v) = req.v52_time_phase {
+            predator_cfg.v52.time_phase = v;
+        }
+        if let Some(v) = req.v52_execution {
+            predator_cfg.v52.execution = v;
+        }
+        if let Some(v) = req.v52_dual_arb {
+            predator_cfg.v52.dual_arb = v;
+        }
+        if let Some(v) = req.v52_reversal {
+            predator_cfg.v52.reversal = v;
+        }
+        normalize_v52_config(&mut predator_cfg.v52);
+        predator_cfg.v52.clone()
+    };
+    if let Some(v) = req.market_tier_profile {
+        next.market_tier_profile = v;
     }
     let mut fair_cfg = state
         .fair_value_cfg
@@ -149,19 +838,21 @@ async fn reload_strategy(
     if let Ok(mut guard) = state.fair_value_cfg.write() {
         *guard = fair_cfg.clone();
     }
-    let maker_cfg = cfg.clone();
-    drop(cfg);
+    *state.strategy_cfg.write().await = std::sync::Arc::new(next.clone());
+    let maker_cfg = next;
     append_jsonl(
         &dataset_path("reports", "strategy_reload.jsonl"),
         &serde_json::json!({
             "ts_ms": Utc::now().timestamp_millis(),
             "maker": maker_cfg,
-            "fair_value": fair_cfg
+            "fair_value": fair_cfg,
+            "v52": v52_cfg
         }),
     );
     Json(StrategyReloadResp {
         maker: maker_cfg,
         fair_value: fair_cfg,
+        v52: v52_cfg,
     })
 }
 
@@ -169,24 +860,26 @@ async fn reload_taker(
     State(state): State<AppState>,
     Json(req): Json<TakerReloadReq>,
 ) -> Json<TakerReloadResp> {
-    let mut cfg = state.strategy_cfg.write().await;
+    let cur = state.strategy_cfg.read().await.clone();
+    let mut next = (*cur).clone();
     if let Some(v) = req.trigger_bps {
-        cfg.taker_trigger_bps = v.max(0.0);
+        next.taker_trigger_bps = v.max(0.0);
     }
     if let Some(v) = req.max_slippage_bps {
-        cfg.taker_max_slippage_bps = v.max(0.0);
+        next.taker_max_slippage_bps = v.max(0.0);
     }
     if let Some(v) = req.stale_tick_filter_ms {
-        cfg.stale_tick_filter_ms = v.clamp(50.0, 5_000.0);
+        next.stale_tick_filter_ms = v.clamp(50.0, 5_000.0);
     }
     if let Some(v) = req.market_tier_profile {
-        cfg.market_tier_profile = v;
+        next.market_tier_profile = v;
     }
+    *state.strategy_cfg.write().await = std::sync::Arc::new(next.clone());
     let resp = TakerReloadResp {
-        trigger_bps: cfg.taker_trigger_bps,
-        max_slippage_bps: cfg.taker_max_slippage_bps,
-        stale_tick_filter_ms: cfg.stale_tick_filter_ms,
-        market_tier_profile: cfg.market_tier_profile.clone(),
+        trigger_bps: next.taker_trigger_bps,
+        max_slippage_bps: next.taker_max_slippage_bps,
+        stale_tick_filter_ms: next.stale_tick_filter_ms,
+        market_tier_profile: next.market_tier_profile.clone(),
     };
     append_jsonl(
         &dataset_path("reports", "taker_reload.jsonl"),
@@ -228,13 +921,17 @@ async fn reload_allocator(
     }
 
     {
-        let mut strategy = state.strategy_cfg.write().await;
-        strategy.capital_fraction_kelly = allocator.capital_fraction_kelly;
-        strategy.variance_penalty_lambda = allocator.variance_penalty_lambda;
+        let cur = state.strategy_cfg.read().await.clone();
+        let mut next = (*cur).clone();
+        next.capital_fraction_kelly = allocator.capital_fraction_kelly;
+        next.variance_penalty_lambda = allocator.variance_penalty_lambda;
+        *state.strategy_cfg.write().await = std::sync::Arc::new(next);
     }
     {
-        let mut tox = state.toxicity_cfg.write().await;
-        tox.active_top_n_markets = allocator.active_top_n_markets;
+        let cur = state.toxicity_cfg.read().await.clone();
+        let mut next = (*cur).clone();
+        next.active_top_n_markets = allocator.active_top_n_markets;
+        *state.toxicity_cfg.write().await = std::sync::Arc::new(next);
     }
 
     let resp = AllocatorReloadResp {
@@ -251,10 +948,7 @@ async fn reload_risk(
     State(state): State<AppState>,
     Json(req): Json<RiskReloadReq>,
 ) -> Json<RiskReloadResp> {
-    let mut cfg = state
-        .risk_limits
-        .write()
-        .unwrap_or_else(|e| e.into_inner());
+    let mut cfg = state.risk_limits.write().unwrap_or_else(|e| e.into_inner());
     if let Some(v) = req.max_market_notional {
         cfg.max_market_notional = v.max(0.0);
     }
@@ -273,6 +967,21 @@ async fn reload_risk(
     if let Some(v) = req.cooldown_sec {
         cfg.cooldown_sec = v.max(1);
     }
+    if let Some(v) = req.progressive_enabled {
+        cfg.progressive_enabled = v;
+    }
+    if let Some(v) = req.drawdown_tier1_ratio {
+        cfg.drawdown_tier1_ratio = v.clamp(0.05, 0.99);
+    }
+    if let Some(v) = req.drawdown_tier2_ratio {
+        cfg.drawdown_tier2_ratio = v.clamp(cfg.drawdown_tier1_ratio, 0.999);
+    }
+    if let Some(v) = req.tier1_size_scale {
+        cfg.tier1_size_scale = v.clamp(0.01, 1.0);
+    }
+    if let Some(v) = req.tier2_size_scale {
+        cfg.tier2_size_scale = v.clamp(0.01, 1.0);
+    }
     let snapshot = cfg.clone();
     append_jsonl(
         &dataset_path("reports", "risk_reload.jsonl"),
@@ -285,68 +994,71 @@ async fn reload_toxicity(
     State(state): State<AppState>,
     Json(req): Json<ToxicityReloadReq>,
 ) -> Json<ToxicityConfig> {
-    let mut cfg = state.toxicity_cfg.write().await;
+    let cur = state.toxicity_cfg.read().await.clone();
+    let mut next = (*cur).clone();
     if let Some(v) = req.safe_threshold {
-        cfg.safe_threshold = v.clamp(0.0, 1.0);
+        next.safe_threshold = v.clamp(0.0, 1.0);
     }
     if let Some(v) = req.caution_threshold {
-        cfg.caution_threshold = v.clamp(0.0, 1.0);
+        next.caution_threshold = v.clamp(0.0, 1.0);
     }
     if let Some(v) = req.cooldown_min_sec {
-        cfg.cooldown_min_sec = v.max(1);
+        next.cooldown_min_sec = v.max(1);
     }
     if let Some(v) = req.cooldown_max_sec {
-        cfg.cooldown_max_sec = v.max(cfg.cooldown_min_sec);
+        next.cooldown_max_sec = v.max(next.cooldown_min_sec);
     }
     if let Some(v) = req.min_market_score {
-        cfg.min_market_score = v.clamp(0.0, 100.0);
+        next.min_market_score = v.clamp(0.0, 100.0);
     }
     if let Some(v) = req.active_top_n_markets {
-        cfg.active_top_n_markets = v;
+        next.active_top_n_markets = v;
     }
     if let Some(v) = req.markout_1s_caution_bps {
-        cfg.markout_1s_caution_bps = v;
+        next.markout_1s_caution_bps = v;
     }
     if let Some(v) = req.markout_5s_caution_bps {
-        cfg.markout_5s_caution_bps = v;
+        next.markout_5s_caution_bps = v;
     }
     if let Some(v) = req.markout_10s_caution_bps {
-        cfg.markout_10s_caution_bps = v;
+        next.markout_10s_caution_bps = v;
     }
     if let Some(v) = req.markout_1s_danger_bps {
-        cfg.markout_1s_danger_bps = v;
+        next.markout_1s_danger_bps = v;
     }
     if let Some(v) = req.markout_5s_danger_bps {
-        cfg.markout_5s_danger_bps = v;
+        next.markout_5s_danger_bps = v;
     }
     if let Some(v) = req.markout_10s_danger_bps {
-        cfg.markout_10s_danger_bps = v;
+        next.markout_10s_danger_bps = v;
     }
-    if cfg.safe_threshold > cfg.caution_threshold {
-        let safe = cfg.safe_threshold;
-        cfg.safe_threshold = cfg.caution_threshold;
-        cfg.caution_threshold = safe;
+    if next.safe_threshold > next.caution_threshold {
+        std::mem::swap(&mut next.safe_threshold, &mut next.caution_threshold);
     }
-    if cfg.markout_1s_caution_bps < cfg.markout_1s_danger_bps {
-        let v = cfg.markout_1s_caution_bps;
-        cfg.markout_1s_caution_bps = cfg.markout_1s_danger_bps;
-        cfg.markout_1s_danger_bps = v;
+    if next.markout_1s_caution_bps < next.markout_1s_danger_bps {
+        std::mem::swap(
+            &mut next.markout_1s_caution_bps,
+            &mut next.markout_1s_danger_bps,
+        );
     }
-    if cfg.markout_5s_caution_bps < cfg.markout_5s_danger_bps {
-        let v = cfg.markout_5s_caution_bps;
-        cfg.markout_5s_caution_bps = cfg.markout_5s_danger_bps;
-        cfg.markout_5s_danger_bps = v;
+    if next.markout_5s_caution_bps < next.markout_5s_danger_bps {
+        std::mem::swap(
+            &mut next.markout_5s_caution_bps,
+            &mut next.markout_5s_danger_bps,
+        );
     }
-    if cfg.markout_10s_caution_bps < cfg.markout_10s_danger_bps {
-        let v = cfg.markout_10s_caution_bps;
-        cfg.markout_10s_caution_bps = cfg.markout_10s_danger_bps;
-        cfg.markout_10s_danger_bps = v;
+    if next.markout_10s_caution_bps < next.markout_10s_danger_bps {
+        std::mem::swap(
+            &mut next.markout_10s_caution_bps,
+            &mut next.markout_10s_danger_bps,
+        );
     }
+    *state.toxicity_cfg.write().await = std::sync::Arc::new(next.clone());
     append_jsonl(
         &dataset_path("reports", "toxicity_reload.jsonl"),
-        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "config": *cfg}),
+        &serde_json::json!({"ts_ms": Utc::now().timestamp_millis(), "config": next}),
     );
-    Json(cfg.clone())
+    Json(next)
 }
 
 async fn reload_perf_profile(
@@ -378,13 +1090,27 @@ async fn reload_perf_profile(
 }
 
 async fn report_shadow_live(State(state): State<AppState>) -> Json<ShadowLiveReport> {
-    let live = state.shadow_stats.build_live_report().await;
+    let mut live = state.shadow_stats.build_live_report().await;
+    live.edge_model_version = state.shared.edge_model_cfg.read().await.version.clone();
+    {
+        let map = state.shared.source_health_latest.read().await;
+        let mut rows = map.values().cloned().collect::<Vec<_>>();
+        rows.sort_by(|a, b| b.score.total_cmp(&a.score));
+        live.source_health = rows;
+    }
     persist_live_report_files(&live);
     Json(live)
 }
 
 async fn report_shadow_final(State(state): State<AppState>) -> Json<ShadowFinalReport> {
-    let final_report = state.shadow_stats.build_final_report().await;
+    let mut final_report = state.shadow_stats.build_final_report().await;
+    final_report.live.edge_model_version = state.shared.edge_model_cfg.read().await.version.clone();
+    {
+        let map = state.shared.source_health_latest.read().await;
+        let mut rows = map.values().cloned().collect::<Vec<_>>();
+        rows.sort_by(|a, b| b.score.total_cmp(&a.score));
+        final_report.live.source_health = rows;
+    }
     persist_final_report_files(&final_report);
     Json(final_report)
 }
diff --git a/crates/app_runner/src/engine_core.rs b/crates/app_runner/src/engine_core.rs
index 9825e78..1118522 100644
--- a/crates/app_runner/src/engine_core.rs
+++ b/crates/app_runner/src/engine_core.rs
@@ -1,47 +1,28 @@
-use super::*;
-
 pub(super) fn is_quote_reject_reason(reason: &str) -> bool {
     reason.starts_with("execution_") || reason.starts_with("exchange_reject")
 }
 
 pub(super) fn is_policy_block_reason(reason: &str) -> bool {
+    // Metrics contract: policy_blocked only counts hard risk blocks.
     reason == "risk_capped_zero" || reason.starts_with("risk:")
 }
 
-pub(super) fn classify_execution_style(
-    book: &BookTop,
-    intent: &core_types::QuoteIntent,
-) -> ExecutionStyle {
-    match intent.side {
-        OrderSide::BuyYes => {
-            if intent.price >= book.ask_yes {
-                ExecutionStyle::Taker
-            } else {
-                ExecutionStyle::Maker
-            }
-        }
-        OrderSide::SellYes => {
-            if intent.price <= book.bid_yes {
-                ExecutionStyle::Taker
-            } else {
-                ExecutionStyle::Maker
-            }
-        }
-        OrderSide::BuyNo => {
-            if intent.price >= book.ask_no {
-                ExecutionStyle::Taker
-            } else {
-                ExecutionStyle::Maker
-            }
-        }
-        OrderSide::SellNo => {
-            if intent.price <= book.bid_no {
-                ExecutionStyle::Taker
-            } else {
-                ExecutionStyle::Maker
-            }
-        }
-    }
+pub(super) fn is_gate_block_reason(reason: &str) -> bool {
+    is_policy_block_reason(reason)
+        || reason.starts_with("rate_budget_")
+        || matches!(
+            reason,
+            "open_orders_pressure_precheck"
+                | "taker_slippage_budget"
+                | "market_rank_blocked"
+                | "market_score_low"
+                | "symbol_quality_guard"
+                | "decision_backlog_guard"
+                | "no_quote_policy"
+                | "no_quote_edge"
+                | "edge_below_dynamic_gate"
+                | "edge_notional_too_small"
+        )
 }
 
 pub(super) fn normalize_reject_code(raw: &str) -> String {
@@ -74,3 +55,27 @@ pub(super) fn classify_execution_error_reason(err: &anyhow::Error) -> &'static s
         "execution_error"
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{is_gate_block_reason, is_policy_block_reason};
+
+    #[test]
+    fn policy_block_reason_only_counts_hard_risk() {
+        assert!(is_policy_block_reason("risk:exposure"));
+        assert!(is_policy_block_reason("risk_capped_zero"));
+        assert!(!is_policy_block_reason("rate_budget_global"));
+        assert!(!is_policy_block_reason("open_orders_pressure_precheck"));
+        assert!(!is_policy_block_reason("decision_backlog_guard"));
+        assert!(!is_policy_block_reason("ref_dedupe_dropped"));
+    }
+
+    #[test]
+    fn gate_block_reason_keeps_soft_gates_for_diagnosis() {
+        assert!(is_gate_block_reason("risk:exposure"));
+        assert!(is_gate_block_reason("rate_budget_global"));
+        assert!(is_gate_block_reason("market_rank_blocked"));
+        assert!(is_gate_block_reason("edge_below_dynamic_gate"));
+        assert!(!is_gate_block_reason("ref_dedupe_dropped"));
+    }
+}
diff --git a/crates/app_runner/src/engine_loop.rs b/crates/app_runner/src/engine_loop.rs
new file mode 100644
index 0000000..354d751
--- /dev/null
+++ b/crates/app_runner/src/engine_loop.rs
@@ -0,0 +1,1646 @@
+use std::collections::HashMap;
+use std::sync::atomic::{AtomicBool, Ordering};
+use std::sync::Arc;
+use std::time::{Duration, Instant};
+
+use chrono::Utc;
+use core_types::{
+    new_id, BookTop, ControlCommand, Direction, EdgeAttribution, EngineEvent,
+    ExecutionStyle, ExecutionVenue, FairValueModel, InventoryState, MarketHealth, OrderAck,
+    OrderIntentV2, OrderSide, OrderTimeInForce, PaperAction, QuoteEval, QuoteIntent, RefTick,
+    ShadowOutcome, ShadowShot, Stage, TimeframeClass, ToxicRegime,
+};
+use execution_clob::ClobExecution;
+use exit_manager::{ExitReason, MarketEvalInput};
+use fair_value::BasisMrFairValue;
+use infra_bus::RingBus;
+use market_discovery::{DiscoveryConfig, MarketDiscovery};
+use paper_executor::ShadowExecutor;
+use portfolio::PortfolioBook;
+use tokio::sync::{mpsc, RwLock};
+
+use crate::paper_runtime::{global_paper_runtime, PaperIntentCtx};
+use crate::execution_eval::{
+    aggressive_price_for_side, classify_filled_outcome, classify_unfilled_outcome, edge_for_intent,
+    evaluate_fillable, evaluate_survival, get_fee_rate_bps_cached, get_rebate_bps_cached,
+    is_crossable, pnl_after_horizon,
+};
+use crate::fusion_engine::{
+    compute_coalesce_policy, estimate_feed_latency, fast_tick_allowed_in_fusion_mode,
+    insert_latest_ref_tick, is_anchor_ref_source, pick_latest_tick, ref_event_ts_ms, TokenBucket,
+};
+use crate::report_io::{
+    append_jsonl, current_jsonl_queue_depth, dataset_path, next_normalized_ingest_seq,
+};
+use crate::state::{
+    exit_reason_label, EngineShared, SignalCacheEntry, StrategyIngress, StrategyIngressMsg,
+};
+use crate::stats_utils::{freshness_ms, now_ns, percentile_deque_capped};
+use crate::strategy_policy::{
+    adaptive_max_spread, bps_to_usdc, build_toxic_features, compute_market_score_from_snapshot,
+    cooldown_secs_for_score, estimate_entry_notional_usdc, estimate_queue_fill_proxy,
+    evaluate_toxicity, inventory_for_market, is_market_in_top_n, net_markout, roi_bps_from_usdc,
+    should_observe_only_symbol,
+};
+use crate::strategy_runtime::{
+    classify_time_phase, evaluate_and_route_v52, stage_for_phase, timeframe_total_ms,
+};
+use crate::toxicity_runtime::update_toxic_state_from_outcome;
+use crate::{publish_if_telemetry_subscribers, spawn_detached};
+
+pub(crate) fn spawn_strategy_engine(
+    bus: RingBus<EngineEvent>,
+    portfolio: Arc<PortfolioBook>,
+    execution: Arc<ClobExecution>,
+    shadow: Arc<ShadowExecutor>,
+    paused: Arc<RwLock<bool>>,
+    shared: Arc<EngineShared>,
+    mut ingress_rx: mpsc::Receiver<StrategyIngressMsg>,
+) {
+    spawn_detached("strategy_engine", true, async move {
+        let fair = BasisMrFairValue::new(shared.fair_value_cfg.clone());
+        // Separate fast reference ticks (exchange WS) from anchor ticks (Chainlink RTDS).
+        // Fast ticks drive stale filtering + fair value evaluation; anchor ticks are tracked for
+        // auditing/diagnostics so the trigger stays latency-sensitive.
+        let mut latest_fast_ticks: HashMap<String, RefTick> = HashMap::new();
+        let mut latest_anchor_ticks: HashMap<String, RefTick> = HashMap::new();
+        let mut last_direction_tick_event_ms: HashMap<String, i64> = HashMap::new();
+        let mut market_inventory: HashMap<String, InventoryState> = HashMap::new();
+        let mut market_rate_budget: HashMap<String, TokenBucket> = HashMap::new();
+        let mut untracked_issue_cooldown: HashMap<String, Instant> = HashMap::new();
+        let mut book_lag_sample_at: HashMap<String, Instant> = HashMap::new();
+        let mut global_rate_budget = TokenBucket::new(
+            shared.rate_limit_rps,
+            (shared.rate_limit_rps * 2.0).max(1.0),
+        );
+        let mut control_rx = bus.subscribe();
+        let mut last_discovery_refresh = Instant::now() - Duration::from_secs(3600);
+        let mut last_symbol_retry_refresh = Instant::now() - Duration::from_secs(3600);
+        let mut last_fusion_mode = shared.fusion_cfg.read().await.mode.clone();
+        let strategy_max_coalesce = std::env::var("POLYEDGE_STRATEGY_MAX_COALESCE")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(256)
+            .clamp(8, 1_024);
+        let strategy_coalesce_min = std::env::var("POLYEDGE_STRATEGY_MIN_COALESCE")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(4)
+            .clamp(1, 128);
+        let strategy_coalesce_budget_us = std::env::var("POLYEDGE_STRATEGY_COALESCE_BUDGET_US")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(120)
+            .clamp(20, 2_000);
+        let strategy_drop_stale_book_ms = std::env::var("POLYEDGE_STRATEGY_DROP_STALE_BOOK_MS")
+            .ok()
+            .and_then(|v| v.parse::<f64>().ok())
+            .unwrap_or(800.0)
+            .clamp(50.0, 5_000.0);
+        let strategy_max_decision_backlog_ms = std::env::var("POLYEDGE_MAX_DECISION_BACKLOG_MS")
+            .ok()
+            .and_then(|v| v.parse::<f64>().ok())
+            .unwrap_or(0.90)
+            .clamp(0.10, 50.0);
+        let mut stale_book_drops: u64 = 0;
+        let symbol_refresh_inflight = Arc::new(AtomicBool::new(false));
+        refresh_market_symbol_map(&shared).await;
+
+        loop {
+            if last_discovery_refresh.elapsed() >= Duration::from_secs(300) {
+                refresh_market_symbol_map(&shared).await;
+                last_discovery_refresh = Instant::now();
+            }
+
+            let ingress_msg = tokio::select! {
+                ctrl = control_rx.recv() => {
+                    match ctrl {
+                        Ok(EngineEvent::Control(ControlCommand::Pause)) => {
+                            *paused.write().await = true;
+                            shared.shadow_stats.set_paused(true);
+                        }
+                        Ok(EngineEvent::Control(ControlCommand::Resume)) => {
+                            *paused.write().await = false;
+                            shared.shadow_stats.set_paused(false);
+                        }
+                        Ok(EngineEvent::Control(ControlCommand::Flatten)) => {
+                            if let Err(err) = execution.flatten_all().await {
+                                tracing::warn!(?err, "flatten from control event failed");
+                            }
+                        }
+                        Ok(_) => {}
+                        Err(_) => {}
+                    }
+                    continue;
+                }
+                maybe_ingress = ingress_rx.recv() => {
+                    let Some(event) = maybe_ingress else {
+                        shared.shadow_stats.record_issue("strategy_ingress_closed").await;
+                        break;
+                    };
+                    event
+                }
+            };
+            let mut ingress_enqueued_ns = ingress_msg.enqueued_ns;
+            let ingress_event = ingress_msg.payload;
+
+            let dispatch_start = Instant::now();
+            let current_fusion_mode = shared.fusion_cfg.read().await.mode.clone();
+            if current_fusion_mode != last_fusion_mode {
+                latest_fast_ticks.retain(|_, tick| {
+                    fast_tick_allowed_in_fusion_mode(tick.source.as_str(), &current_fusion_mode)
+                });
+                shared.latest_fast_ticks.retain(|_, tick| {
+                    fast_tick_allowed_in_fusion_mode(tick.source.as_str(), &current_fusion_mode)
+                });
+                last_fusion_mode = current_fusion_mode.clone();
+                shared
+                    .shadow_stats
+                    .record_issue("fusion_mode_switch_fast_cache_reset")
+                    .await;
+            }
+
+            match ingress_event {
+                StrategyIngress::RefTick(tick) => {
+                    let parse_us = dispatch_start.elapsed().as_secs_f64() * 1_000_000.0;
+                    shared.shadow_stats.push_parse_us(parse_us).await;
+                    if !is_anchor_ref_source(tick.source.as_str())
+                        && !fast_tick_allowed_in_fusion_mode(
+                            tick.source.as_str(),
+                            &current_fusion_mode,
+                        )
+                    {
+                        continue;
+                    }
+                    insert_latest_ref_tick(&mut latest_fast_ticks, &mut latest_anchor_ticks, tick);
+                }
+                StrategyIngress::BookTop(mut book) => {
+                    let parse_us = dispatch_start.elapsed().as_secs_f64() * 1_000_000.0;
+                    shared.shadow_stats.push_parse_us(parse_us).await;
+                    // Keep only the freshest observable state under burst.
+                    let mut coalesced = 0_u64;
+                    let coalesce_start = Instant::now();
+                    let queue_len = ingress_rx.len();
+                    let coalesce_policy = compute_coalesce_policy(
+                        queue_len,
+                        shared
+                            .shadow_stats
+                            .book_top_lag_p50_ms_for_symbol_sync(book.market_id.as_str()),
+                        strategy_max_coalesce,
+                        strategy_coalesce_min,
+                        strategy_coalesce_budget_us,
+                    );
+                    while coalesced < coalesce_policy.max_events as u64 {
+                        if coalesced > 0
+                            && (coalesce_start.elapsed().as_micros() as u64)
+                                >= coalesce_policy.budget_us
+                        {
+                            break;
+                        }
+                        match ingress_rx.try_recv() {
+                            Ok(StrategyIngressMsg {
+                                enqueued_ns,
+                                payload: StrategyIngress::BookTop(next_book),
+                            }) => {
+                                book = next_book;
+                                ingress_enqueued_ns = enqueued_ns;
+                                coalesced += 1;
+                            }
+                            Ok(StrategyIngressMsg {
+                                payload: StrategyIngress::RefTick(next_tick),
+                                ..
+                            }) => {
+                                let next_is_anchor =
+                                    is_anchor_ref_source(next_tick.source.as_str());
+                                if !next_is_anchor
+                                    && !fast_tick_allowed_in_fusion_mode(
+                                        next_tick.source.as_str(),
+                                        &current_fusion_mode,
+                                    )
+                                {
+                                    coalesced += 1;
+                                    continue;
+                                }
+                                insert_latest_ref_tick(
+                                    &mut latest_fast_ticks,
+                                    &mut latest_anchor_ticks,
+                                    next_tick,
+                                );
+                                coalesced += 1;
+                            }
+                            Err(tokio::sync::mpsc::error::TryRecvError::Empty) => break,
+                            Err(tokio::sync::mpsc::error::TryRecvError::Disconnected) => {
+                                shared
+                                    .shadow_stats
+                                    .record_issue("strategy_ingress_disconnected")
+                                    .await;
+                                break;
+                            }
+                        }
+                    }
+                    if coalesced > 0 {
+                        metrics::counter!("runtime.coalesced_events").increment(coalesced);
+                    }
+                    if book.recv_ts_local_ns > 0 {
+                        let book_age_ms =
+                            ((now_ns() - book.recv_ts_local_ns).max(0) as f64) / 1_000_000.0;
+                        if book_age_ms > strategy_drop_stale_book_ms {
+                            stale_book_drops = stale_book_drops.saturating_add(1);
+                            metrics::counter!("strategy.stale_book_dropped").increment(1);
+                            metrics::histogram!("latency.stale_book_drop_age_ms")
+                                .record(book_age_ms);
+                            if stale_book_drops.is_multiple_of(128) {
+                                shared.shadow_stats.record_issue("stale_book_dropped").await;
+                            }
+                            continue;
+                        }
+                    }
+
+                    let backlog_depth = ingress_rx.len() as f64;
+                    metrics::histogram!("runtime.event_backlog_depth").record(backlog_depth);
+                    let queue_depth = execution.open_orders_count() as f64;
+                    metrics::histogram!("runtime.open_order_depth").record(queue_depth);
+                    let io_depth = current_jsonl_queue_depth() as f64;
+                    shared
+                        .shadow_stats
+                        .push_depth_sample(backlog_depth, queue_depth, io_depth)
+                        .await;
+                    metrics::histogram!("runtime.jsonl_queue_depth").record(io_depth);
+                    shared
+                        .latest_books
+                        .write()
+                        .await
+                        .insert(book.market_id.clone(), book.clone());
+
+                    if let Some(paper) = global_paper_runtime() {
+                        let chainlink_settlement_price =
+                            if let Some(symbol) = pick_market_symbol(&shared, &book).await {
+                                shared.settlement_prices.read().await.get(&symbol).copied()
+                            } else {
+                                None
+                            };
+                        paper.on_book(&book, chainlink_settlement_price).await;
+                    }
+                    let fills = shadow.on_book(&book);
+                    shared.shadow_stats.mark_filled(fills.len() as u64);
+                    for fill in fills {
+                        execution.mark_order_closed_local(&fill.order_id);
+                        portfolio.apply_fill(&fill);
+                        if let Some(paper) = global_paper_runtime() {
+                            paper.on_fill(&fill).await;
+                        }
+                        publish_if_telemetry_subscribers(&bus, EngineEvent::Fill(fill.clone()));
+                        let ingest_seq = next_normalized_ingest_seq();
+                        append_jsonl(
+                            &dataset_path("normalized", "fills.jsonl"),
+                            &serde_json::json!({
+                                "ts_ms": Utc::now().timestamp_millis(),
+                                "source_seq": Utc::now().timestamp_millis().max(0) as u64,
+                                "ingest_seq": ingest_seq,
+                                "fill": fill
+                            }),
+                        );
+                    }
+
+                    if *paused.read().await {
+                        shared.shadow_stats.record_issue("paused").await;
+                        continue;
+                    }
+                    if shared.shadow_stats.observe_only() {
+                        shared.shadow_stats.record_issue("observe_only").await;
+                        continue;
+                    }
+
+                    let symbol = pick_market_symbol(&shared, &book).await;
+                    let Some(symbol) = symbol else {
+                        if market_is_tracked(&shared, &book).await {
+                            {
+                                let mut states = shared.tox_state.write().await;
+                                let st = states.entry(book.market_id.clone()).or_default();
+                                st.symbol_missing = st.symbol_missing.saturating_add(1);
+                            }
+                            shared.shadow_stats.record_issue("symbol_missing").await;
+                        } else {
+                            let now = Instant::now();
+                            let should_record = untracked_issue_cooldown
+                                .get(&book.market_id)
+                                .map(|last| last.elapsed() >= Duration::from_secs(60))
+                                .unwrap_or(true);
+                            if should_record {
+                                shared.shadow_stats.record_issue("market_untracked").await;
+                                untracked_issue_cooldown.insert(book.market_id.clone(), now);
+                            }
+                        }
+                        if last_symbol_retry_refresh.elapsed() >= Duration::from_secs(15)
+                            && !symbol_refresh_inflight.swap(true, Ordering::AcqRel)
+                        {
+                            last_symbol_retry_refresh = Instant::now();
+                            let shared_refresh = shared.clone();
+                            let inflight = symbol_refresh_inflight.clone();
+                            spawn_detached("symbol_map_refresh", false, async move {
+                                refresh_market_symbol_map(&shared_refresh).await;
+                                inflight.store(false, Ordering::Release);
+                            });
+                        }
+                        continue;
+                    };
+                    let tick_fast_owned = shared
+                        .latest_fast_ticks
+                        .get(symbol.as_str())
+                        .map(|entry| entry.value().clone())
+                        .and_then(|tick| {
+                            if fast_tick_allowed_in_fusion_mode(
+                                tick.source.as_str(),
+                                &current_fusion_mode,
+                            ) {
+                                Some(tick)
+                            } else {
+                                None
+                            }
+                        });
+                    let tick_fast = tick_fast_owned
+                        .as_ref()
+                        .or_else(|| pick_latest_tick(&latest_fast_ticks, &symbol));
+                    let Some(tick_fast) = tick_fast else {
+                        shared.shadow_stats.record_issue("tick_missing").await;
+                        continue;
+                    };
+                    let fusion_mode = {
+                        let fusion = shared.fusion_cfg.read().await;
+                        fusion.mode.clone()
+                    };
+                    if !fast_tick_allowed_in_fusion_mode(tick_fast.source.as_str(), &fusion_mode) {
+                        shared
+                            .shadow_stats
+                            .record_issue("tick_source_mode_mismatch")
+                            .await;
+                        continue;
+                    }
+                    let tick_anchor_owned = shared
+                        .latest_anchor_ticks
+                        .get(symbol.as_str())
+                        .map(|entry| entry.value().clone());
+                    let tick_anchor = tick_anchor_owned
+                        .as_ref()
+                        .or_else(|| pick_latest_tick(&latest_anchor_ticks, &symbol));
+                    if let Some(anchor) = tick_anchor {
+                        let now_ms = Utc::now().timestamp_millis();
+                        let age_ms = now_ms - ref_event_ts_ms(anchor);
+                        if age_ms > 5_000 {
+                            shared.shadow_stats.record_issue("anchor_stale").await;
+                        }
+                    } else {
+                        shared.shadow_stats.record_issue("anchor_missing").await;
+                    }
+                    // For latency-sensitive trading, evaluate fair value on the fastest observable
+                    // reference tick. The Chainlink anchor is tracked for correctness auditing and
+                    // can be used for future calibration, but should not slow down the trigger.
+                    let eval_tick = tick_fast;
+                    if !is_anchor_ref_source(eval_tick.source.as_str()) {
+                        let event_ms = ref_event_ts_ms(eval_tick);
+                        let should_update_direction = last_direction_tick_event_ms
+                            .get(symbol.as_str())
+                            .map(|prev| event_ms > *prev)
+                            .unwrap_or(true);
+                        if should_update_direction {
+                            shared
+                                .predator_direction_detector
+                                .write()
+                                .await
+                                .on_tick(eval_tick);
+                            last_direction_tick_event_ms.insert(symbol.clone(), event_ms);
+                        }
+                    }
+                    shared.shadow_stats.mark_seen();
+
+                    // Positive value means: our fast reference tick arrived earlier than the
+                    // Polymarket book update (i.e. the exploitable lag window).
+                    //
+                    // Guardrail: if the tick is already old, this is not a meaningful "lag window"
+                    // measurement and would inflate p50/p99. We only sample when the tick is fresh.
+                    let tick_age_ms =
+                        freshness_ms(Utc::now().timestamp_millis(), tick_fast.recv_ts_ms);
+                    let stale_ms = tick_age_ms.max(0) as f64;
+                    let book_top_lag_ms = if tick_age_ms <= 1_500
+                        && tick_fast.recv_ts_local_ns > 0
+                        && book.recv_ts_local_ns > 0
+                    {
+                        ((book.recv_ts_local_ns - tick_fast.recv_ts_local_ns).max(0) as f64)
+                            / 1_000_000.0
+                    } else {
+                        0.0
+                    };
+                    let should_sample_book_lag = book_lag_sample_at
+                        .get(&symbol)
+                        .map(|t| t.elapsed() >= Duration::from_millis(200))
+                        .unwrap_or(true);
+                    if should_sample_book_lag {
+                        book_lag_sample_at.insert(symbol.clone(), Instant::now());
+                        shared
+                            .shadow_stats
+                            .push_book_top_lag_ms(&symbol, book_top_lag_ms)
+                            .await;
+                    }
+
+                    let latency_sample = estimate_feed_latency(tick_fast, &book);
+                    let feed_in_ms = latency_sample.feed_in_ms;
+                    let stale_tick_filter_ms =
+                        shared.strategy_cfg.read().await.stale_tick_filter_ms;
+                    shared
+                        .shadow_stats
+                        .push_latency_sample(
+                            feed_in_ms,
+                            latency_sample.source_latency_ms,
+                            latency_sample.exchange_lag_ms,
+                            latency_sample.path_lag_ms,
+                            latency_sample.book_latency_ms,
+                            latency_sample.local_backlog_ms,
+                            latency_sample.ref_decode_ms,
+                        )
+                        .await;
+                    metrics::histogram!("latency.feed_in_ms").record(feed_in_ms);
+                    metrics::histogram!("latency.source_latency_ms")
+                        .record(latency_sample.source_latency_ms);
+                    metrics::histogram!("latency.exchange_lag_ms")
+                        .record(latency_sample.exchange_lag_ms);
+                    if latency_sample.path_lag_ms.is_finite() && latency_sample.path_lag_ms >= 0.0 {
+                        metrics::histogram!("latency.path_lag_ms")
+                            .record(latency_sample.path_lag_ms);
+                    }
+                    metrics::histogram!("latency.book_latency_ms")
+                        .record(latency_sample.book_latency_ms);
+                    metrics::histogram!("latency.local_backlog_ms")
+                        .record(latency_sample.local_backlog_ms);
+                    metrics::histogram!("latency.ref_decode_ms")
+                        .record(latency_sample.ref_decode_ms);
+                    // Stale tick filtering must be based on *local* staleness/age, not exchange
+                    // event timestamps (which can be skewed across venues).
+                    if stale_ms > stale_tick_filter_ms {
+                        shared.shadow_stats.mark_stale_tick_dropped();
+                        shared.shadow_stats.record_issue("stale_tick_dropped").await;
+                        continue;
+                    }
+                    if latency_sample.local_backlog_ms > strategy_max_decision_backlog_ms {
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("decision_backlog_guard")
+                            .await;
+                        metrics::counter!("strategy.decision_backlog_guard").increment(1);
+                        continue;
+                    }
+                    let queue_wait_ms = if ingress_enqueued_ns > 0 {
+                        ((now_ns() - ingress_enqueued_ns).max(0) as f64) / 1_000_000.0
+                    } else {
+                        latency_sample.local_backlog_ms
+                    };
+                    shared
+                        .shadow_stats
+                        .push_decision_queue_wait_ms(queue_wait_ms)
+                        .await;
+                    metrics::histogram!("latency.decision_queue_wait_ms").record(queue_wait_ms);
+                    let signal_start = Instant::now();
+                    let signal = fair.evaluate(eval_tick, &book);
+                    if signal.edge_bps_bid > 0.0 || signal.edge_bps_ask > 0.0 {
+                        shared.shadow_stats.mark_candidate();
+                    }
+                    let signal_us = signal_start.elapsed().as_secs_f64() * 1_000_000.0;
+                    shared.shadow_stats.push_signal_us(signal_us).await;
+                    metrics::histogram!("latency.signal_us").record(signal_us);
+                    publish_if_telemetry_subscribers(&bus, EngineEvent::Signal(signal.clone()));
+                    shared.latest_signals.insert(
+                        book.market_id.clone(),
+                        SignalCacheEntry {
+                            signal: signal.clone(),
+                            ts_ms: Utc::now().timestamp_millis(),
+                        },
+                    );
+                    if should_sample_book_lag && book_top_lag_ms >= 5.0 {
+                        // "Orderless" survival probe: measure whether an observed top-of-book
+                        // price survives for +Œî ms, independent of order placement.
+                        let mid_yes = (book.bid_yes + book.ask_yes) * 0.5;
+                        let probe_side = if signal.fair_yes >= mid_yes {
+                            OrderSide::BuyYes
+                        } else {
+                            OrderSide::BuyNo
+                        };
+                        let probe_px = aggressive_price_for_side(&book, &probe_side);
+                        if probe_px > 0.0 {
+                            for delay_ms in [5_u64, 10_u64, 25_u64] {
+                                spawn_survival_probe_task(
+                                    shared.clone(),
+                                    book.market_id.clone(),
+                                    symbol.clone(),
+                                    probe_side.clone(),
+                                    probe_px,
+                                    delay_ms,
+                                );
+                            }
+                        }
+                    }
+
+                    let cfg = shared.strategy_cfg.read().await.clone();
+                    let tox_cfg = shared.toxicity_cfg.read().await.clone();
+                    let pending_market_exposure =
+                        execution.open_order_notional_for_market(&book.market_id);
+
+                    let (
+                        tox_features,
+                        tox_decision,
+                        market_score,
+                        pending_exposure,
+                        no_quote_rate,
+                        symbol_missing_rate,
+                        markout_samples,
+                        active_by_rank,
+                    ) = {
+                        // Step A: snapshot (read-lock) the state needed for computation.
+                        let (
+                            attempted0,
+                            no_quote0,
+                            symbol_missing0,
+                            cooldown_until_ms0,
+                            markout_samples0,
+                            markout_1s_p50,
+                            markout_5s_p50,
+                            markout_10s_p50,
+                        ) = {
+                            let states = shared.tox_state.read().await;
+                            if let Some(st) = states.get(&book.market_id) {
+                                let samples = st
+                                    .markout_1s
+                                    .len()
+                                    .max(st.markout_5s.len())
+                                    .max(st.markout_10s.len());
+                                (
+                                    st.attempted,
+                                    st.no_quote,
+                                    st.symbol_missing,
+                                    st.cooldown_until_ms,
+                                    samples,
+                                    percentile_deque_capped(&st.markout_1s, 0.50, 1024)
+                                        .unwrap_or(0.0),
+                                    percentile_deque_capped(&st.markout_5s, 0.50, 1024)
+                                        .unwrap_or(0.0),
+                                    percentile_deque_capped(&st.markout_10s, 0.50, 2048)
+                                        .unwrap_or(0.0),
+                                )
+                            } else {
+                                (0, 0, 0, 0, 0, 0.0, 0.0, 0.0)
+                            }
+                        };
+
+                        // Step B: compute without holding a write lock.
+                        let attempted1 = attempted0.saturating_add(1).max(1);
+                        let tox_features = build_toxic_features(
+                            &book,
+                            &symbol,
+                            stale_ms,
+                            signal.fair_yes,
+                            attempted1,
+                            no_quote0,
+                            markout_1s_p50,
+                            markout_5s_p50,
+                            markout_10s_p50,
+                        );
+                        let mut tox_decision = evaluate_toxicity(&tox_features, &tox_cfg);
+                        let score_scale = (tox_cfg.k_spread / 1.5).clamp(0.25, 4.0);
+                        tox_decision.tox_score =
+                            (tox_decision.tox_score * score_scale).clamp(0.0, 1.0);
+                        tox_decision.regime = if tox_decision.tox_score >= tox_cfg.caution_threshold
+                        {
+                            ToxicRegime::Danger
+                        } else if tox_decision.tox_score >= tox_cfg.safe_threshold {
+                            ToxicRegime::Caution
+                        } else {
+                            ToxicRegime::Safe
+                        };
+
+                        let now_ms = Utc::now().timestamp_millis();
+                        let mut cooldown_until_ms1 = cooldown_until_ms0;
+                        if now_ms < cooldown_until_ms0 {
+                            tox_decision.regime = ToxicRegime::Danger;
+                            tox_decision
+                                .reason_codes
+                                .push("cooldown_active".to_string());
+                        }
+                        // Note: cooldown is based on the pre-warmup regime, matching the old behavior.
+                        if matches!(tox_decision.regime, ToxicRegime::Danger) {
+                            let cool = cooldown_secs_for_score(tox_decision.tox_score, &tox_cfg);
+                            cooldown_until_ms1 =
+                                cooldown_until_ms1.max(now_ms + (cool as i64) * 1_000);
+                        }
+                        let markout_samples = markout_samples0;
+                        if markout_samples < 20 {
+                            tox_decision.tox_score =
+                                tox_decision.tox_score.min(tox_cfg.safe_threshold * 0.8);
+                            tox_decision.regime = ToxicRegime::Safe;
+                            tox_decision
+                                .reason_codes
+                                .push("warmup_samples_lt_20".to_string());
+                        }
+
+                        let market_score = compute_market_score_from_snapshot(
+                            attempted1,
+                            no_quote0,
+                            symbol_missing0,
+                            tox_decision.tox_score,
+                            markout_samples,
+                            markout_10s_p50,
+                        );
+                        let no_quote_rate = (no_quote0 as f64 / attempted1 as f64).clamp(0.0, 1.0);
+                        let symbol_missing_rate =
+                            (symbol_missing0 as f64 / attempted1 as f64).clamp(0.0, 1.0);
+
+                        // Step C: short write-back only.
+                        {
+                            let mut states = shared.tox_state.write().await;
+                            let st = states.entry(book.market_id.clone()).or_default();
+                            st.attempted = st.attempted.saturating_add(1);
+                            st.symbol = symbol.clone();
+                            st.last_tox_score = tox_decision.tox_score;
+                            st.last_regime = tox_decision.regime.clone();
+                            st.cooldown_until_ms = st.cooldown_until_ms.max(cooldown_until_ms1);
+                            st.market_score = market_score;
+                        }
+
+                        // Step D: rank decision (read-lock, uses updated market_score).
+                        let active_by_rank = {
+                            let states = shared.tox_state.read().await;
+                            is_market_in_top_n(
+                                &states,
+                                &book.market_id,
+                                tox_cfg.active_top_n_markets,
+                            )
+                        };
+
+                        (
+                            tox_features,
+                            tox_decision,
+                            market_score,
+                            pending_market_exposure,
+                            no_quote_rate,
+                            symbol_missing_rate,
+                            markout_samples,
+                            active_by_rank,
+                        )
+                    };
+                    let spread_yes = (book.ask_yes - book.bid_yes).max(0.0);
+                    let effective_max_spread = adaptive_max_spread(
+                        cfg.max_spread,
+                        tox_decision.tox_score,
+                        markout_samples,
+                    );
+                    if should_observe_only_symbol(
+                        &symbol,
+                        &cfg,
+                        &tox_decision,
+                        stale_ms,
+                        spread_yes,
+                        book_top_lag_ms,
+                    ) {
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("symbol_quality_guard")
+                            .await;
+                        continue;
+                    }
+                    let queue_fill_proxy =
+                        estimate_queue_fill_proxy(tox_decision.tox_score, spread_yes, stale_ms);
+
+                    if spread_yes > effective_max_spread {
+                        {
+                            let mut states = shared.tox_state.write().await;
+                            let st = states.entry(book.market_id.clone()).or_default();
+                            st.no_quote = st.no_quote.saturating_add(1);
+                        }
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("no_quote_spread")
+                            .await;
+                        continue;
+                    }
+                    if signal.confidence <= 0.0 {
+                        {
+                            let mut states = shared.tox_state.write().await;
+                            let st = states.entry(book.market_id.clone()).or_default();
+                            st.no_quote = st.no_quote.saturating_add(1);
+                        }
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("no_quote_confidence")
+                            .await;
+                        continue;
+                    }
+
+                    publish_if_telemetry_subscribers(
+                        &bus,
+                        EngineEvent::ToxicFeatures(tox_features.clone()),
+                    );
+                    publish_if_telemetry_subscribers(
+                        &bus,
+                        EngineEvent::ToxicDecision(tox_decision.clone()),
+                    );
+                    let ingest_seq_features = next_normalized_ingest_seq();
+                    append_jsonl(
+                        &dataset_path("normalized", "tox_features.jsonl"),
+                        &serde_json::json!({
+                            "ts_ms": Utc::now().timestamp_millis(),
+                            "source_seq": book.ts_ms.max(0) as u64,
+                            "ingest_seq": ingest_seq_features,
+                            "features": tox_features
+                        }),
+                    );
+                    let ingest_seq_decisions = next_normalized_ingest_seq();
+                    append_jsonl(
+                        &dataset_path("normalized", "tox_decisions.jsonl"),
+                        &serde_json::json!({
+                            "ts_ms": Utc::now().timestamp_millis(),
+                            "source_seq": book.ts_ms.max(0) as u64,
+                            "ingest_seq": ingest_seq_decisions,
+                            "decision": tox_decision
+                        }),
+                    );
+                    let market_health = MarketHealth {
+                        market_id: book.market_id.clone(),
+                        symbol: symbol.clone(),
+                        symbol_missing_rate,
+                        no_quote_rate,
+                        pending_exposure,
+                        queue_fill_proxy,
+                        ts_ns: now_ns(),
+                    };
+                    let ingest_seq_health = next_normalized_ingest_seq();
+                    append_jsonl(
+                        &dataset_path("normalized", "market_health.jsonl"),
+                        &serde_json::json!({
+                            "ts_ms": Utc::now().timestamp_millis(),
+                            "source_seq": book.ts_ms.max(0) as u64,
+                            "ingest_seq": ingest_seq_health,
+                            "health": market_health
+                        }),
+                    );
+
+                    if market_score < tox_cfg.min_market_score {
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("market_score_low")
+                            .await;
+                        continue;
+                    }
+                    if !active_by_rank {
+                        shared
+                            .shadow_stats
+                            .mark_blocked_with_reason("market_rank_blocked")
+                            .await;
+                        continue;
+                    }
+
+                    let predator_cfg = shared.predator_cfg.read().await.clone();
+                    if predator_cfg.enabled {
+                        let now_ms = Utc::now().timestamp_millis();
+                        let _ = evaluate_and_route_v52(
+                            &shared,
+                            &bus,
+                            &portfolio,
+                            &execution,
+                            &shadow,
+                            &mut market_rate_budget,
+                            &mut global_rate_budget,
+                            &predator_cfg,
+                            &symbol,
+                            tick_fast.recv_ts_ms,
+                            tick_fast.recv_ts_local_ns,
+                            now_ms,
+                            None,
+                        )
+                        .await;
+                        continue;
+                    }
+
+                    market_inventory.insert(
+                        book.market_id.clone(),
+                        inventory_for_market(&portfolio, &book.market_id),
+                    );
+                    shared
+                        .shadow_stats
+                        .mark_blocked_with_reason("predator_c_disabled")
+                        .await;
+                    continue;
+                }
+            }
+        }
+    });
+}
+
+#[derive(Debug, Default, Clone, Copy)]
+pub(crate) struct PredatorExecResult {
+    pub(crate) attempted: u64,
+    pub(crate) executed: u64,
+    pub(crate) stop_firing: bool,
+}
+
+fn opposite_side_for_reentry(side: &OrderSide) -> OrderSide {
+    match side {
+        OrderSide::BuyYes => OrderSide::BuyNo,
+        OrderSide::BuyNo => OrderSide::BuyYes,
+        OrderSide::SellYes => OrderSide::SellNo,
+        OrderSide::SellNo => OrderSide::SellYes,
+    }
+}
+
+fn maker_reentry_price_for_side(book: &BookTop, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes => book.bid_yes,
+        OrderSide::BuyNo => book.bid_no,
+        OrderSide::SellYes => book.ask_yes,
+        OrderSide::SellNo => book.ask_no,
+    }
+}
+
+pub(crate) fn build_reversal_reentry_order(
+    market_id: &str,
+    side: &OrderSide,
+    book: &BookTop,
+    size: f64,
+    ttl_ms: u64,
+    fee_rate_bps: f64,
+) -> Option<OrderIntentV2> {
+    let reentry_side = opposite_side_for_reentry(side);
+    let price = maker_reentry_price_for_side(book, &reentry_side);
+    if !price.is_finite() || price <= 0.0 {
+        return None;
+    }
+    let token_id = match reentry_side {
+        OrderSide::BuyYes | OrderSide::SellYes => book.token_id_yes.clone(),
+        OrderSide::BuyNo | OrderSide::SellNo => book.token_id_no.clone(),
+    };
+    Some(OrderIntentV2 {
+        market_id: market_id.to_string(),
+        token_id: Some(token_id),
+        side: reentry_side,
+        price,
+        size: size.max(0.01),
+        ttl_ms: ttl_ms.max(100),
+        style: ExecutionStyle::Maker,
+        tif: OrderTimeInForce::PostOnly,
+        max_slippage_bps: 0.0,
+        fee_rate_bps,
+        expected_edge_net_bps: 0.0,
+        client_order_id: Some(new_id()),
+        hold_to_resolution: false,
+        prebuilt_payload: None,
+    })
+}
+
+async fn reentry_candidate_for_market(
+    shared: &Arc<EngineShared>,
+    target_market_id: &str,
+    side: &OrderSide,
+    size: f64,
+    maker_ttl_ms: u64,
+    maker_min_edge_bps: f64,
+    fail_cost_bps: f64,
+) -> Option<(OrderIntentV2, BookTop)> {
+    let book = shared.latest_books.read().await.get(target_market_id).cloned()?;
+    let fee_rate_bps = get_fee_rate_bps_cached(shared, target_market_id).await;
+    let mut order = build_reversal_reentry_order(
+        target_market_id,
+        side,
+        &book,
+        size,
+        maker_ttl_ms,
+        fee_rate_bps,
+    )?;
+    let fair_yes = shared
+        .latest_signals
+        .get(target_market_id)
+        .map(|sig| sig.value().signal.fair_yes.clamp(0.0, 1.0))
+        .unwrap_or(0.5);
+    let quote_intent = QuoteIntent {
+        market_id: target_market_id.to_string(),
+        side: order.side.clone(),
+        price: order.price,
+        size: order.size,
+        ttl_ms: order.ttl_ms,
+    };
+    let rebate_bps = get_rebate_bps_cached(shared, target_market_id, fee_rate_bps).await;
+    let edge_net_bps =
+        edge_for_intent(fair_yes, &quote_intent) - fee_rate_bps + rebate_bps - fail_cost_bps;
+    if edge_net_bps < maker_min_edge_bps {
+        return None;
+    }
+    order.expected_edge_net_bps = edge_net_bps;
+    Some((order, book))
+}
+
+pub(crate) fn spawn_predator_exit_lifecycle(
+    shared: Arc<EngineShared>,
+    bus: RingBus<EngineEvent>,
+    execution: Arc<ClobExecution>,
+    shadow: Arc<ShadowExecutor>,
+    position_id: String,
+    market_id: String,
+    symbol: String,
+    side: OrderSide,
+    entry_price: f64,
+    size: f64,
+    maker_ttl_ms: u64,
+    entry_fair_yes: f64,
+) {
+    let mut fill_rx = shared.wss_fill_tx.as_ref().map(|tx| tx.subscribe());
+    let entry_pm_mid_yes = entry_price;
+
+    spawn_detached("predator_exit_lifecycle", false, async move {
+        let checkpoints = [3_000_u64, 15_000_u64, 60_000_u64, 300_000_u64];
+        let mut elapsed_ms = 0_u64;
+
+        'outer: for checkpoint in checkpoints {
+            let wait_ms = checkpoint.saturating_sub(elapsed_ms);
+            elapsed_ms = checkpoint;
+
+            if wait_ms > 0 {
+                let sleep = tokio::time::sleep(Duration::from_millis(wait_ms));
+                tokio::pin!(sleep);
+
+                loop {
+                    let fill_fut =
+                        futures::future::OptionFuture::from(fill_rx.as_mut().map(|rx| rx.recv()));
+                    tokio::select! {
+                        biased;
+                        Some(fill_result) = fill_fut => {
+                            if let Ok(fill) = fill_result {
+                                if fill.order_id == position_id || fill.market_id == market_id {
+                                    tracing::info!(
+                                        position_id = %position_id,
+                                        market_id = %market_id,
+                                        fill_price = fill.price,
+                                        fill_size = fill.size,
+                                        event_type = %fill.event_type,
+                                        "wss_user_feed: fill detected, triggering early exit eval"
+                                    );
+                                    metrics::counter!("wss.fill_detected").increment(1);
+                                    break;
+                                }
+                            }
+                        }
+                        _ = &mut sleep => break,
+                    }
+                }
+            }
+
+            let exit_cfg = shared.exit_cfg.read().await.clone();
+            if !exit_cfg.enabled {
+                continue 'outer;
+            }
+
+            let now_ms = Utc::now().timestamp_millis();
+            let true_prob = estimate_true_prob_for_side(&shared, &market_id, &side).await;
+            let unrealized_pnl_usdc =
+                estimate_unrealized_pnl_usdc(&shared, &market_id, &side, entry_price, size)
+                    .await
+                    .unwrap_or(0.0);
+            let time_to_expiry_ms = estimate_time_to_expiry_ms(&shared, &market_id, now_ms).await;
+
+            let pm_mid_yes = {
+                let books = shared.latest_books.read().await;
+                books
+                    .get(&market_id)
+                    .map(|b| (b.bid_yes + b.ask_yes) / 2.0)
+                    .unwrap_or(0.0)
+            };
+
+            let action = {
+                let mut manager = shared.predator_exit_manager.write().await;
+                manager.evaluate_market(
+                    &market_id,
+                    MarketEvalInput {
+                        now_ms,
+                        unrealized_pnl_usdc,
+                        true_prob,
+                        time_to_expiry_ms,
+                        pm_mid_yes,
+                        entry_pm_mid_yes,
+                        entry_fair_yes,
+                    },
+                )
+            };
+
+            if let Some(action) = action {
+                let reason_kind = action.reason.clone();
+                let reason = exit_reason_label(reason_kind.clone());
+                shared.shadow_stats.record_exit_reason(reason).await;
+                if exit_cfg.flatten_on_trigger {
+                    let _ = bus.publish(EngineEvent::Control(ControlCommand::Flatten));
+                }
+                if matches!(
+                    reason_kind,
+                    ExitReason::Reversal100ms | ExitReason::Reversal300ms
+                ) {
+                    let maker_cfg = shared.strategy_cfg.read().await.clone();
+                    let fail_cost_bps = shared.edge_model_cfg.read().await.fail_cost_bps;
+                    let same_market_first = shared
+                        .predator_cfg
+                        .read()
+                        .await
+                        .v52
+                        .reversal
+                        .same_market_opposite_first;
+                    let mut selected: Option<(OrderIntentV2, BookTop, String)> = None;
+
+                    if same_market_first {
+                        selected = reentry_candidate_for_market(
+                            &shared,
+                            &market_id,
+                            &side,
+                            size,
+                            maker_ttl_ms,
+                            maker_cfg.min_edge_bps,
+                            fail_cost_bps,
+                        )
+                        .await
+                        .map(|(order, book)| (order, book, market_id.clone()));
+                        if selected.is_none() {
+                            shared
+                                .shadow_stats
+                                .mark_blocked_with_reason("reversal_rebuild_same_market_no_edge")
+                                .await;
+                        }
+                    }
+
+                    if selected.is_none() {
+                        let other_markets = shared
+                            .symbol_to_markets
+                            .read()
+                            .await
+                            .get(symbol.as_str())
+                            .cloned()
+                            .unwrap_or_default();
+                        for other_market_id in other_markets {
+                            if same_market_first && other_market_id == market_id {
+                                continue;
+                            }
+                            if !same_market_first && other_market_id != market_id {
+                                if let Some((order, book)) = reentry_candidate_for_market(
+                                    &shared,
+                                    other_market_id.as_str(),
+                                    &side,
+                                    size,
+                                    maker_ttl_ms,
+                                    maker_cfg.min_edge_bps,
+                                    fail_cost_bps,
+                                )
+                                .await
+                                {
+                                    selected = Some((order, book, other_market_id));
+                                    break;
+                                }
+                                continue;
+                            }
+                            if let Some((order, book)) = reentry_candidate_for_market(
+                                &shared,
+                                other_market_id.as_str(),
+                                &side,
+                                size,
+                                maker_ttl_ms,
+                                maker_cfg.min_edge_bps,
+                                fail_cost_bps,
+                            )
+                            .await
+                            {
+                                selected = Some((order, book, other_market_id));
+                                break;
+                            }
+                        }
+                        if selected.is_none() {
+                            shared
+                                .shadow_stats
+                                .mark_blocked_with_reason("reversal_rebuild_cross_market_no_edge")
+                                .await;
+                        }
+                    }
+
+                    if let Some((reentry_order, book, target_market_id)) = selected {
+                        let reentry_fee_ref_bps = reentry_order.fee_rate_bps;
+                        let quote_intent = QuoteIntent {
+                            market_id: reentry_order.market_id.clone(),
+                            side: reentry_order.side.clone(),
+                            price: reentry_order.price,
+                            size: reentry_order.size,
+                            ttl_ms: reentry_order.ttl_ms,
+                        };
+                        publish_if_telemetry_subscribers(
+                            &bus,
+                            EngineEvent::QuoteIntent(quote_intent.clone()),
+                        );
+                        match execution.place_order_v2(reentry_order).await {
+                            Ok(ack) if ack.accepted => {
+                                shared.shadow_stats.mark_executed();
+                                let ack_event = OrderAck {
+                                    order_id: ack.order_id,
+                                    market_id: ack.market_id,
+                                    accepted: true,
+                                    ts_ms: ack.ts_ms,
+                                };
+                                publish_if_telemetry_subscribers(
+                                    &bus,
+                                    EngineEvent::OrderAck(ack_event.clone()),
+                                );
+                                if let Some(paper) = global_paper_runtime() {
+                                    let timeframe_class = shared
+                                        .market_to_timeframe
+                                        .read()
+                                        .await
+                                        .get(&target_market_id)
+                                        .cloned();
+                                    let timeframe = timeframe_class
+                                        .as_ref()
+                                        .map(ToString::to_string)
+                                        .unwrap_or_else(|| "unknown".to_string());
+                                    let stage = if let Some(tf) = timeframe_class {
+                                        if let Some(total_ms) = timeframe_total_ms(tf.clone()) {
+                                            let rem_ms =
+                                                (total_ms - now_ms.rem_euclid(total_ms)).max(0);
+                                            let rem_ratio =
+                                                (rem_ms as f64 / total_ms as f64).clamp(0.0, 1.0);
+                                            let predator_cfg = shared.predator_cfg.read().await.clone();
+                                            let phase =
+                                                classify_time_phase(rem_ratio, &predator_cfg.v52.time_phase);
+                                            stage_for_phase(phase, true)
+                                        } else {
+                                            Stage::Maturity
+                                        }
+                                    } else {
+                                        Stage::Maturity
+                                    };
+                                    let entry_price = match quote_intent.side {
+                                        OrderSide::BuyYes | OrderSide::SellYes => {
+                                            (book.bid_yes + book.ask_yes) * 0.5
+                                        }
+                                        OrderSide::BuyNo | OrderSide::SellNo => {
+                                            (book.bid_no + book.ask_no) * 0.5
+                                        }
+                                    };
+                                    paper
+                                        .register_order_intent(
+                                            &ack_event,
+                                            PaperIntentCtx {
+                                                market_id: target_market_id.clone(),
+                                                symbol: symbol.clone(),
+                                                timeframe,
+                                                stage,
+                                                direction: match quote_intent.side {
+                                                    OrderSide::BuyYes | OrderSide::SellNo => {
+                                                        Direction::Up
+                                                    }
+                                                    OrderSide::BuyNo | OrderSide::SellYes => {
+                                                        Direction::Down
+                                                    }
+                                                },
+                                                velocity_bps_per_sec: 0.0,
+                                                edge_bps: 0.0,
+                                                prob_fast: 0.5,
+                                                prob_settle: 0.5,
+                                                confidence: 0.0,
+                                                action: PaperAction::ReversalExit,
+                                                intent: ExecutionStyle::Maker,
+                                                requested_size_usdc: (quote_intent.price
+                                                    * quote_intent.size)
+                                                    .max(0.0),
+                                                requested_size_contracts: quote_intent.size,
+                                                entry_price,
+                                            },
+                                        )
+                                        .await;
+                                }
+                                shadow.register_order(
+                                    &ack_event,
+                                    quote_intent.clone(),
+                                    ExecutionStyle::Maker,
+                                    ((book.bid_yes + book.ask_yes) * 0.5).max(0.0),
+                                    -get_rebate_bps_cached(
+                                        &shared,
+                                        &target_market_id,
+                                        reentry_fee_ref_bps,
+                                    )
+                                    .await
+                                    .max(0.0),
+                                );
+                            }
+                            Ok(_) => {}
+                            Err(err) => {
+                                tracing::warn!(
+                                    market_id = %target_market_id,
+                                    symbol = %symbol,
+                                    error = %err,
+                                    "reversal maker re-entry failed"
+                                );
+                            }
+                        }
+                    }
+                }
+                tracing::info!(
+                    position_id = %position_id,
+                    market_id = %market_id,
+                    symbol = %symbol,
+                    reason,
+                    "predator exit lifecycle triggered"
+                );
+                break 'outer;
+            }
+        }
+
+        // Ensure stale lifecycle entries don't leak forever if no exit action is triggered.
+        if elapsed_ms >= 300_000 {
+            let _ = shared
+                .predator_exit_manager
+                .write()
+                .await
+                .close(&position_id);
+        }
+    });
+}
+
+async fn estimate_true_prob_for_side(
+    shared: &Arc<EngineShared>,
+    market_id: &str,
+    side: &OrderSide,
+) -> f64 {
+    let p_yes = shared
+        .latest_signals
+        .get(market_id)
+        .map(|sig| sig.value().signal.fair_yes.clamp(0.0, 1.0))
+        .unwrap_or(0.5);
+    match side {
+        OrderSide::BuyYes | OrderSide::SellNo => p_yes,
+        OrderSide::BuyNo | OrderSide::SellYes => 1.0 - p_yes,
+    }
+}
+
+pub(crate) async fn estimate_time_to_expiry_ms(
+    shared: &Arc<EngineShared>,
+    market_id: &str,
+    now_ms: i64,
+) -> i64 {
+    let timeframe = shared
+        .market_to_timeframe
+        .read()
+        .await
+        .get(market_id)
+        .cloned();
+    let frame_ms = match timeframe {
+        Some(TimeframeClass::Tf5m) => 5 * 60 * 1_000,
+        Some(TimeframeClass::Tf15m) => 15 * 60 * 1_000,
+        Some(TimeframeClass::Tf1h) => 60 * 60 * 1_000,
+        Some(TimeframeClass::Tf1d) => 24 * 60 * 60 * 1_000,
+        None => return i64::MAX,
+    } as i64;
+    let rem = frame_ms - now_ms.rem_euclid(frame_ms);
+    rem.max(0)
+}
+
+async fn estimate_unrealized_pnl_usdc(
+    shared: &Arc<EngineShared>,
+    market_id: &str,
+    side: &OrderSide,
+    entry_price: f64,
+    size: f64,
+) -> Option<f64> {
+    let book = shared.latest_books.read().await.get(market_id).cloned()?;
+    let mark = match side {
+        OrderSide::BuyYes | OrderSide::SellYes => book.bid_yes.max(0.0),
+        OrderSide::BuyNo | OrderSide::SellNo => book.bid_no.max(0.0),
+    };
+    let dir = match side {
+        OrderSide::BuyYes | OrderSide::BuyNo => 1.0,
+        OrderSide::SellYes | OrderSide::SellNo => -1.0,
+    };
+    Some((mark - entry_price) * size * dir)
+}
+
+pub(crate) fn spawn_shadow_outcome_task(
+    shared: Arc<EngineShared>,
+    bus: RingBus<EngineEvent>,
+    shot: ShadowShot,
+) {
+    spawn_detached("shadow_outcome", false, async move {
+        tokio::time::sleep(Duration::from_millis(shot.delay_ms)).await;
+        if !shared.shadow_stats.is_current_window_ts_ns(shot.t0_ns) {
+            metrics::counter!("shadow.outcome_window_mismatch").increment(1);
+            return;
+        }
+
+        let book = shared
+            .latest_books
+            .read()
+            .await
+            .get(&shot.market_id)
+            .cloned();
+        let latency_ms = ((now_ns() - shot.t0_ns).max(0) as f64) / 1_000_000.0;
+        shared.shadow_stats.push_shadow_fill_ms(latency_ms).await;
+        metrics::histogram!("latency.shadow_fill_ms").record(latency_ms);
+
+        let (
+            survived,
+            fillable,
+            slippage_bps,
+            queue_fill_prob,
+            attribution,
+            pnl_1s_bps,
+            pnl_5s_bps,
+            pnl_10s_bps,
+        ) = if let Some(book) = book {
+            let survived = evaluate_survival(&shot, &book);
+            let (fillable, slippage_bps, queue_fill_prob) =
+                evaluate_fillable(&shot, &book, latency_ms);
+            if fillable {
+                let p1 = pnl_after_horizon(&shared, &shot, Duration::from_secs(1)).await;
+                let p5 = pnl_after_horizon(&shared, &shot, Duration::from_secs(5)).await;
+                let p10 = pnl_after_horizon(&shared, &shot, Duration::from_secs(10)).await;
+                let attribution = classify_filled_outcome(shot.edge_net_bps, p10, slippage_bps);
+                (
+                    survived,
+                    true,
+                    slippage_bps,
+                    queue_fill_prob,
+                    attribution,
+                    p1,
+                    p5,
+                    p10,
+                )
+            } else {
+                let attribution = classify_unfilled_outcome(
+                    &book,
+                    latency_ms,
+                    shot.delay_ms,
+                    survived,
+                    queue_fill_prob,
+                );
+                (
+                    survived,
+                    false,
+                    slippage_bps,
+                    queue_fill_prob,
+                    attribution,
+                    None,
+                    None,
+                    None,
+                )
+            }
+        } else {
+            (
+                false,
+                false,
+                None,
+                0.0,
+                EdgeAttribution::SignalLag,
+                None,
+                None,
+                None,
+            )
+        };
+        let net_markout_1s_bps = net_markout(pnl_1s_bps, &shot);
+        let net_markout_5s_bps = net_markout(pnl_5s_bps, &shot);
+        let net_markout_10s_bps = net_markout(pnl_10s_bps, &shot);
+        let entry_notional_usdc = estimate_entry_notional_usdc(&shot);
+        let net_markout_10s_usdc = bps_to_usdc(net_markout_10s_bps, entry_notional_usdc);
+        let roi_notional_10s_bps = roi_bps_from_usdc(net_markout_10s_usdc, entry_notional_usdc);
+
+        let outcome = ShadowOutcome {
+            shot_id: shot.shot_id.clone(),
+            market_id: shot.market_id.clone(),
+            symbol: shot.symbol.clone(),
+            side: shot.side.clone(),
+            delay_ms: shot.delay_ms,
+            survived,
+            fillable,
+            execution_style: shot.execution_style.clone(),
+            slippage_bps,
+            pnl_1s_bps,
+            pnl_5s_bps,
+            pnl_10s_bps,
+            net_markout_1s_bps,
+            net_markout_5s_bps,
+            net_markout_10s_bps,
+            entry_notional_usdc,
+            net_markout_10s_usdc,
+            roi_notional_10s_bps,
+            queue_fill_prob,
+            is_stale_tick: false,
+            is_outlier: false,
+            robust_weight: 1.0,
+            attribution,
+            ts_ns: now_ns(),
+        };
+        if !shared.shadow_stats.is_current_window_ts_ns(outcome.ts_ns) {
+            metrics::counter!("shadow.outcome_window_mismatch").increment(1);
+            return;
+        }
+        shared.shadow_stats.push_outcome(outcome.clone()).await;
+        if shot.delay_ms == 10 {
+            let exit_cfg = shared.exit_cfg.read().await.clone();
+            if exit_cfg.enabled {
+                let true_prob = shared
+                    .latest_signals
+                    .get(&shot.market_id)
+                    .map(|sig| {
+                        let p_yes = sig.value().signal.fair_yes.clamp(0.0, 1.0);
+                        match shot.side {
+                            OrderSide::BuyYes | OrderSide::SellNo => p_yes,
+                            OrderSide::BuyNo | OrderSide::SellYes => 1.0 - p_yes,
+                        }
+                    })
+                    .unwrap_or(0.5);
+                let action = {
+                    let mut manager = shared.predator_exit_manager.write().await;
+                    manager.evaluate_market(
+                        &shot.market_id,
+                        MarketEvalInput {
+                            now_ms: Utc::now().timestamp_millis(),
+                            unrealized_pnl_usdc: outcome.net_markout_10s_usdc.unwrap_or(0.0),
+                            true_prob,
+                            time_to_expiry_ms: i64::MAX,
+                            pm_mid_yes: 0.0,
+                            entry_pm_mid_yes: 0.0,
+                            entry_fair_yes: 0.0,
+                        },
+                    )
+                };
+                if let Some(action) = action {
+                    let reason = exit_reason_label(action.reason);
+                    shared.shadow_stats.record_exit_reason(reason).await;
+                    if exit_cfg.flatten_on_trigger {
+                        let _ = bus.publish(EngineEvent::Control(ControlCommand::Flatten));
+                    }
+                }
+            }
+        }
+        update_toxic_state_from_outcome(&shared, &outcome).await;
+        if shot.delay_ms == 10 {
+            if let Some(pnl_usdc) = outcome.net_markout_10s_usdc {
+                let compounder_enabled = shared.predator_cfg.read().await.compounder.enabled;
+                if compounder_enabled {
+                    let (update, halt) = {
+                        let mut c = shared.predator_compounder.write().await;
+                        let update = c.on_markout(pnl_usdc);
+                        (update, c.halted())
+                    };
+                    shared
+                        .shadow_stats
+                        .set_predator_capital(update.clone(), halt)
+                        .await;
+                    publish_if_telemetry_subscribers(&bus, EngineEvent::CapitalUpdate(update));
+
+                    if halt {
+                        let live_armed = std::env::var("POLYEDGE_LIVE_ARMED")
+                            .map(|v| v.eq_ignore_ascii_case("true") || v == "1")
+                            .unwrap_or(false);
+                        if live_armed {
+                            shared.shadow_stats.record_issue("capital_halt").await;
+                            let _ = bus.publish(EngineEvent::Control(ControlCommand::Pause));
+                            let _ = bus.publish(EngineEvent::Control(ControlCommand::Flatten));
+                        }
+                    }
+                }
+            }
+            let eval = QuoteEval {
+                market_id: shot.market_id.clone(),
+                symbol: shot.symbol.clone(),
+                survival_10ms: if outcome.survived { 1.0 } else { 0.0 },
+                maker_markout_10s_bps: outcome.net_markout_10s_bps.unwrap_or(0.0),
+                adverse_flag: outcome.net_markout_10s_bps.unwrap_or(0.0) < 0.0,
+                ts_ns: now_ns(),
+            };
+            let ingest_seq = next_normalized_ingest_seq();
+            append_jsonl(
+                &dataset_path("normalized", "quote_eval.jsonl"),
+                &serde_json::json!({
+                    "ts_ms": Utc::now().timestamp_millis(),
+                    "source_seq": shot.t0_ns.max(0) as u64,
+                    "ingest_seq": ingest_seq,
+                    "eval": eval
+                }),
+            );
+            publish_if_telemetry_subscribers(&bus, EngineEvent::QuoteEval(eval));
+        }
+        publish_if_telemetry_subscribers(&bus, EngineEvent::ShadowOutcome(outcome));
+    });
+}
+
+fn spawn_survival_probe_task(
+    shared: Arc<EngineShared>,
+    market_id: String,
+    symbol: String,
+    side: OrderSide,
+    probe_px: f64,
+    delay_ms: u64,
+) {
+    spawn_detached("survival_probe", false, async move {
+        tokio::time::sleep(Duration::from_millis(delay_ms)).await;
+        let book = shared.latest_books.read().await.get(&market_id).cloned();
+        let survived = match book {
+            Some(ref b) => is_crossable(&side, probe_px, b),
+            None => false,
+        };
+        shared
+            .shadow_stats
+            .record_survival_probe(&symbol, delay_ms, survived)
+            .await;
+    });
+}
+
+async fn refresh_market_symbol_map(shared: &EngineShared) {
+    let discovery = MarketDiscovery::new(DiscoveryConfig {
+        symbols: (*shared.universe_symbols).clone(),
+        market_types: (*shared.universe_market_types).clone(),
+        timeframes: (*shared.universe_timeframes).clone(),
+        ..DiscoveryConfig::default()
+    });
+    match discovery.discover().await {
+        Ok(markets) => {
+            let mut market_map = HashMap::new();
+            let mut token_map = HashMap::new();
+            let mut timeframe_map = HashMap::new();
+            let mut symbol_to_markets = HashMap::<String, Vec<String>>::new();
+            for m in markets {
+                market_map.insert(m.market_id.clone(), m.symbol.clone());
+                symbol_to_markets
+                    .entry(m.symbol.clone())
+                    .or_default()
+                    .push(m.market_id.clone());
+                if let Some(tf) = m.timeframe.as_deref().and_then(parse_timeframe_class) {
+                    timeframe_map.insert(m.market_id.clone(), tf);
+                }
+                if let Some(t) = m.token_id_yes {
+                    token_map.insert(t, m.symbol.clone());
+                }
+                if let Some(t) = m.token_id_no {
+                    token_map.insert(t, m.symbol.clone());
+                }
+            }
+            for v in symbol_to_markets.values_mut() {
+                v.sort();
+                v.dedup();
+            }
+            {
+                let mut map = shared.market_to_symbol.write().await;
+                *map = market_map;
+            }
+            {
+                let mut map = shared.token_to_symbol.write().await;
+                *map = token_map;
+            }
+            {
+                let mut map = shared.market_to_timeframe.write().await;
+                *map = timeframe_map;
+            }
+            {
+                let mut map = shared.symbol_to_markets.write().await;
+                *map = symbol_to_markets;
+            }
+        }
+        Err(err) => {
+            tracing::warn!(?err, "market discovery refresh failed");
+        }
+    }
+}
+
+fn parse_timeframe_class(tf: &str) -> Option<TimeframeClass> {
+    match tf.trim().to_ascii_lowercase().as_str() {
+        "5m" | "tf5m" => Some(TimeframeClass::Tf5m),
+        "15m" | "tf15m" => Some(TimeframeClass::Tf15m),
+        "1h" | "tf1h" => Some(TimeframeClass::Tf1h),
+        "1d" | "tf1d" => Some(TimeframeClass::Tf1d),
+        _ => None,
+    }
+}
+
+async fn pick_market_symbol(shared: &EngineShared, book: &BookTop) -> Option<String> {
+    if let Some(v) = shared
+        .market_to_symbol
+        .read()
+        .await
+        .get(&book.market_id)
+        .cloned()
+    {
+        return Some(v);
+    }
+    let token_map = shared.token_to_symbol.read().await;
+    token_map
+        .get(&book.token_id_yes)
+        .cloned()
+        .or_else(|| token_map.get(&book.token_id_no).cloned())
+}
+
+async fn market_is_tracked(shared: &EngineShared, book: &BookTop) -> bool {
+    if shared
+        .market_to_symbol
+        .read()
+        .await
+        .contains_key(&book.market_id)
+    {
+        return true;
+    }
+    let token_map = shared.token_to_symbol.read().await;
+    token_map.contains_key(&book.token_id_yes) || token_map.contains_key(&book.token_id_no)
+}
+
diff --git a/crates/app_runner/src/execution_eval.rs b/crates/app_runner/src/execution_eval.rs
new file mode 100644
index 0000000..0abb339
--- /dev/null
+++ b/crates/app_runner/src/execution_eval.rs
@@ -0,0 +1,342 @@
+use std::time::{Duration, Instant};
+
+use core_types::{BookTop, EdgeAttribution, OrderIntentV2, OrderSide, QuoteIntent, ShadowShot};
+use reqwest::Client;
+use serde::Serialize;
+
+use crate::state::{EngineShared, FeeRateEntry};
+use crate::stats_utils::value_to_f64;
+use crate::strategy_policy::estimate_queue_fill_prob;
+use crate::spawn_detached;
+
+pub(super) async fn get_fee_rate_bps_cached(shared: &EngineShared, market_id: &str) -> f64 {
+    const DEFAULT_FEE_BPS: f64 = 2.0;
+    const TTL: Duration = Duration::from_secs(60);
+    const REFRESH_BACKOFF: Duration = Duration::from_secs(3);
+
+    let now = Instant::now();
+    let (cached_fee, needs_refresh) =
+        if let Some(entry) = shared.fee_cache.read().await.get(market_id).cloned() {
+            (
+                entry.fee_bps,
+                now.duration_since(entry.fetched_at) >= TTL || entry.fee_bps <= 0.0,
+            )
+        } else {
+            (DEFAULT_FEE_BPS, true)
+        };
+
+    if needs_refresh {
+        maybe_spawn_fee_refresh(shared, market_id, now, REFRESH_BACKOFF).await;
+    }
+
+    cached_fee
+}
+
+pub(super) async fn get_rebate_bps_cached(
+    shared: &EngineShared,
+    market_id: &str,
+    fee_bps: f64,
+) -> f64 {
+    const TTL: Duration = Duration::from_secs(120);
+    let now = Instant::now();
+    let maybe = shared.scoring_cache.read().await.get(market_id).cloned();
+    match maybe {
+        Some(entry) if now.duration_since(entry.fetched_at) <= TTL => {
+            entry.rebate_bps_est.clamp(0.0, fee_bps.max(0.0))
+        }
+        _ => 0.0,
+    }
+}
+
+pub(super) async fn maybe_spawn_fee_refresh(
+    shared: &EngineShared,
+    market_id: &str,
+    now: Instant,
+    refresh_backoff: Duration,
+) {
+    {
+        let inflight = shared.fee_refresh_inflight.read().await;
+        if let Some(last_attempt) = inflight.get(market_id) {
+            if now.duration_since(*last_attempt) < refresh_backoff {
+                return;
+            }
+        }
+    }
+
+    {
+        let mut inflight = shared.fee_refresh_inflight.write().await;
+        if let Some(last_attempt) = inflight.get(market_id) {
+            if now.duration_since(*last_attempt) < refresh_backoff {
+                return;
+            }
+        }
+        inflight.insert(market_id.to_string(), now);
+    }
+
+    let market = market_id.to_string();
+    let http = shared.http.clone();
+    let clob_endpoint = shared.clob_endpoint.clone();
+    let fee_cache = shared.fee_cache.clone();
+    let inflight = shared.fee_refresh_inflight.clone();
+    spawn_detached("fee_refresh", false, async move {
+        if let Some(fee_bps) = fetch_fee_rate_bps(&http, &clob_endpoint, &market).await {
+            fee_cache.write().await.insert(
+                market.clone(),
+                FeeRateEntry {
+                    fee_bps,
+                    fetched_at: Instant::now(),
+                },
+            );
+        }
+        inflight.write().await.remove(&market);
+    });
+}
+
+pub(super) async fn fetch_fee_rate_bps(
+    http: &Client,
+    clob_endpoint: &str,
+    market_id: &str,
+) -> Option<f64> {
+    let base = clob_endpoint.trim_end_matches('/');
+    let endpoints = [
+        format!("{base}/fee-rate?market_id={market_id}"),
+        format!("{base}/fee-rate?market={market_id}"),
+        format!("{base}/fee-rate?token_id={market_id}"),
+    ];
+
+    for url in endpoints {
+        let Ok(resp) = http.get(&url).send().await else {
+            continue;
+        };
+        let Ok(resp) = resp.error_for_status() else {
+            continue;
+        };
+        let Ok(v) = resp.json::<serde_json::Value>().await else {
+            continue;
+        };
+        let candidate = v
+            .get("fee_rate_bps")
+            .and_then(value_to_f64)
+            .or_else(|| v.get("feeRateBps").and_then(value_to_f64))
+            .or_else(|| v.get("makerFeeRateBps").and_then(value_to_f64))
+            .or_else(|| v.get("maker_fee_rate_bps").and_then(value_to_f64));
+        if candidate.is_some() {
+            return candidate;
+        }
+    }
+    None
+}
+
+pub(super) async fn pnl_after_horizon(
+    shared: &EngineShared,
+    shot: &ShadowShot,
+    horizon: Duration,
+) -> Option<f64> {
+    tokio::time::sleep(horizon).await;
+    let book = shared
+        .latest_books
+        .read()
+        .await
+        .get(&shot.market_id)
+        .cloned()?;
+    let mark = mid_for_side(&book, &shot.side);
+    if shot.intended_price <= 0.0 {
+        return None;
+    }
+    let pnl = match shot.side {
+        OrderSide::BuyYes | OrderSide::BuyNo => {
+            ((mark - shot.intended_price) / shot.intended_price) * 10_000.0
+        }
+        OrderSide::SellYes | OrderSide::SellNo => {
+            ((shot.intended_price - mark) / shot.intended_price) * 10_000.0
+        }
+    };
+    Some(pnl)
+}
+
+pub(super) fn evaluate_survival(shot: &ShadowShot, book: &BookTop) -> bool {
+    let probe_px = if shot.survival_probe_price > 0.0 {
+        shot.survival_probe_price
+    } else {
+        shot.intended_price
+    };
+    is_crossable(&shot.side, probe_px, book)
+}
+
+pub(super) fn is_crossable(side: &OrderSide, probe_px: f64, book: &BookTop) -> bool {
+    if probe_px <= 0.0 {
+        return false;
+    }
+    match side {
+        OrderSide::BuyYes => probe_px >= book.ask_yes,
+        OrderSide::SellYes => probe_px <= book.bid_yes,
+        OrderSide::BuyNo => probe_px >= book.ask_no,
+        OrderSide::SellNo => probe_px <= book.bid_no,
+    }
+}
+
+pub(super) fn evaluate_fillable(
+    shot: &ShadowShot,
+    book: &BookTop,
+    latency_ms: f64,
+) -> (bool, Option<f64>, f64) {
+    let probe_px = if shot.survival_probe_price > 0.0 {
+        shot.survival_probe_price
+    } else {
+        shot.intended_price
+    };
+    let (crossable, fill_px) = match shot.side {
+        OrderSide::BuyYes => (probe_px >= book.ask_yes, book.ask_yes),
+        OrderSide::SellYes => (probe_px <= book.bid_yes, book.bid_yes),
+        OrderSide::BuyNo => (probe_px >= book.ask_no, book.ask_no),
+        OrderSide::SellNo => (probe_px <= book.bid_no, book.bid_no),
+    };
+    if !crossable || probe_px <= 0.0 {
+        return (false, None, 0.0);
+    }
+    let queue_fill_prob = estimate_queue_fill_prob(shot, book, latency_ms);
+    if queue_fill_prob < 0.45 {
+        return (false, None, queue_fill_prob);
+    }
+    let mut slippage = match shot.side {
+        OrderSide::BuyYes | OrderSide::BuyNo => ((fill_px - probe_px) / probe_px) * 10_000.0,
+        OrderSide::SellYes | OrderSide::SellNo => ((probe_px - fill_px) / probe_px) * 10_000.0,
+    };
+    slippage += (1.0 - queue_fill_prob) * 8.0;
+    (true, Some(slippage), queue_fill_prob)
+}
+
+pub(super) fn classify_unfilled_outcome(
+    book: &BookTop,
+    latency_ms: f64,
+    delay_ms: u64,
+    survived: bool,
+    queue_fill_prob: f64,
+) -> EdgeAttribution {
+    let spread = (book.ask_yes - book.bid_yes).max(0.0);
+    if delay_ms >= 400 {
+        return EdgeAttribution::StaleQuote;
+    }
+    if !survived {
+        return EdgeAttribution::BookMoved;
+    }
+    if book.ask_yes <= 0.0 || book.bid_yes <= 0.0 {
+        return EdgeAttribution::LiquidityThin;
+    }
+    if spread > 0.05 {
+        return EdgeAttribution::SpreadTooWide;
+    }
+    if queue_fill_prob < 0.45 {
+        return EdgeAttribution::LatencyTail;
+    }
+    if latency_ms > 100.0 {
+        return EdgeAttribution::LatencyTail;
+    }
+    EdgeAttribution::BookMoved
+}
+
+pub(super) fn classify_filled_outcome(
+    edge_net_bps: f64,
+    pnl_10s_bps: Option<f64>,
+    slippage_bps: Option<f64>,
+) -> EdgeAttribution {
+    if edge_net_bps < 0.0 {
+        return EdgeAttribution::FeeOverrun;
+    }
+    if slippage_bps.unwrap_or(0.0) > edge_net_bps.abs() {
+        return EdgeAttribution::SignalLag;
+    }
+    if pnl_10s_bps.unwrap_or(0.0) < 0.0 {
+        return EdgeAttribution::AdverseSelection;
+    }
+    EdgeAttribution::Unknown
+}
+
+pub(super) fn mid_for_side(book: &BookTop, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes | OrderSide::SellYes => (book.bid_yes + book.ask_yes) * 0.5,
+        OrderSide::BuyNo | OrderSide::SellNo => (book.bid_no + book.ask_no) * 0.5,
+    }
+}
+
+pub(super) fn aggressive_price_for_side(book: &BookTop, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes => book.ask_yes,
+        OrderSide::SellYes => book.bid_yes,
+        OrderSide::BuyNo => book.ask_no,
+        OrderSide::SellNo => book.bid_no,
+    }
+}
+
+#[derive(Serialize)]
+pub(super) struct PrebuiltOrderPayload<'a> {
+    market_id: &'a str,
+    token_id: Option<&'a str>,
+    side: &'a str,
+    price: f64,
+    size: f64,
+    ttl_ms: u64,
+    style: &'a str,
+    tif: &'a str,
+    max_slippage_bps: f64,
+    fee_rate_bps: f64,
+    expected_edge_net_bps: f64,
+    hold_to_resolution: bool,
+}
+
+pub(super) fn prebuild_order_payload(intent: &OrderIntentV2) -> Option<Vec<u8>> {
+    let side = intent.side.to_string();
+    let style = intent.style.to_string();
+    let tif = intent.tif.to_string();
+    let payload = PrebuiltOrderPayload {
+        market_id: intent.market_id.as_str(),
+        token_id: intent.token_id.as_deref(),
+        side: side.as_str(),
+        price: intent.price,
+        size: intent.size,
+        ttl_ms: intent.ttl_ms,
+        style: style.as_str(),
+        tif: tif.as_str(),
+        max_slippage_bps: intent.max_slippage_bps,
+        fee_rate_bps: intent.fee_rate_bps,
+        expected_edge_net_bps: intent.expected_edge_net_bps,
+        hold_to_resolution: intent.hold_to_resolution,
+    };
+    serde_json::to_vec(&payload).ok()
+}
+
+pub(super) fn spread_for_side(book: &BookTop, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes | OrderSide::SellYes => (book.ask_yes - book.bid_yes).max(0.0),
+        OrderSide::BuyNo | OrderSide::SellNo => (book.ask_no - book.bid_no).max(0.0),
+    }
+}
+
+pub(super) fn fair_for_side(fair_yes: f64, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes | OrderSide::SellYes => fair_yes,
+        OrderSide::BuyNo | OrderSide::SellNo => (1.0 - fair_yes).clamp(0.001, 0.999),
+    }
+}
+
+pub(super) fn edge_gross_bps_for_side(fair_yes: f64, side: &OrderSide, entry_price: f64) -> f64 {
+    let fair = fair_for_side(fair_yes, side);
+    let px = entry_price.max(1e-6);
+    match side {
+        OrderSide::BuyYes | OrderSide::BuyNo => ((fair - px) / px) * 10_000.0,
+        OrderSide::SellYes | OrderSide::SellNo => ((px - fair) / px) * 10_000.0,
+    }
+}
+
+pub(super) fn edge_for_intent(fair_yes: f64, intent: &QuoteIntent) -> f64 {
+    let px = intent.price.max(1e-6);
+    let fair = match intent.side {
+        OrderSide::BuyYes | OrderSide::SellYes => fair_yes,
+        OrderSide::BuyNo | OrderSide::SellNo => (1.0 - fair_yes).clamp(0.001, 0.999),
+    };
+    match intent.side {
+        // Expected edge vs. intended entry price in bps of entry.
+        OrderSide::BuyYes | OrderSide::BuyNo => ((fair - px) / px) * 10_000.0,
+        OrderSide::SellYes | OrderSide::SellNo => ((px - fair) / px) * 10_000.0,
+    }
+}
diff --git a/crates/app_runner/src/feed_runtime.rs b/crates/app_runner/src/feed_runtime.rs
new file mode 100644
index 0000000..96b4d18
--- /dev/null
+++ b/crates/app_runner/src/feed_runtime.rs
@@ -0,0 +1,899 @@
+use std::collections::HashMap;
+use std::sync::Arc;
+use std::time::{Duration, Instant};
+
+use anyhow::Result;
+use chrono::Utc;
+use core_types::{EngineEvent, MarketFeed, RefPriceFeed, RefTick, SourceHealth};
+use feed_polymarket::PolymarketFeed;
+use feed_reference::MultiSourceRefFeed;
+use futures::StreamExt;
+use infra_bus::RingBus;
+use smol_str::SmolStr;
+use tokio::sync::{mpsc, RwLock};
+
+use crate::fusion_engine::{
+    is_anchor_ref_source, is_ref_tick_duplicate, max_book_top_diff_bps, ref_event_ts_ms,
+    should_arm_ws_primary_fallback, should_enforce_udp_share_cap, should_log_ref_tick,
+    should_replace_anchor_tick, should_replace_ref_tick, udp_downweight_keep_every,
+    udp_min_freshness_score, upsert_latest_tick_slot, ws_primary_fallback_gap_ns,
+};
+use crate::report_io::{append_jsonl_line, dataset_path, sha256_hex};
+use crate::state::{EngineShared, FusionConfig, ShadowStats, SourceHealthConfig, StrategyIngress, StrategyIngressMsg};
+use crate::stats_utils::{now_ns, value_to_f64};
+use crate::{publish_if_telemetry_subscribers, spawn_detached};
+
+pub(super) fn spawn_reference_feed(
+    bus: RingBus<EngineEvent>,
+    stats: Arc<ShadowStats>,
+    symbols: Vec<String>,
+    fusion_cfg: Arc<RwLock<FusionConfig>>,
+    shared: Arc<EngineShared>,
+    strategy_tx: mpsc::Sender<StrategyIngressMsg>,
+) {
+    #[derive(Clone, Copy)]
+    enum RefLane {
+        Direct,
+        Udp,
+    }
+    const TS_INVERSION_TOLERANCE_MS: i64 = 250;
+    const TS_BACKJUMP_RESET_MS: i64 = 5_000;
+    spawn_detached("reference_feed_orchestrator", true, async move {
+        let symbols = if symbols.is_empty() {
+            vec!["BTCUSDT".to_string()]
+        } else {
+            symbols
+        };
+        let ref_merge_queue_cap = std::env::var("POLYEDGE_REF_MERGE_QUEUE_CAP")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(4_096)
+            .clamp(1_024, 32_768);
+        let ref_merge_drop_on_full = std::env::var("POLYEDGE_REF_MERGE_DROP_ON_FULL")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(true);
+        let strategy_ingress_drop_on_full = std::env::var("POLYEDGE_STRATEGY_INGRESS_DROP_ON_FULL")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(true);
+        let strategy_ref_ingress_enabled = std::env::var("POLYEDGE_STRATEGY_REF_INGRESS_ENABLED")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(false);
+        let (tx, mut rx) = mpsc::channel::<(RefLane, Result<RefTick>)>(ref_merge_queue_cap);
+
+        let tx_direct = tx.clone();
+        let symbols_direct = symbols.clone();
+        spawn_detached("reference_feed_direct_lane", true, async move {
+            loop {
+                let feed = MultiSourceRefFeed::new(Duration::from_millis(50));
+                match feed.stream_ticks(symbols_direct.clone()).await {
+                    Ok(mut stream) => {
+                        while let Some(item) = stream.next().await {
+                            let lane_item = (RefLane::Direct, item);
+                            if ref_merge_drop_on_full {
+                                match tx_direct.try_send(lane_item) {
+                                    Ok(()) => {}
+                                    Err(mpsc::error::TrySendError::Full(_)) => {
+                                        metrics::counter!("fusion.ref_merge_drop").increment(1);
+                                    }
+                                    Err(mpsc::error::TrySendError::Closed(_)) => return,
+                                }
+                            } else if tx_direct.send(lane_item).await.is_err() {
+                                return;
+                            }
+                        }
+                    }
+                    Err(err) => tracing::warn!(?err, "direct reference feed failed to start"),
+                }
+                tokio::time::sleep(Duration::from_millis(500)).await;
+            }
+        });
+
+        let tx_udp = tx.clone();
+        let symbols_udp = symbols.clone();
+        let fusion_cfg_udp = fusion_cfg.clone();
+        spawn_detached("reference_feed_udp_lane", true, async move {
+            loop {
+                let cfg = fusion_cfg_udp.read().await.clone();
+                if !cfg.enable_udp || cfg.mode == "direct_only" {
+                    tokio::time::sleep(Duration::from_millis(500)).await;
+                    continue;
+                }
+                let feed = feed_udp::UdpBinanceFeed::new(cfg.udp_port);
+                match feed.stream_ticks(symbols_udp.clone()).await {
+                    Ok(mut stream) => {
+                        while let Some(item) = stream.next().await {
+                            let lane_item = (RefLane::Udp, item);
+                            if ref_merge_drop_on_full {
+                                match tx_udp.try_send(lane_item) {
+                                    Ok(()) => {}
+                                    Err(mpsc::error::TrySendError::Full(_)) => {
+                                        metrics::counter!("fusion.ref_merge_drop").increment(1);
+                                    }
+                                    Err(mpsc::error::TrySendError::Closed(_)) => return,
+                                }
+                            } else if tx_udp.send(lane_item).await.is_err() {
+                                return;
+                            }
+                        }
+                    }
+                    Err(err) => tracing::warn!(?err, "udp reference feed failed to start"),
+                }
+                tokio::time::sleep(Duration::from_millis(250)).await;
+            }
+        });
+        drop(tx);
+
+        let mut ingest_seq: u64 = 0;
+        let mut last_source_ts_by_stream: HashMap<String, i64> = HashMap::new();
+        let mut last_published_by_symbol: HashMap<String, (i64, f64)> = HashMap::new();
+        let mut source_runtime: HashMap<SmolStr, SourceRuntimeStats> = HashMap::new();
+        let mut latest_price_by_symbol_source: HashMap<String, HashMap<SmolStr, f64>> =
+            HashMap::new();
+        let mut latest_ws_recv_ns_global: i64 = 0;
+        let mut ws_primary_fallback_until_ns: i64 = 0;
+        let mut ws_primary_ready_seen = false;
+        let mut ws_cap_breach_started_ns: i64 = 0;
+        let mut accepted_fast_mix_by_symbol: HashMap<String, (u64, u64)> = HashMap::new();
+        let mut accepted_fast_mix_total: (u64, u64) = (0, 0);
+        let mut fusion = fusion_cfg.read().await.clone();
+        let mut last_fusion_mode = fusion.mode.clone();
+        let fusion_cfg_refresh_interval_ms = std::env::var("POLYEDGE_FUSION_CFG_REFRESH_MS")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(200)
+            .clamp(50, 2_000);
+        let mut fusion_cfg_refresh_at = Instant::now();
+        let mut source_health_cfg = shared.source_health_cfg.read().await.clone();
+        let mut source_health_cfg_refresh_at = Instant::now();
+        let ref_tick_bus_enabled = std::env::var("POLYEDGE_REF_TICK_BUS_ENABLED")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(false);
+
+        while let Some((lane, item)) = rx.recv().await {
+            match item {
+                Ok(tick) => {
+                    if fusion_cfg_refresh_at.elapsed()
+                        >= Duration::from_millis(fusion_cfg_refresh_interval_ms)
+                    {
+                        let next_fusion = fusion_cfg.read().await.clone();
+                        if next_fusion.mode != last_fusion_mode {
+                            accepted_fast_mix_by_symbol.clear();
+                            accepted_fast_mix_total = (0, 0);
+                            ws_primary_ready_seen = false;
+                            ws_primary_fallback_until_ns = 0;
+                            ws_cap_breach_started_ns = 0;
+                            stats.record_issue("fusion_mode_switch_fast_cache_reset").await;
+                            last_fusion_mode = next_fusion.mode.clone();
+                        }
+                        fusion = next_fusion;
+                        fusion_cfg_refresh_at = Instant::now();
+                    }
+                    let is_anchor = is_anchor_ref_source(tick.source.as_str());
+                    if fusion.mode == "udp_only" && !matches!(lane, RefLane::Udp) && !is_anchor {
+                        continue;
+                    }
+                    if fusion.mode == "direct_only"
+                        && !matches!(lane, RefLane::Direct)
+                        && !is_anchor
+                    {
+                        continue;
+                    }
+                    ingest_seq = ingest_seq.saturating_add(1);
+                    let source_ts = tick.event_ts_exchange_ms.max(tick.event_ts_ms);
+                    let source_seq = source_ts.max(0) as u64;
+                    let valid = !tick.symbol.is_empty()
+                        && tick.price.is_finite()
+                        && tick.price > 0.0
+                        && source_seq > 0;
+                    stats.mark_data_validity(valid);
+                    let stream_key = format!("{}:{}", tick.source, tick.symbol);
+                    if let Some(prev) = last_source_ts_by_stream.get(&stream_key).copied() {
+                        if source_ts + TS_INVERSION_TOLERANCE_MS < prev {
+                            let back_jump_ms = prev.saturating_sub(source_ts);
+                            if back_jump_ms > TS_BACKJUMP_RESET_MS {
+                                stats.record_issue("ref_ts_backjump_reset").await;
+                            } else {
+                                stats.mark_ts_inversion();
+                            }
+                        }
+                    }
+                    last_source_ts_by_stream.insert(stream_key, source_ts);
+                    if let Some((prev_ts, prev_px)) = last_published_by_symbol.get(&tick.symbol) {
+                        if is_ref_tick_duplicate(source_ts, tick.price, *prev_ts, *prev_px, &fusion)
+                        {
+                            stats.mark_ref_dedupe_dropped();
+                            continue;
+                        }
+                    }
+                    last_published_by_symbol.insert(tick.symbol.clone(), (source_ts, tick.price));
+                    if source_health_cfg_refresh_at.elapsed() >= Duration::from_millis(500) {
+                        source_health_cfg = shared.source_health_cfg.read().await.clone();
+                        source_health_cfg_refresh_at = Instant::now();
+                    }
+                    let source_key = tick.source.clone();
+                    let symbol_key = tick.symbol.clone();
+                    let recv_ts_ms = tick.recv_ts_ms;
+                    if source_key == "binance_ws" {
+                        let recv_ns = if tick.recv_ts_local_ns > 0 {
+                            tick.recv_ts_local_ns
+                        } else {
+                            now_ns()
+                        };
+                        latest_ws_recv_ns_global = latest_ws_recv_ns_global.max(recv_ns);
+                    }
+                    let latency_ms = recv_ts_ms.saturating_sub(source_ts).max(0) as f64;
+                    let runtime = source_runtime.entry(source_key.clone()).or_default();
+                    runtime.sample_count = runtime.sample_count.saturating_add(1);
+                    runtime.latency_sum_ms += latency_ms;
+                    runtime.latency_sq_sum_ms += latency_ms * latency_ms;
+                    if runtime.last_event_ts_ms > 0
+                        && source_ts + TS_INVERSION_TOLERANCE_MS < runtime.last_event_ts_ms
+                    {
+                        runtime.out_of_order_count = runtime.out_of_order_count.saturating_add(1);
+                    }
+                    if runtime.last_recv_ts_ms > 0
+                        && recv_ts_ms.saturating_sub(runtime.last_recv_ts_ms)
+                            > source_health_cfg.gap_window_ms
+                    {
+                        runtime.gap_count = runtime.gap_count.saturating_add(1);
+                    }
+                    runtime.last_event_ts_ms = source_ts;
+                    runtime.last_recv_ts_ms = recv_ts_ms;
+
+                    {
+                        let per_symbol = latest_price_by_symbol_source
+                            .entry(symbol_key.clone())
+                            .or_default();
+                        per_symbol.insert(source_key.clone(), tick.price);
+                        if per_symbol.len() >= 2 {
+                            let values = per_symbol.values().copied().collect::<Vec<_>>();
+                            if let Some(median) = median_price(&values) {
+                                if median.is_finite() && median > 0.0 {
+                                    let dev_bps = ((tick.price - median).abs() / median * 10_000.0)
+                                        .clamp(0.0, 10_000.0);
+                                    if runtime.sample_count <= 1 {
+                                        runtime.deviation_ema_bps = dev_bps;
+                                    } else {
+                                        runtime.deviation_ema_bps =
+                                            (runtime.deviation_ema_bps * 0.90) + (dev_bps * 0.10);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    let source_health = build_source_health_snapshot(
+                        source_key.as_str(),
+                        runtime,
+                        &source_health_cfg,
+                        Utc::now().timestamp_millis(),
+                    );
+                    if runtime.sample_count % 8 == 0 {
+                        let mut map = shared.source_health_latest.write().await;
+                        map.insert(source_key.to_string(), source_health.clone());
+                    }
+                    if tick.source == "binance_udp" {
+                        let (udp_samples, ws_samples) = accepted_fast_mix_total;
+                        let fast_total = udp_samples.saturating_add(ws_samples);
+                        let udp_share = if fast_total > 0 {
+                            udp_samples as f64 / fast_total as f64
+                        } else {
+                            0.0
+                        };
+                        let (sym_udp_samples, sym_ws_samples) = accepted_fast_mix_by_symbol
+                            .get(tick.symbol.as_str())
+                            .copied()
+                            .unwrap_or((0, 0));
+                        let sym_fast_total = sym_udp_samples.saturating_add(sym_ws_samples);
+                        let udp_share_symbol = if sym_fast_total > 0 {
+                            sym_udp_samples as f64 / sym_fast_total as f64
+                        } else {
+                            udp_share
+                        };
+                        let effective_udp_share = if sym_fast_total >= 32 {
+                            udp_share_symbol
+                        } else {
+                            udp_share
+                        };
+                        let jitter_high =
+                            source_health.jitter_ms > fusion.jitter_threshold_ms.max(1.0);
+                        let freshness_low =
+                            source_health.freshness_score < udp_min_freshness_score();
+                        let now_recv_ns = if tick.recv_ts_local_ns > 0 {
+                            tick.recv_ts_local_ns
+                        } else {
+                            now_ns()
+                        };
+                        let ws_gap_ns = if latest_ws_recv_ns_global > 0 {
+                            now_recv_ns.saturating_sub(latest_ws_recv_ns_global)
+                        } else {
+                            i64::MAX
+                        };
+                        let ws_cap_ready = ws_gap_ns <= ws_primary_fallback_gap_ns();
+                        if ws_cap_ready {
+                            ws_primary_ready_seen = true;
+                            ws_cap_breach_started_ns = 0;
+                        } else if ws_primary_ready_seen && ws_cap_breach_started_ns == 0 {
+                            ws_cap_breach_started_ns = now_recv_ns;
+                        }
+                        let ws_breach_persisted = ws_cap_breach_started_ns > 0
+                            && now_recv_ns.saturating_sub(ws_cap_breach_started_ns)
+                                >= (fusion.fallback_arm_duration_ms as i64)
+                                    .saturating_mul(1_000_000);
+                        let fallback_active_now = fusion.mode == "websocket_primary"
+                            && now_recv_ns < ws_primary_fallback_until_ns;
+                        if should_arm_ws_primary_fallback(
+                            fusion.mode.as_str(),
+                            ws_cap_ready,
+                            ws_breach_persisted,
+                            fallback_active_now,
+                        ) {
+                            let cooldown_ns =
+                                (fusion.fallback_cooldown_sec as i64).saturating_mul(1_000_000_000);
+                            ws_primary_fallback_until_ns =
+                                now_recv_ns.saturating_add(cooldown_ns.max(0));
+                            metrics::counter!("fusion.ws_primary_fallback_arm").increment(1);
+                            stats.mark_fallback_trigger_reason("ws_gap_persisted").await;
+                        }
+
+                        let fallback_active = fusion.mode == "websocket_primary"
+                            && now_recv_ns < ws_primary_fallback_until_ns;
+                        if fallback_active {
+                            metrics::counter!("fusion.ws_primary_fallback_active").increment(1);
+                        }
+                        let fallback_state = if fallback_active {
+                            if ws_cap_ready {
+                                "cooldown"
+                            } else {
+                                "udp_fallback"
+                            }
+                        } else if ws_cap_breach_started_ns > 0 {
+                            "armed"
+                        } else {
+                            "ws_primary"
+                        };
+                        stats.set_fallback_state(fallback_state);
+
+                        let target_share = fusion.udp_share_cap.clamp(0.05, 0.95);
+                        let projected_udp_share = if fast_total > 0 {
+                            (udp_samples.saturating_add(1) as f64)
+                                / (fast_total.saturating_add(1) as f64)
+                        } else {
+                            1.0
+                        };
+                        let projected_share_violation = projected_udp_share > target_share;
+                        // In websocket_primary / active_active we hard-enforce the UDP share cap
+                        // outside explicit fallback windows. If WS is unhealthy, fallback state
+                        // should arm and take over; until then we still constrain UDP dominance.
+                        let enforce_ws_primary = should_enforce_udp_share_cap(
+                            fusion.mode.as_str(),
+                            fallback_active,
+                            projected_share_violation,
+                        );
+
+                        if enforce_ws_primary {
+                            metrics::counter!("fusion.udp_downweight_drop").increment(1);
+                            metrics::counter!("fusion.udp_share_cap_drop").increment(1);
+                            stats.mark_share_cap_drop();
+                            continue;
+                        }
+
+                        if ws_cap_ready && (jitter_high || freshness_low) {
+                            let share_ratio = (effective_udp_share / target_share).max(1.0);
+                            let base_keep_every = udp_downweight_keep_every().max(2);
+                            let dynamic_keep = share_ratio.ceil() as usize;
+                            let jitter_boost = if jitter_high { 2 } else { 1 };
+                            let freshness_boost = if freshness_low { 2 } else { 1 };
+                            let keep_every = base_keep_every
+                                .max(dynamic_keep)
+                                .max(base_keep_every.saturating_mul(jitter_boost))
+                                .max(base_keep_every.saturating_mul(freshness_boost))
+                                .clamp(2, 16);
+                            if (ingest_seq % keep_every as u64) != 0 {
+                                metrics::counter!("fusion.udp_downweight_drop").increment(1);
+                                if jitter_high {
+                                    metrics::counter!("fusion.udp_jitter_drop").increment(1);
+                                }
+                                if freshness_low {
+                                    metrics::counter!("fusion.udp_freshness_drop").increment(1);
+                                }
+                                continue;
+                            }
+                        }
+                    }
+                    if should_log_ref_tick(ingest_seq) {
+                        let tick_json =
+                            serde_json::to_string(&tick).unwrap_or_else(|_| "{}".to_string());
+                        let line = format!(
+                            "{{\"ts_ms\":{},\"source_seq\":{},\"ingest_seq\":{},\"valid\":{},\"tick\":{}}}",
+                            Utc::now().timestamp_millis(),
+                            source_seq,
+                            ingest_seq,
+                            valid,
+                            tick_json
+                        );
+                        append_jsonl_line(&dataset_path("raw", "ref_ticks.jsonl"), line);
+                    }
+                    if !valid {
+                        stats.record_issue("invalid_ref_tick").await;
+                        continue;
+                    }
+                    stats.mark_ref_tick(tick.source.as_str(), tick.recv_ts_ms);
+                    if source_key == "binance_udp" || source_key == "binance_ws" {
+                        let entry = accepted_fast_mix_by_symbol
+                            .entry(symbol_key.clone())
+                            .or_default();
+                        if source_key == "binance_udp" {
+                            entry.0 = entry.0.saturating_add(1);
+                            accepted_fast_mix_total.0 = accepted_fast_mix_total.0.saturating_add(1);
+                        } else {
+                            entry.1 = entry.1.saturating_add(1);
+                            accepted_fast_mix_total.1 = accepted_fast_mix_total.1.saturating_add(1);
+                        }
+                        let total = entry.0.saturating_add(entry.1);
+                        if total > 100_000 {
+                            entry.0 /= 2;
+                            entry.1 /= 2;
+                        }
+                        let total_global = accepted_fast_mix_total
+                            .0
+                            .saturating_add(accepted_fast_mix_total.1);
+                        if total_global > 1_000_000 {
+                            accepted_fast_mix_total.0 /= 2;
+                            accepted_fast_mix_total.1 /= 2;
+                        }
+                    }
+
+                    if is_anchor {
+                        let _ = upsert_latest_tick_slot(
+                            &shared.latest_anchor_ticks,
+                            tick.clone(),
+                            should_replace_anchor_tick,
+                        );
+                    } else if let Some(delta_ns) = upsert_latest_tick_slot(
+                        &shared.latest_fast_ticks,
+                        tick.clone(),
+                        should_replace_ref_tick,
+                    ) {
+                        metrics::histogram!("fusion.arrive_delta_ns").record(delta_ns as f64);
+                    }
+
+                    if strategy_ref_ingress_enabled {
+                        let ingress = StrategyIngressMsg {
+                            enqueued_ns: now_ns(),
+                            payload: StrategyIngress::RefTick(tick.clone()),
+                        };
+                        if strategy_ingress_drop_on_full {
+                            match strategy_tx.try_send(ingress) {
+                                Ok(()) => {}
+                                Err(mpsc::error::TrySendError::Full(_)) => {
+                                    metrics::counter!("strategy.ingress_ref_drop").increment(1);
+                                }
+                                Err(mpsc::error::TrySendError::Closed(_)) => break,
+                            }
+                        } else if strategy_tx.send(ingress).await.is_err() {
+                            break;
+                        }
+                    }
+
+                    if ref_tick_bus_enabled {
+                        publish_if_telemetry_subscribers(&bus, EngineEvent::RefTick(tick));
+                    }
+                }
+                Err(err) => {
+                    tracing::warn!(?err, "reference feed event error");
+                }
+            }
+        }
+    });
+}
+
+pub(super) fn spawn_settlement_feed(shared: Arc<EngineShared>) {
+    spawn_detached("settlement_feed_orchestrator", true, async move {
+        loop {
+            let cfg = shared.settlement_cfg.read().await.clone();
+            if !cfg.enabled || cfg.endpoint.trim().is_empty() {
+                tokio::time::sleep(Duration::from_millis(1_000)).await;
+                continue;
+            }
+
+            let req = shared
+                .http
+                .get(cfg.endpoint.clone())
+                .timeout(Duration::from_millis(cfg.timeout_ms.max(100)));
+            match req.send().await {
+                Ok(resp) => match resp.json::<serde_json::Value>().await {
+                    Ok(value) => {
+                        let mut updates = HashMap::<String, f64>::new();
+                        let maybe_object = value.as_object();
+                        if let Some(obj) = maybe_object {
+                            for symbol in &cfg.symbols {
+                                for key in settlement_symbol_keys(symbol) {
+                                    if let Some(price) = obj.get(&key).and_then(value_to_f64) {
+                                        if price.is_finite() && price > 0.0 {
+                                            updates.insert(symbol.clone(), price);
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        if !updates.is_empty() {
+                            let mut map = shared.settlement_prices.write().await;
+                            for (k, v) in updates {
+                                map.insert(k, v);
+                            }
+                        }
+                    }
+                    Err(err) => {
+                        tracing::warn!(?err, "settlement feed json decode failed");
+                        metrics::counter!("settlement.feed.decode_error").increment(1);
+                    }
+                },
+                Err(err) => {
+                    tracing::warn!(?err, "settlement feed poll failed");
+                    metrics::counter!("settlement.feed.poll_error").increment(1);
+                }
+            }
+
+            tokio::time::sleep(Duration::from_millis(cfg.poll_interval_ms.max(250))).await;
+        }
+    });
+}
+
+pub(super) fn settlement_symbol_keys(symbol: &str) -> Vec<String> {
+    let mut keys = Vec::with_capacity(4);
+    let normalized = symbol.trim().to_ascii_uppercase();
+    keys.push(normalized.clone());
+    if let Some(base) = normalized.strip_suffix("USDT") {
+        keys.push(base.to_string());
+        keys.push(format!("{base}USD"));
+    }
+    keys.push(normalized.replace('_', ""));
+    keys
+}
+
+pub(super) async fn settlement_prob_yes_for_symbol(
+    shared: &Arc<EngineShared>,
+    symbol: &str,
+    p_fast_yes: f64,
+    now_ms: i64,
+) -> Option<f64> {
+    let settle_price = {
+        let anchor = shared
+            .latest_anchor_ticks
+            .get(symbol)
+            .map(|tick| tick.value().clone())
+            .filter(|tick| {
+                is_anchor_ref_source(tick.source.as_str())
+                    && now_ms.saturating_sub(ref_event_ts_ms(tick)) <= 5_000
+            })
+            .map(|tick| tick.price);
+        if let Some(v) = anchor {
+            Some(v)
+        } else {
+            shared.settlement_prices.read().await.get(symbol).copied()
+        }
+    }?;
+    if settle_price <= 0.0 {
+        return None;
+    }
+    let fast_price = shared.latest_fast_ticks.get(symbol).map(|t| t.price)?;
+    if fast_price <= 0.0 {
+        return None;
+    }
+    Some(blend_settlement_probability(
+        p_fast_yes,
+        fast_price,
+        settle_price,
+    ))
+}
+
+#[inline]
+pub(super) fn blend_settlement_probability(
+    p_fast_yes: f64,
+    fast_price: f64,
+    settle_price: f64,
+) -> f64 {
+    // When fast and settlement feeds diverge, pull probability toward 0.5.
+    // This keeps execution conservative until settlement alignment recovers.
+    let gap = ((fast_price - settle_price) / settle_price)
+        .abs()
+        .clamp(0.0, 0.03);
+    let settle_blend = (gap * 20.0).clamp(0.0, 0.25);
+    let p = (p_fast_yes.clamp(0.0, 1.0) * (1.0 - settle_blend)) + (0.5 * settle_blend);
+    p.clamp(0.0, 1.0)
+}
+
+#[derive(Debug, Default, Clone)]
+pub(super) struct SourceRuntimeStats {
+    pub(super) sample_count: u64,
+    pub(super) latency_sum_ms: f64,
+    pub(super) latency_sq_sum_ms: f64,
+    pub(super) out_of_order_count: u64,
+    pub(super) gap_count: u64,
+    pub(super) last_event_ts_ms: i64,
+    pub(super) last_recv_ts_ms: i64,
+    pub(super) deviation_ema_bps: f64,
+}
+
+pub(super) fn median_price(values: &[f64]) -> Option<f64> {
+    if values.is_empty() {
+        return None;
+    }
+    let mut sorted = values.to_vec();
+    sorted.sort_by(|a, b| a.total_cmp(b));
+    let mid = sorted.len() / 2;
+    Some(if sorted.len() % 2 == 0 {
+        (sorted[mid - 1] + sorted[mid]) * 0.5
+    } else {
+        sorted[mid]
+    })
+}
+
+pub(super) fn build_source_health_snapshot(
+    source: &str,
+    stats: &SourceRuntimeStats,
+    cfg: &SourceHealthConfig,
+    now_ms: i64,
+) -> SourceHealth {
+    let n = stats.sample_count.max(1) as f64;
+    let latency_ms = (stats.latency_sum_ms / n).max(0.0);
+    let variance = (stats.latency_sq_sum_ms / n) - (latency_ms * latency_ms);
+    let jitter_ms = variance.max(0.0).sqrt();
+    let out_of_order_rate = (stats.out_of_order_count as f64 / n).clamp(0.0, 1.0);
+    let gap_rate = (stats.gap_count as f64 / n).clamp(0.0, 1.0);
+    let price_deviation_bps = stats.deviation_ema_bps.max(0.0);
+    let freshness_age_ms = if stats.last_recv_ts_ms > 0 {
+        now_ms.saturating_sub(stats.last_recv_ts_ms).max(0) as f64
+    } else {
+        cfg.freshness_limit_ms * 4.0
+    };
+    let freshness_penalty = (freshness_age_ms / cfg.freshness_limit_ms.max(1e-6)).clamp(0.0, 2.0);
+    let freshness_score = (1.0 - freshness_penalty * 0.5).clamp(0.0, 1.0);
+
+    let jitter_penalty = (jitter_ms / cfg.jitter_limit_ms.max(1e-6)).clamp(0.0, 2.0);
+    let deviation_penalty =
+        (price_deviation_bps / cfg.deviation_limit_bps.max(1e-6)).clamp(0.0, 2.0);
+    let out_of_order_penalty = (out_of_order_rate / 0.02).clamp(0.0, 2.0);
+    let gap_penalty = (gap_rate / 0.02).clamp(0.0, 2.0);
+    let coverage = (stats.sample_count as f64 / cfg.min_samples.max(1) as f64).clamp(0.0, 1.0);
+    let raw_score = 1.0
+        - (0.30 * jitter_penalty)
+        - (0.25 * deviation_penalty)
+        - (0.18 * out_of_order_penalty)
+        - (0.12 * gap_penalty)
+        - (0.15 * freshness_penalty);
+    let score = (raw_score.clamp(0.0, 1.0) * (0.25 + 0.75 * coverage)).clamp(0.0, 1.0);
+
+    SourceHealth {
+        source: source.to_string(),
+        latency_ms,
+        jitter_ms,
+        out_of_order_rate,
+        gap_rate,
+        price_deviation_bps,
+        freshness_score,
+        score,
+        sample_count: stats.sample_count,
+        ts_ms: now_ms,
+    }
+}
+
+pub(super) fn spawn_market_feed(
+    bus: RingBus<EngineEvent>,
+    stats: Arc<ShadowStats>,
+    symbols: Vec<String>,
+    market_types: Vec<String>,
+    timeframes: Vec<String>,
+    strategy_tx: mpsc::Sender<StrategyIngressMsg>,
+) {
+    const TS_INVERSION_TOLERANCE_MS: i64 = 250;
+    const TS_BACKJUMP_RESET_MS: i64 = 5_000;
+    // If we see *no* market messages for this long, treat the WS stream as stuck and reconnect.
+    // Keep this comfortably above "normal quiet" to avoid hammering gamma discovery on reconnection.
+    // 5s is too aggressive for quiet windows and creates reconnect churn.
+    // Keep stale protection, but allow a calmer idle window to reduce needless reconnects.
+    const BOOK_IDLE_TIMEOUT_MS: u64 = 20_000;
+    const RECONNECT_BASE_MS: u64 = 250;
+    const RECONNECT_MAX_MS: u64 = 10_000;
+    spawn_detached("market_feed_orchestrator", true, async move {
+        let strategy_ingress_drop_on_full = std::env::var("POLYEDGE_STRATEGY_INGRESS_DROP_ON_FULL")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(true);
+        let strategy_book_dedupe_window_ms =
+            std::env::var("POLYEDGE_BOOK_INGRESS_DEDUPE_WINDOW_MS")
+                .ok()
+                .and_then(|v| v.parse::<i64>().ok())
+                .unwrap_or(25)
+                .clamp(0, 500);
+        let strategy_book_dedupe_bps = std::env::var("POLYEDGE_BOOK_INGRESS_DEDUPE_BPS")
+            .ok()
+            .and_then(|v| v.parse::<f64>().ok())
+            .unwrap_or(0.05)
+            .clamp(0.0, 5.0);
+        let mut reconnects: u64 = 0;
+        loop {
+            let feed = PolymarketFeed::new_with_universe(
+                Duration::from_millis(50),
+                symbols.clone(),
+                market_types.clone(),
+                timeframes.clone(),
+            );
+            let Ok(mut stream) = feed.stream_books().await else {
+                reconnects = reconnects.saturating_add(1);
+                let backoff_ms =
+                    (RECONNECT_BASE_MS.saturating_mul(reconnects.min(40))).min(RECONNECT_MAX_MS);
+                tracing::warn!(
+                    reconnects,
+                    backoff_ms,
+                    "market feed failed to start; reconnecting"
+                );
+                tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
+                continue;
+            };
+            let mut ingest_seq: u64 = 0;
+            let mut last_source_ts_by_market: HashMap<String, i64> = HashMap::new();
+            let mut last_enqueued_book_by_market: HashMap<String, (i64, f64, f64, f64, f64)> =
+                HashMap::new();
+            // Only reset reconnect backoff once we observe actual book traffic (not just a successful
+            // handshake). This avoids a reconnect storm when discovery/WS is returning 200 but no
+            // updates are delivered.
+            let mut saw_any_book = false;
+
+            loop {
+                let next = tokio::time::timeout(
+                    Duration::from_millis(BOOK_IDLE_TIMEOUT_MS),
+                    stream.next(),
+                )
+                .await;
+                let item = match next {
+                    Ok(v) => v,
+                    Err(_) => {
+                        tracing::warn!(
+                            timeout_ms = BOOK_IDLE_TIMEOUT_MS,
+                            saw_any_book,
+                            reconnects,
+                            "market feed idle timeout; reconnecting"
+                        );
+                        break;
+                    }
+                };
+
+                let Some(item) = item else {
+                    tracing::warn!("market feed stream ended; reconnecting");
+                    break;
+                };
+
+                match item {
+                    Ok(book) => {
+                        if !saw_any_book {
+                            saw_any_book = true;
+                            if reconnects > 0 {
+                                tracing::info!(reconnects, "market feed reconnected");
+                            }
+                            reconnects = 0;
+                        }
+                        ingest_seq = ingest_seq.saturating_add(1);
+                        let source_ts = book.ts_ms;
+                        let source_seq = source_ts.max(0) as u64;
+                        let valid = !book.market_id.is_empty()
+                            && book.bid_yes.is_finite()
+                            && book.ask_yes.is_finite()
+                            && book.bid_no.is_finite()
+                            && book.ask_no.is_finite()
+                            && source_seq > 0;
+                        stats.mark_data_validity(valid);
+                        if let Some(prev) = last_source_ts_by_market.get(&book.market_id).copied() {
+                            if source_ts + TS_INVERSION_TOLERANCE_MS < prev {
+                                let back_jump_ms = prev.saturating_sub(source_ts);
+                                if back_jump_ms > TS_BACKJUMP_RESET_MS {
+                                    stats.record_issue("book_ts_backjump_reset").await;
+                                } else {
+                                    stats.mark_ts_inversion();
+                                }
+                            }
+                        }
+                        last_source_ts_by_market.insert(book.market_id.clone(), source_ts);
+                        // IMPORTANT: book freshness must be based on *local* receive time, not the
+                        // exchange/server-provided ts_ms (which can be skewed/backjump).
+                        let book_tick_ms = if book.recv_ts_local_ns > 0 {
+                            (book.recv_ts_local_ns / 1_000_000).max(0)
+                        } else {
+                            Utc::now().timestamp_millis()
+                        };
+                        stats.mark_book_tick(book_tick_ms);
+                        let book_json =
+                            serde_json::to_string(&book).unwrap_or_else(|_| "{}".to_string());
+                        let hash = sha256_hex(&book_json);
+                        let line = format!(
+                            "{{\"ts_ms\":{},\"source_seq\":{},\"ingest_seq\":{},\"valid\":{},\"sha256\":\"{}\",\"book\":{}}}",
+                            Utc::now().timestamp_millis(),
+                            source_seq,
+                            ingest_seq,
+                            valid,
+                            hash,
+                            book_json
+                        );
+                        append_jsonl_line(&dataset_path("raw", "book_tops.jsonl"), line);
+                        if !valid {
+                            stats.record_issue("invalid_book_top").await;
+                            continue;
+                        }
+
+                        if strategy_book_dedupe_window_ms > 0 {
+                            let book_recv_ms = if book.recv_ts_local_ns > 0 {
+                                (book.recv_ts_local_ns / 1_000_000).max(0)
+                            } else {
+                                Utc::now().timestamp_millis()
+                            };
+                            if let Some((
+                                prev_recv_ms,
+                                prev_bid_yes,
+                                prev_ask_yes,
+                                prev_bid_no,
+                                prev_ask_no,
+                            )) = last_enqueued_book_by_market.get(&book.market_id)
+                            {
+                                let within_window = (book_recv_ms - *prev_recv_ms).abs()
+                                    <= strategy_book_dedupe_window_ms;
+                                let max_diff_bps = max_book_top_diff_bps(
+                                    *prev_bid_yes,
+                                    *prev_ask_yes,
+                                    *prev_bid_no,
+                                    *prev_ask_no,
+                                    &book,
+                                );
+                                if within_window && max_diff_bps <= strategy_book_dedupe_bps {
+                                    metrics::counter!("strategy.ingress_book_dedupe_drop")
+                                        .increment(1);
+                                    continue;
+                                }
+                            }
+                            last_enqueued_book_by_market.insert(
+                                book.market_id.clone(),
+                                (
+                                    book_recv_ms,
+                                    book.bid_yes,
+                                    book.ask_yes,
+                                    book.bid_no,
+                                    book.ask_no,
+                                ),
+                            );
+                        }
+
+                        let ingress = StrategyIngressMsg {
+                            enqueued_ns: now_ns(),
+                            payload: StrategyIngress::BookTop(book.clone()),
+                        };
+                        if strategy_ingress_drop_on_full {
+                            match strategy_tx.try_send(ingress) {
+                                Ok(()) => {}
+                                Err(mpsc::error::TrySendError::Full(_)) => {
+                                    metrics::counter!("strategy.ingress_book_drop").increment(1);
+                                }
+                                Err(mpsc::error::TrySendError::Closed(_)) => break,
+                            }
+                        } else if strategy_tx.send(ingress).await.is_err() {
+                            break;
+                        }
+
+                        publish_if_telemetry_subscribers(&bus, EngineEvent::BookTop(book));
+                    }
+                    Err(err) => {
+                        tracing::warn!(?err, "market feed event error");
+                    }
+                }
+            }
+
+            reconnects = reconnects.saturating_add(1);
+            let backoff_ms =
+                (RECONNECT_BASE_MS.saturating_mul(reconnects.min(40))).min(RECONNECT_MAX_MS);
+            tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
+        }
+    });
+}
diff --git a/crates/app_runner/src/fusion_engine.rs b/crates/app_runner/src/fusion_engine.rs
new file mode 100644
index 0000000..2b0a429
--- /dev/null
+++ b/crates/app_runner/src/fusion_engine.rs
@@ -0,0 +1,495 @@
+use std::collections::HashMap;
+use std::sync::OnceLock;
+use std::time::Instant;
+
+use core_types::{BookTop, RefTick};
+use dashmap::DashMap;
+
+use crate::state::FusionConfig;
+use crate::stats_utils::now_ns;
+
+#[derive(Debug, Clone, Copy, Default)]
+pub(super) struct FeedLatencySample {
+    pub(super) feed_in_ms: f64,
+    pub(super) source_latency_ms: f64,
+    pub(super) exchange_lag_ms: f64,
+    pub(super) path_lag_ms: f64,
+    pub(super) book_latency_ms: f64,
+    pub(super) local_backlog_ms: f64,
+    pub(super) ref_decode_ms: f64,
+}
+
+#[derive(Debug, Clone, Copy, Default)]
+pub(super) struct PathLagCalibState {
+    floor_ms: f64,
+    initialized: bool,
+    updated_ns: i64,
+}
+
+pub(super) static PATH_LAG_CALIB: OnceLock<DashMap<String, PathLagCalibState>> = OnceLock::new();
+
+pub(super) fn path_lag_calib_map() -> &'static DashMap<String, PathLagCalibState> {
+    PATH_LAG_CALIB.get_or_init(DashMap::new)
+}
+
+pub(super) fn calibrate_path_lag_ms(source: &str, observed_delta_ms: f64, now_ns: i64) -> f64 {
+    const FLOOR_RISE_MS_PER_SEC: f64 = 0.20;
+    const FLOOR_CLAMP_MIN_MS: f64 = -10_000.0;
+    const FLOOR_CLAMP_MAX_MS: f64 = 10_000.0;
+    let key = source.to_string();
+    let mut state = path_lag_calib_map()
+        .get(&key)
+        .map(|v| *v)
+        .unwrap_or_default();
+    if !state.initialized {
+        state.floor_ms = observed_delta_ms;
+        state.initialized = true;
+        state.updated_ns = now_ns;
+    } else {
+        let dt_sec = ((now_ns - state.updated_ns).max(0) as f64) / 1_000_000_000.0;
+        let mut floor = state.floor_ms + dt_sec * FLOOR_RISE_MS_PER_SEC;
+        if observed_delta_ms < floor {
+            floor = observed_delta_ms;
+        }
+        state.floor_ms = floor.clamp(FLOOR_CLAMP_MIN_MS, FLOOR_CLAMP_MAX_MS);
+        state.updated_ns = now_ns;
+    }
+    path_lag_calib_map().insert(key, state);
+    (observed_delta_ms - state.floor_ms).max(0.0)
+}
+
+#[cfg(test)]
+pub(super) fn reset_path_lag_calib_for_tests() {
+    if let Some(map) = PATH_LAG_CALIB.get() {
+        map.clear();
+    }
+}
+
+#[derive(Debug, Clone)]
+pub(super) struct TokenBucket {
+    pub(super) rps: f64,
+    pub(super) burst: f64,
+    pub(super) tokens: f64,
+    pub(super) last_refill: Instant,
+}
+
+impl TokenBucket {
+    pub(super) fn new(rps: f64, burst: f64) -> Self {
+        let rps = rps.max(0.1);
+        let burst = burst.max(1.0);
+        Self {
+            rps,
+            burst,
+            tokens: burst,
+            last_refill: Instant::now(),
+        }
+    }
+
+    pub(super) fn try_take(&mut self, n: f64) -> bool {
+        let now = Instant::now();
+        let dt = now.duration_since(self.last_refill).as_secs_f64();
+        self.last_refill = now;
+        self.tokens = (self.tokens + dt * self.rps).clamp(0.0, self.burst);
+        if self.tokens >= n {
+            self.tokens -= n;
+            true
+        } else {
+            false
+        }
+    }
+}
+
+pub(super) fn estimate_feed_latency(tick: &RefTick, book: &BookTop) -> FeedLatencySample {
+    let now = now_ns();
+    let now_ms = now / 1_000_000;
+    let tick_source_ms = tick.event_ts_exchange_ms.max(tick.event_ts_ms);
+    let tick_ingest_ms = (tick.recv_ts_ms - tick_source_ms).max(0) as f64;
+    let exchange_lag_ms = tick
+        .ts_first_hop_ms
+        .map(|first| (first - tick_source_ms).max(0) as f64)
+        .unwrap_or(tick_ingest_ms);
+    let path_lag_ms = tick
+        .ts_first_hop_ms
+        .map(|first| calibrate_path_lag_ms(&tick.source, (tick.recv_ts_ms - first) as f64, now))
+        .unwrap_or(f64::NAN);
+    let book_recv_ms = if book.recv_ts_local_ns > 0 {
+        (book.recv_ts_local_ns / 1_000_000).max(0)
+    } else {
+        now_ms
+    };
+    let book_ingest_ms = (book_recv_ms - book.ts_ms).max(0) as f64;
+    // IMPORTANT: `source_latency_ms` is the external *reference* (CEX) tick latency proxy.
+    // Do not mix in Polymarket book timestamps here; track book latency separately.
+    let source_latency_ms = tick_ingest_ms;
+    let ref_decode_ms = if tick.recv_ts_local_ns > 0 && tick.ingest_ts_local_ns > 0 {
+        ((tick.ingest_ts_local_ns - tick.recv_ts_local_ns).max(0) as f64) / 1_000_000.0
+    } else {
+        0.0
+    };
+
+    let latest_recv_ns = if book.recv_ts_local_ns > 0 {
+        tick.recv_ts_local_ns.max(book.recv_ts_local_ns)
+    } else {
+        tick.recv_ts_local_ns
+    };
+    let local_backlog_ms = if latest_recv_ns > 0 {
+        ((now - latest_recv_ns).max(0) as f64) / 1_000_000.0
+    } else {
+        (now_ms - tick.recv_ts_ms.max(book.ts_ms)).max(0) as f64
+    };
+
+    // IMPORTANT: `feed_in_ms` is the *local* recv->ingest latency (decode + enqueue), intended
+    // to be <5ms and independent of exchange clock skew. Use source_latency_ms/local_backlog_ms
+    // separately for "how old is this data?" debugging/guardrails.
+    let feed_in_ms = ref_decode_ms;
+    FeedLatencySample {
+        feed_in_ms,
+        source_latency_ms,
+        exchange_lag_ms,
+        path_lag_ms,
+        book_latency_ms: book_ingest_ms,
+        local_backlog_ms,
+        ref_decode_ms,
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+pub(super) struct CoalescePolicy {
+    pub(super) max_events: usize,
+    pub(super) budget_us: u64,
+}
+
+pub(super) fn compute_coalesce_policy(
+    queue_len: usize,
+    lag_p50_ms: Option<f64>,
+    strategy_max_coalesce: usize,
+    strategy_coalesce_min: usize,
+    strategy_coalesce_budget_us: u64,
+) -> CoalescePolicy {
+    // For shallow queues, process immediately to minimize tail latency.
+    if queue_len < 12 {
+        return CoalescePolicy {
+            max_events: 0,
+            budget_us: 0,
+        };
+    }
+
+    // If queue is already deep, prioritize drain speed to collapse backlog spikes quickly.
+    if queue_len >= 128 {
+        let max_events = queue_len
+            .min(strategy_max_coalesce)
+            .max(strategy_coalesce_min);
+        let budget_us = strategy_coalesce_budget_us.max(800).min(3_000);
+        return CoalescePolicy {
+            max_events,
+            budget_us,
+        };
+    }
+
+    let dynamic_cap = queue_len
+        .saturating_div(2)
+        .saturating_add(8)
+        .min(strategy_max_coalesce);
+    let max_events = dynamic_cap.max(strategy_coalesce_min);
+    let budget_us = match lag_p50_ms {
+        Some(l) if l >= 80.0 => 220_u64,
+        Some(l) if l >= 40.0 => strategy_coalesce_budget_us.min(160),
+        Some(l) if l >= 15.0 => 80_u64,
+        Some(_) => 40_u64,
+        None => strategy_coalesce_budget_us.min(120),
+    };
+
+    CoalescePolicy {
+        max_events,
+        budget_us,
+    }
+}
+
+pub(super) fn is_anchor_ref_source(source: &str) -> bool {
+    source == "chainlink_rtds"
+}
+
+#[inline]
+pub(super) fn fast_tick_allowed_in_fusion_mode(source: &str, mode: &str) -> bool {
+    match mode {
+        "udp_only" => source == "binance_udp",
+        "direct_only" => source != "binance_udp" && !is_anchor_ref_source(source),
+        "active_active" | "websocket_primary" => true,
+        // Unknown future modes: keep permissive to avoid accidental data blackout.
+        _ => true,
+    }
+}
+
+#[inline]
+pub(super) fn should_arm_ws_primary_fallback(
+    mode: &str,
+    ws_cap_ready: bool,
+    ws_breach_persisted: bool,
+    fallback_active: bool,
+) -> bool {
+    mode == "websocket_primary" && ws_breach_persisted && !ws_cap_ready && !fallback_active
+}
+
+#[inline]
+pub(super) fn should_enforce_udp_share_cap(
+    mode: &str,
+    fallback_active: bool,
+    share_high: bool,
+) -> bool {
+    matches!(mode, "active_active" | "websocket_primary") && !fallback_active && share_high
+}
+
+pub(super) fn ref_event_ts_ms(tick: &RefTick) -> i64 {
+    tick.event_ts_exchange_ms.max(tick.event_ts_ms)
+}
+
+pub(super) fn should_replace_ref_tick(current: &RefTick, next: &RefTick) -> bool {
+    let current_event = ref_event_ts_ms(current);
+    let next_event = ref_event_ts_ms(next);
+    // Guard: ignore ticks whose event timestamp is wildly in the future vs our local receive time.
+    // (This can happen under clock skew or malformed payloads and would break latency ranking.)
+    if next_event > next.recv_ts_ms + 5_000 {
+        return false;
+    }
+
+    let staleness_budget_us = fusion_staleness_budget_us_for_source(next.source.as_str());
+    if next.recv_ts_local_ns > 0
+        && current.recv_ts_local_ns > 0
+        && next.source != current.source
+        && next.recv_ts_local_ns > current.recv_ts_local_ns
+    {
+        let arrival_delta_us = (next.recv_ts_local_ns - current.recv_ts_local_ns) / 1_000;
+        if arrival_delta_us > staleness_budget_us && next_event <= current_event + 1 {
+            return false;
+        }
+    }
+
+    // Priority 1: Chainlink RTDS has <5ms latency, always prefer when timestamps are recent
+    if next.source == "chainlink_rtds" && next_event + 50 >= current_event {
+        return true;
+    }
+    if current.source == "chainlink_rtds" && current_event + 50 >= next_event {
+        return false;
+    }
+    // Goal: "fastest observable tick" for latency-sensitive triggers.
+    // Event timestamps across sources are not perfectly comparable, so we bias towards lower
+    // `recv_ts_ms - event_ts_ms` latency (i.e. faster wire path), with a small guard against
+    // extreme back-jumps in event time.
+    let current_latency_ms = (current.recv_ts_ms - current_event).max(0) as f64;
+    let next_latency_ms = (next.recv_ts_ms - next_event).max(0) as f64;
+
+    const EVENT_BACKJUMP_TOL_MS: i64 = 250;
+    const LATENCY_DOMINATE_MS: f64 = 20.0;
+    const LATENCY_TIE_EPS_MS: f64 = 5.0;
+
+    if next_event + EVENT_BACKJUMP_TOL_MS < current_event {
+        // Allow a big latency improvement to override moderate event-time skew.
+        return next_latency_ms + LATENCY_DOMINATE_MS < current_latency_ms;
+    }
+
+    if next_latency_ms + LATENCY_TIE_EPS_MS < current_latency_ms {
+        return true;
+    }
+    if current_latency_ms + LATENCY_TIE_EPS_MS < next_latency_ms {
+        return false;
+    }
+
+    // Within ~5ms latency tie: prefer the newer event time, otherwise keep first-arriving tick.
+    next_event > current_event + 1
+}
+
+// Source-specific fusion staleness budgets:
+// - UDP path (`binance_udp`) has sub-millisecond latency, so use a tighter 200us window.
+// - Other sources (direct WS, Chainlink) keep a looser 600us default.
+pub(super) fn fusion_staleness_budget_us_for_source(next_source: &str) -> i64 {
+    static BUDGET_UDP_US: OnceLock<i64> = OnceLock::new();
+    static BUDGET_DEFAULT_US: OnceLock<i64> = OnceLock::new();
+
+    // UDP path: aggressive freshness window (default 200us).
+    if next_source.contains("udp") {
+        return *BUDGET_UDP_US.get_or_init(|| {
+            std::env::var("POLYEDGE_FUSION_STALENESS_UDP_US")
+                .ok()
+                .and_then(|v| v.parse::<i64>().ok())
+                .unwrap_or(200)
+                .clamp(50, 2_000)
+        });
+    }
+
+    // Other sources: default 600us window.
+    *BUDGET_DEFAULT_US.get_or_init(|| {
+        std::env::var("POLYEDGE_FUSION_STALENESS_BUDGET_US")
+            .ok()
+            .and_then(|v| v.parse::<i64>().ok())
+            .unwrap_or(600)
+            .clamp(50, 5_000)
+    })
+}
+
+pub(super) fn udp_min_freshness_score() -> f64 {
+    static UDP_MIN_FRESHNESS_SCORE: OnceLock<f64> = OnceLock::new();
+    *UDP_MIN_FRESHNESS_SCORE.get_or_init(|| {
+        std::env::var("POLYEDGE_UDP_MIN_FRESHNESS_SCORE")
+            .ok()
+            .and_then(|v| v.parse::<f64>().ok())
+            .unwrap_or(0.55)
+            .clamp(0.0, 1.0)
+    })
+}
+
+pub(super) fn ws_primary_fallback_gap_ns() -> i64 {
+    3_000 * 1_000_000
+}
+
+pub(super) fn udp_downweight_keep_every() -> usize {
+    static UDP_KEEP_EVERY: OnceLock<usize> = OnceLock::new();
+    *UDP_KEEP_EVERY.get_or_init(|| {
+        std::env::var("POLYEDGE_UDP_DOWNWEIGHT_KEEP_EVERY")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(3)
+            .clamp(2, 32)
+    })
+}
+
+#[inline]
+pub(super) fn should_log_ref_tick(ingest_seq: u64) -> bool {
+    static SAMPLE_EVERY: OnceLock<u64> = OnceLock::new();
+    let sample_every = *SAMPLE_EVERY.get_or_init(|| {
+        std::env::var("POLYEDGE_REF_TICK_LOG_SAMPLE_EVERY")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(32)
+            .clamp(1, 1024)
+    });
+    ingest_seq % sample_every == 0
+}
+
+pub(super) fn is_ref_tick_duplicate(
+    current_source_ts_ms: i64,
+    current_price: f64,
+    prev_source_ts_ms: i64,
+    prev_price: f64,
+    cfg: &FusionConfig,
+) -> bool {
+    if (current_source_ts_ms - prev_source_ts_ms).abs() > cfg.dedupe_window_ms {
+        return false;
+    }
+    if !current_price.is_finite() || !prev_price.is_finite() {
+        return false;
+    }
+    let denom = prev_price.abs().max(1e-9);
+    let rel_bps = ((current_price - prev_price).abs() / denom) * 10_000.0;
+    rel_bps <= cfg.dedupe_price_bps
+}
+
+pub(super) fn max_book_top_diff_bps(
+    prev_bid_yes: f64,
+    prev_ask_yes: f64,
+    prev_bid_no: f64,
+    prev_ask_no: f64,
+    next: &BookTop,
+) -> f64 {
+    fn diff_bps(a: f64, b: f64) -> f64 {
+        if !a.is_finite() || !b.is_finite() {
+            return f64::INFINITY;
+        }
+        let denom = a.abs().max(1e-9);
+        ((a - b).abs() / denom) * 10_000.0
+    }
+
+    diff_bps(prev_bid_yes, next.bid_yes)
+        .max(diff_bps(prev_ask_yes, next.ask_yes))
+        .max(diff_bps(prev_bid_no, next.bid_no))
+        .max(diff_bps(prev_ask_no, next.ask_no))
+}
+
+pub(super) fn should_replace_anchor_tick(current: &RefTick, next: &RefTick) -> bool {
+    let current_event = ref_event_ts_ms(current);
+    let next_event = ref_event_ts_ms(next);
+    if next_event + 50 < current_event {
+        return false;
+    }
+    if next_event > current_event + 1 {
+        return true;
+    }
+    next.recv_ts_local_ns > current.recv_ts_local_ns + 1_000_000
+}
+
+pub(super) fn insert_latest_tick(latest_ticks: &mut HashMap<String, RefTick>, tick: RefTick) {
+    match latest_ticks.get(tick.symbol.as_str()) {
+        Some(current) => {
+            if should_replace_ref_tick(current, &tick) {
+                latest_ticks.insert(tick.symbol.clone(), tick);
+            }
+        }
+        None => {
+            latest_ticks.insert(tick.symbol.clone(), tick);
+        }
+    }
+}
+
+pub(super) fn insert_latest_anchor_tick(
+    latest_ticks: &mut HashMap<String, RefTick>,
+    tick: RefTick,
+) {
+    match latest_ticks.get(tick.symbol.as_str()) {
+        Some(current) => {
+            if should_replace_anchor_tick(current, &tick) {
+                latest_ticks.insert(tick.symbol.clone(), tick);
+            }
+        }
+        None => {
+            latest_ticks.insert(tick.symbol.clone(), tick);
+        }
+    }
+}
+
+pub(super) fn upsert_latest_tick_slot(
+    latest_ticks: &DashMap<String, RefTick>,
+    tick: RefTick,
+    should_replace: fn(&RefTick, &RefTick) -> bool,
+) -> Option<i64> {
+    use dashmap::mapref::entry::Entry;
+    match latest_ticks.entry(tick.symbol.clone()) {
+        Entry::Occupied(mut entry) => {
+            let current = entry.get();
+            if !should_replace(current, &tick) {
+                return None;
+            }
+            let delta_ns = if current.source != tick.source
+                && current.recv_ts_local_ns > 0
+                && tick.recv_ts_local_ns > 0
+            {
+                Some((tick.recv_ts_local_ns - current.recv_ts_local_ns).unsigned_abs() as i64)
+            } else {
+                None
+            };
+            entry.insert(tick);
+            delta_ns
+        }
+        Entry::Vacant(entry) => {
+            entry.insert(tick);
+            None
+        }
+    }
+}
+
+pub(super) fn insert_latest_ref_tick(
+    latest_fast_ticks: &mut HashMap<String, RefTick>,
+    latest_anchor_ticks: &mut HashMap<String, RefTick>,
+    tick: RefTick,
+) {
+    if is_anchor_ref_source(tick.source.as_str()) {
+        insert_latest_anchor_tick(latest_anchor_ticks, tick);
+    } else {
+        insert_latest_tick(latest_fast_ticks, tick);
+    }
+}
+
+pub(super) fn pick_latest_tick<'a>(
+    latest_ticks: &'a HashMap<String, RefTick>,
+    symbol: &str,
+) -> Option<&'a RefTick> {
+    latest_ticks.get(symbol)
+}
diff --git a/crates/app_runner/src/gate_eval.rs b/crates/app_runner/src/gate_eval.rs
index 87cf104..460c817 100644
--- a/crates/app_runner/src/gate_eval.rs
+++ b/crates/app_runner/src/gate_eval.rs
@@ -1,4 +1,4 @@
-use super::*;
+use crate::state::ShadowLiveReport;
 
 pub(super) fn compute_gate_fail_reasons(
     live: &ShadowLiveReport,
@@ -11,6 +11,18 @@ pub(super) fn compute_gate_fail_reasons(
             live.window_outcomes, min_outcomes
         ));
     }
+    if live.latency.ack_only_n < min_outcomes as u64 {
+        failed.push(format!(
+            "ack_only_unmeasured_or_insufficient_samples {} < {}",
+            live.latency.ack_only_n, min_outcomes
+        ));
+    }
+    if live.latency.capturable_window_n < min_outcomes as u64 {
+        failed.push(format!(
+            "capturable_window_unmeasured_or_insufficient_samples {} < {}",
+            live.latency.capturable_window_n, min_outcomes
+        ));
+    }
     if live.fillability_10ms < 0.60 {
         failed.push(format!(
             "fillability_10ms {:.4} < 0.6000",
@@ -92,6 +104,13 @@ pub(super) fn compute_gate_fail_reasons(
             live.ref_freshness_ms
         ));
     }
+    if live.probability_total >= min_outcomes as u64 && live.settlement_source_degraded_ratio > 0.50
+    {
+        failed.push(format!(
+            "settlement_source_degraded_ratio {:.4} > 0.50",
+            live.settlement_source_degraded_ratio
+        ));
+    }
     if live.net_markout_10s_usdc_p50 <= 0.0 {
         failed.push(format!(
             "net_markout_10s_usdc_p50 {:.6} <= 0",
diff --git a/crates/app_runner/src/main.rs b/crates/app_runner/src/main.rs
index 8a1a0c6..1205941 100644
--- a/crates/app_runner/src/main.rs
+++ b/crates/app_runner/src/main.rs
@@ -1,1484 +1,38 @@
-use std::collections::{HashMap, VecDeque};
-use std::fs::{self, OpenOptions};
-use std::io::Write;
-use std::net::SocketAddr;
-use std::path::{Path, PathBuf};
-use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
-use std::sync::{Arc, OnceLock, RwLock as StdRwLock};
-use std::time::{Duration, Instant};
+use std::future::Future;
+use std::panic::AssertUnwindSafe;
 
 use anyhow::Result;
-use axum::extract::State;
-use axum::http::StatusCode;
-use axum::response::IntoResponse;
-use axum::routing::{get, post};
-use axum::{Json, Router};
-use chrono::Utc;
-use core_types::{
-    new_id, BookTop, ControlCommand, EdgeAttribution, EngineEvent, EnginePnLBreakdown,
-    ExecutionStyle, ExecutionVenue, FairValueModel, InventoryState, MarketFeed, MarketHealth,
-    OrderAck, OrderIntentV2, OrderSide, OrderTimeInForce, QuoteEval, QuoteIntent, QuotePolicy,
-    RefPriceFeed, RefTick, RiskContext, RiskManager, ShadowOutcome, ShadowShot, ToxicDecision,
-    ToxicFeatures, ToxicRegime,
-};
-use execution_clob::{ClobExecution, ExecutionMode};
-use fair_value::{BasisMrConfig, BasisMrFairValue};
-use feed_polymarket::PolymarketFeed;
-use feed_reference::MultiSourceRefFeed;
-use futures::StreamExt;
+use core_types::EngineEvent;
+use futures::FutureExt;
 use infra_bus::RingBus;
-use market_discovery::{DiscoveryConfig, MarketDiscovery};
-use observability::{init_metrics, init_tracing};
-use paper_executor::ShadowExecutor;
-use portfolio::PortfolioBook;
-use reqwest::Client;
-use risk_engine::{DefaultRiskManager, RiskLimits};
-use serde::{Deserialize, Serialize};
-use sha2::{Digest, Sha256};
-use strategy_maker::{MakerConfig, MakerQuotePolicy};
-use tokio::sync::{mpsc, RwLock};
 
+#[global_allocator]
+static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;
+
+mod bootstrap;
+mod config_loader;
 mod control_api;
 mod engine_core;
+mod engine_loop;
+mod execution_eval;
+mod feed_runtime;
+mod fusion_engine;
 mod gate_eval;
 mod orchestration;
+mod paper_runtime;
+mod paper_sqlite;
+mod report_io;
+mod seat_persist;
+mod seat_runtime;
+mod seat_types;
+mod state;
 mod stats_utils;
-use engine_core::{
-    classify_execution_error_reason, classify_execution_style, is_policy_block_reason,
-    is_quote_reject_reason, normalize_reject_code,
-};
-use stats_utils::{
-    freshness_ms, now_ns, percentile, percentile_deque, policy_block_ratio, push_capped,
-    quote_block_ratio, robust_filter_iqr, value_to_f64,
-};
-
-#[derive(Clone)]
-struct AppState {
-    paused: Arc<RwLock<bool>>,
-    bus: RingBus<EngineEvent>,
-    portfolio: Arc<PortfolioBook>,
-    execution: Arc<ClobExecution>,
-    _shadow: Arc<ShadowExecutor>,
-    prometheus: metrics_exporter_prometheus::PrometheusHandle,
-    strategy_cfg: Arc<RwLock<MakerConfig>>,
-    fair_value_cfg: Arc<StdRwLock<BasisMrConfig>>,
-    toxicity_cfg: Arc<RwLock<ToxicityConfig>>,
-    allocator_cfg: Arc<RwLock<AllocatorConfig>>,
-    risk_limits: Arc<StdRwLock<RiskLimits>>,
-    tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
-    shadow_stats: Arc<ShadowStats>,
-    perf_profile: Arc<RwLock<PerfProfile>>,
-}
-
-#[derive(Debug, Clone)]
-struct FeeRateEntry {
-    fee_bps: f64,
-    fetched_at: Instant,
-}
-
-#[derive(Debug, Clone)]
-struct ScoringState {
-    scoring_true: u64,
-    scoring_total: u64,
-    rebate_bps_est: f64,
-    fetched_at: Instant,
-}
-
-#[derive(Clone)]
-struct EngineShared {
-    latest_books: Arc<RwLock<HashMap<String, BookTop>>>,
-    market_to_symbol: Arc<RwLock<HashMap<String, String>>>,
-    token_to_symbol: Arc<RwLock<HashMap<String, String>>>,
-    fee_cache: Arc<RwLock<HashMap<String, FeeRateEntry>>>,
-    fee_refresh_inflight: Arc<RwLock<HashMap<String, Instant>>>,
-    scoring_cache: Arc<RwLock<HashMap<String, ScoringState>>>,
-    scoring_refresh_inflight: Arc<RwLock<HashMap<String, Instant>>>,
-    http: Client,
-    clob_endpoint: String,
-    strategy_cfg: Arc<RwLock<MakerConfig>>,
-    fair_value_cfg: Arc<StdRwLock<BasisMrConfig>>,
-    toxicity_cfg: Arc<RwLock<ToxicityConfig>>,
-    risk_manager: Arc<DefaultRiskManager>,
-    universe_symbols: Arc<Vec<String>>,
-    universe_market_types: Arc<Vec<String>>,
-    universe_timeframes: Arc<Vec<String>>,
-    rate_limit_rps: f64,
-    scoring_rebate_factor: f64,
-    tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
-    shadow_stats: Arc<ShadowStats>,
-}
-
-#[derive(Serialize)]
-struct HealthResp {
-    status: &'static str,
-    paused: bool,
-}
-
-#[derive(Debug, Deserialize)]
-struct StrategyReloadReq {
-    min_edge_bps: Option<f64>,
-    ttl_ms: Option<u64>,
-    inventory_skew: Option<f64>,
-    base_quote_size: Option<f64>,
-    max_spread: Option<f64>,
-    basis_k_revert: Option<f64>,
-    basis_z_cap: Option<f64>,
-    basis_min_confidence: Option<f64>,
-    taker_trigger_bps: Option<f64>,
-    taker_max_slippage_bps: Option<f64>,
-    stale_tick_filter_ms: Option<f64>,
-    market_tier_profile: Option<String>,
-    capital_fraction_kelly: Option<f64>,
-    variance_penalty_lambda: Option<f64>,
-    min_eval_notional_usdc: Option<f64>,
-    min_expected_edge_usdc: Option<f64>,
-}
-
-#[derive(Debug, Serialize)]
-struct StrategyReloadResp {
-    maker: MakerConfig,
-    fair_value: BasisMrConfig,
-}
-
-#[derive(Debug, Deserialize)]
-struct RiskReloadReq {
-    max_market_notional: Option<f64>,
-    max_asset_notional: Option<f64>,
-    max_open_orders: Option<usize>,
-    daily_drawdown_cap_pct: Option<f64>,
-    max_loss_streak: Option<u32>,
-    cooldown_sec: Option<u64>,
-}
-
-#[derive(Debug, Deserialize)]
-struct TakerReloadReq {
-    trigger_bps: Option<f64>,
-    max_slippage_bps: Option<f64>,
-    stale_tick_filter_ms: Option<f64>,
-    market_tier_profile: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct TakerReloadResp {
-    trigger_bps: f64,
-    max_slippage_bps: f64,
-    stale_tick_filter_ms: f64,
-    market_tier_profile: String,
-}
-
-#[derive(Debug, Deserialize)]
-struct AllocatorReloadReq {
-    capital_fraction_kelly: Option<f64>,
-    variance_penalty_lambda: Option<f64>,
-    active_top_n_markets: Option<usize>,
-    taker_weight: Option<f64>,
-    maker_weight: Option<f64>,
-    arb_weight: Option<f64>,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-struct AllocatorConfig {
-    capital_fraction_kelly: f64,
-    variance_penalty_lambda: f64,
-    active_top_n_markets: usize,
-    taker_weight: f64,
-    maker_weight: f64,
-    arb_weight: f64,
-}
-
-impl Default for AllocatorConfig {
-    fn default() -> Self {
-        Self {
-            capital_fraction_kelly: 0.35,
-            variance_penalty_lambda: 0.25,
-            active_top_n_markets: 8,
-            taker_weight: 0.7,
-            maker_weight: 0.2,
-            arb_weight: 0.1,
-        }
-    }
-}
-
-#[derive(Debug, Serialize)]
-struct AllocatorReloadResp {
-    allocator: AllocatorConfig,
-}
-
-#[derive(Debug, Serialize)]
-struct RiskReloadResp {
-    risk: RiskLimits,
-}
-
-#[derive(Debug, Deserialize)]
-struct ToxicityReloadReq {
-    safe_threshold: Option<f64>,
-    caution_threshold: Option<f64>,
-    cooldown_min_sec: Option<u64>,
-    cooldown_max_sec: Option<u64>,
-    min_market_score: Option<f64>,
-    active_top_n_markets: Option<usize>,
-    markout_1s_caution_bps: Option<f64>,
-    markout_5s_caution_bps: Option<f64>,
-    markout_10s_caution_bps: Option<f64>,
-    markout_1s_danger_bps: Option<f64>,
-    markout_5s_danger_bps: Option<f64>,
-    markout_10s_danger_bps: Option<f64>,
-}
-
-#[derive(Debug, Deserialize)]
-struct PerfProfileReloadReq {
-    tail_guard: Option<f64>,
-    io_flush_batch: Option<usize>,
-    io_queue_capacity: Option<usize>,
-    json_mode: Option<String>,
-    io_drop_on_full: Option<bool>,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-struct ExecutionConfig {
-    mode: String,
-    rate_limit_rps: f64,
-    http_timeout_ms: u64,
-    clob_endpoint: String,
-}
-
-impl Default for ExecutionConfig {
-    fn default() -> Self {
-        Self {
-            mode: "paper".to_string(),
-            rate_limit_rps: 15.0,
-            http_timeout_ms: 3000,
-            clob_endpoint: "https://clob.polymarket.com".to_string(),
-        }
-    }
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-struct PerfProfile {
-    tail_guard: f64,
-    io_flush_batch: usize,
-    io_queue_capacity: usize,
-    json_mode: String,
-    io_drop_on_full: bool,
-}
-
-impl Default for PerfProfile {
-    fn default() -> Self {
-        Self {
-            tail_guard: 0.99,
-            io_flush_batch: 64,
-            io_queue_capacity: 16_384,
-            json_mode: "typed".to_string(),
-            io_drop_on_full: true,
-        }
-    }
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-struct ToxicityConfig {
-    w1: f64,
-    w2: f64,
-    w3: f64,
-    w4: f64,
-    w5: f64,
-    w6: f64,
-    safe_threshold: f64,
-    caution_threshold: f64,
-    k_spread: f64,
-    cooldown_min_sec: u64,
-    cooldown_max_sec: u64,
-    min_market_score: f64,
-    active_top_n_markets: usize,
-    markout_1s_caution_bps: f64,
-    markout_5s_caution_bps: f64,
-    markout_10s_caution_bps: f64,
-    markout_1s_danger_bps: f64,
-    markout_5s_danger_bps: f64,
-    markout_10s_danger_bps: f64,
-}
-
-impl Default for ToxicityConfig {
-    fn default() -> Self {
-        Self {
-            w1: 0.30,
-            w2: 0.25,
-            w3: 0.20,
-            w4: 0.10,
-            w5: 0.10,
-            w6: 0.05,
-            safe_threshold: 0.35,
-            caution_threshold: 0.65,
-            k_spread: 1.5,
-            cooldown_min_sec: 30,
-            cooldown_max_sec: 120,
-            min_market_score: 70.0,
-            active_top_n_markets: 8,
-            markout_1s_caution_bps: -4.0,
-            markout_5s_caution_bps: -6.0,
-            markout_10s_caution_bps: -8.0,
-            markout_1s_danger_bps: -10.0,
-            markout_5s_danger_bps: -14.0,
-            markout_10s_danger_bps: -18.0,
-        }
-    }
-}
-
-#[derive(Debug, Clone)]
-struct MarketToxicState {
-    symbol: String,
-    markout_1s: VecDeque<f64>,
-    markout_5s: VecDeque<f64>,
-    markout_10s: VecDeque<f64>,
-    attempted: u64,
-    no_quote: u64,
-    symbol_missing: u64,
-    last_tox_score: f64,
-    last_regime: ToxicRegime,
-    cooldown_until_ms: i64,
-}
-
-impl Default for MarketToxicState {
-    fn default() -> Self {
-        Self {
-            symbol: String::new(),
-            markout_1s: VecDeque::new(),
-            markout_5s: VecDeque::new(),
-            markout_10s: VecDeque::new(),
-            attempted: 0,
-            no_quote: 0,
-            symbol_missing: 0,
-            last_tox_score: 0.0,
-            last_regime: ToxicRegime::Safe,
-            cooldown_until_ms: 0,
-        }
-    }
-}
-
-#[derive(Debug, Serialize, Clone)]
-struct ToxicityMarketRow {
-    market_rank: usize,
-    market_id: String,
-    symbol: String,
-    tox_score: f64,
-    regime: ToxicRegime,
-    market_score: f64,
-    markout_10s_bps: f64,
-    no_quote_rate: f64,
-    symbol_missing_rate: f64,
-    pending_exposure: f64,
-    active_for_quoting: bool,
-}
-
-#[derive(Debug, Serialize)]
-struct ToxicityLiveReport {
-    ts_ms: i64,
-    average_tox_score: f64,
-    safe_count: usize,
-    caution_count: usize,
-    danger_count: usize,
-    rows: Vec<ToxicityMarketRow>,
-}
-
-#[derive(Debug, Serialize)]
-struct ToxicityFinalReport {
-    pass: bool,
-    failed_reasons: Vec<String>,
-    live: ToxicityLiveReport,
-}
-
-#[derive(Debug, Serialize)]
-struct GateEvaluation {
-    window_id: u64,
-    gate_ready: bool,
-    min_outcomes: usize,
-    pass: bool,
-    data_valid_ratio: f64,
-    seq_gap_rate: f64,
-    ts_inversion_rate: f64,
-    stale_tick_drop_ratio: f64,
-    fillability_10ms: f64,
-    net_edge_p50_bps: f64,
-    net_edge_p10_bps: f64,
-    net_markout_10s_usdc_p50: f64,
-    roi_notional_10s_bps_p50: f64,
-    pnl_10s_p50_bps_raw: f64,
-    pnl_10s_p50_bps_robust: f64,
-    pnl_10s_sample_count: usize,
-    pnl_10s_outlier_ratio: f64,
-    eligible_count: u64,
-    executed_count: u64,
-    executed_over_eligible: f64,
-    ev_net_usdc_p50: f64,
-    ev_net_usdc_p10: f64,
-    ev_positive_ratio: f64,
-    quote_block_ratio: f64,
-    policy_block_ratio: f64,
-    strategy_uptime_pct: f64,
-    tick_to_ack_p99_ms: f64,
-    decision_queue_wait_p99_ms: f64,
-    decision_compute_p99_ms: f64,
-    source_latency_p99_ms: f64,
-    local_backlog_p99_ms: f64,
-    failed_reasons: Vec<String>,
-}
-
-#[derive(Debug, Serialize, Clone, Default)]
-struct LatencyBreakdown {
-    feed_in_p50_ms: f64,
-    feed_in_p90_ms: f64,
-    feed_in_p99_ms: f64,
-    signal_p50_us: f64,
-    signal_p90_us: f64,
-    signal_p99_us: f64,
-    quote_p50_us: f64,
-    quote_p90_us: f64,
-    quote_p99_us: f64,
-    risk_p50_us: f64,
-    risk_p90_us: f64,
-    risk_p99_us: f64,
-    decision_queue_wait_p50_ms: f64,
-    decision_queue_wait_p90_ms: f64,
-    decision_queue_wait_p99_ms: f64,
-    decision_compute_p50_ms: f64,
-    decision_compute_p90_ms: f64,
-    decision_compute_p99_ms: f64,
-    tick_to_decision_p50_ms: f64,
-    tick_to_decision_p90_ms: f64,
-    tick_to_decision_p99_ms: f64,
-    ack_only_p50_ms: f64,
-    ack_only_p90_ms: f64,
-    ack_only_p99_ms: f64,
-    tick_to_ack_p50_ms: f64,
-    tick_to_ack_p90_ms: f64,
-    tick_to_ack_p99_ms: f64,
-    parse_p99_us: f64,
-    io_queue_p99_ms: f64,
-    bus_lag_p99_ms: f64,
-    shadow_fill_p50_ms: f64,
-    shadow_fill_p90_ms: f64,
-    shadow_fill_p99_ms: f64,
-    source_latency_p50_ms: f64,
-    source_latency_p90_ms: f64,
-    source_latency_p99_ms: f64,
-    local_backlog_p50_ms: f64,
-    local_backlog_p90_ms: f64,
-    local_backlog_p99_ms: f64,
-}
-
-#[derive(Debug, Serialize)]
-struct ShadowLiveReport {
-    window_id: u64,
-    window_shots: usize,
-    window_outcomes: usize,
-    gate_ready: bool,
-    gate_fail_reasons: Vec<String>,
-    observe_only: bool,
-    started_at_ms: i64,
-    elapsed_sec: u64,
-    total_shots: usize,
-    total_outcomes: usize,
-    data_valid_ratio: f64,
-    seq_gap_rate: f64,
-    ts_inversion_rate: f64,
-    stale_tick_drop_ratio: f64,
-    quote_attempted: u64,
-    quote_blocked: u64,
-    policy_blocked: u64,
-    fillability_5ms: f64,
-    fillability_10ms: f64,
-    fillability_25ms: f64,
-    survival_5ms: f64,
-    survival_10ms: f64,
-    survival_25ms: f64,
-    // Survival probe is an "orderless" latency-arb competitiveness metric:
-    // at T0 we observe a crossable top-of-book price, then check at +Œî whether
-    // it is still crossable. This intentionally does not depend on order acks.
-    survival_probe_5ms: f64,
-    survival_probe_10ms: f64,
-    survival_probe_25ms: f64,
-    survival_probe_5ms_n: u64,
-    survival_probe_10ms_n: u64,
-    survival_probe_25ms_n: u64,
-    net_edge_p50_bps: f64,
-    net_edge_p10_bps: f64,
-    pnl_1s_p50_bps: f64,
-    pnl_5s_p50_bps: f64,
-    pnl_10s_p50_bps: f64,
-    pnl_10s_p50_bps_raw: f64,
-    pnl_10s_p50_bps_robust: f64,
-    net_markout_10s_usdc_p50: f64,
-    roi_notional_10s_bps_p50: f64,
-    pnl_10s_sample_count: usize,
-    pnl_10s_outlier_ratio: f64,
-    eligible_count: u64,
-    executed_count: u64,
-    executed_over_eligible: f64,
-    ev_net_usdc_p50: f64,
-    ev_net_usdc_p10: f64,
-    ev_positive_ratio: f64,
-    quote_block_ratio: f64,
-    policy_block_ratio: f64,
-    queue_depth_p99: f64,
-    event_backlog_p99: f64,
-    tick_to_decision_p50_ms: f64,
-    tick_to_decision_p90_ms: f64,
-    tick_to_decision_p99_ms: f64,
-    decision_queue_wait_p99_ms: f64,
-    decision_compute_p99_ms: f64,
-    source_latency_p99_ms: f64,
-    local_backlog_p99_ms: f64,
-    ack_only_p50_ms: f64,
-    ack_only_p90_ms: f64,
-    ack_only_p99_ms: f64,
-    strategy_uptime_pct: f64,
-    tick_to_ack_p99_ms: f64,
-    ref_ticks_total: u64,
-    book_ticks_total: u64,
-    ref_freshness_ms: i64,
-    book_freshness_ms: i64,
-    book_top_lag_p50_ms: f64,
-    book_top_lag_p90_ms: f64,
-    book_top_lag_p99_ms: f64,
-    book_top_lag_by_symbol_p50_ms: HashMap<String, f64>,
-    survival_10ms_by_symbol: HashMap<String, f64>,
-    survival_probe_10ms_by_symbol: HashMap<String, f64>,
-    blocked_reason_counts: HashMap<String, u64>,
-    latency: LatencyBreakdown,
-    market_scorecard: Vec<MarketScoreRow>,
-}
-
-#[derive(Debug, Serialize)]
-struct ShadowFinalReport {
-    live: ShadowLiveReport,
-    gate: GateEvaluation,
-}
-
-#[derive(Debug, Serialize, Clone)]
-struct EnginePnlRow {
-    engine: String,
-    samples: usize,
-    total_usdc: f64,
-    p50_usdc: f64,
-    p10_usdc: f64,
-    positive_ratio: f64,
-}
-
-#[derive(Debug, Serialize, Clone)]
-struct EnginePnlReport {
-    window_id: u64,
-    breakdown: EnginePnLBreakdown,
-    rows: Vec<EnginePnlRow>,
-}
-
-#[derive(Debug, Serialize, Clone)]
-struct MarketScoreRow {
-    market_id: String,
-    symbol: String,
-    shots: usize,
-    outcomes: usize,
-    fillability_10ms: f64,
-    net_edge_p50_bps: f64,
-    net_edge_p10_bps: f64,
-    pnl_10s_p50_bps: f64,
-    net_markout_10s_usdc_p50: f64,
-    roi_notional_10s_bps_p50: f64,
-}
-
-#[derive(Debug, Clone, Copy, Default)]
-struct SurvivalProbeCounters {
-    n_5: u64,
-    s_5: u64,
-    n_10: u64,
-    s_10: u64,
-    n_25: u64,
-    s_25: u64,
-}
-
-impl SurvivalProbeCounters {
-    fn record(&mut self, delay_ms: u64, survived: bool) {
-        let (n, s) = match delay_ms {
-            5 => (&mut self.n_5, &mut self.s_5),
-            10 => (&mut self.n_10, &mut self.s_10),
-            25 => (&mut self.n_25, &mut self.s_25),
-            _ => return,
-        };
-        *n = n.saturating_add(1);
-        if survived {
-            *s = s.saturating_add(1);
-        }
-    }
-
-    fn ratio(&self, delay_ms: u64) -> f64 {
-        let (n, s) = match delay_ms {
-            5 => (self.n_5, self.s_5),
-            10 => (self.n_10, self.s_10),
-            25 => (self.n_25, self.s_25),
-            _ => (0, 0),
-        };
-        if n == 0 {
-            0.0
-        } else {
-            s as f64 / n as f64
-        }
-    }
-
-    fn n(&self, delay_ms: u64) -> u64 {
-        match delay_ms {
-            5 => self.n_5,
-            10 => self.n_10,
-            25 => self.n_25,
-            _ => 0,
-        }
-    }
-}
-
-struct ShadowStats {
-    window_id: AtomicU64,
-    started_at: RwLock<Instant>,
-    started_at_ms: AtomicI64,
-    quote_attempted: AtomicU64,
-    quote_blocked: AtomicU64,
-    policy_blocked: AtomicU64,
-    seen_count: AtomicU64,
-    candidate_count: AtomicU64,
-    quoted_count: AtomicU64,
-    eligible_count: AtomicU64,
-    executed_count: AtomicU64,
-    filled_count: AtomicU64,
-    blocked_reasons: RwLock<HashMap<String, u64>>,
-    ref_ticks_total: AtomicU64,
-    book_ticks_total: AtomicU64,
-    last_ref_tick_ms: AtomicI64,
-    last_book_tick_ms: AtomicI64,
-    shots: RwLock<Vec<ShadowShot>>,
-    outcomes: RwLock<Vec<ShadowOutcome>>,
-    decision_queue_wait_ms: RwLock<Vec<f64>>,
-    decision_compute_ms: RwLock<Vec<f64>>,
-    tick_to_decision_ms: RwLock<Vec<f64>>,
-    ack_only_ms: RwLock<Vec<f64>>,
-    tick_to_ack_ms: RwLock<Vec<f64>>,
-    feed_in_ms: RwLock<Vec<f64>>,
-    source_latency_ms: RwLock<Vec<f64>>,
-    local_backlog_ms: RwLock<Vec<f64>>,
-    book_top_lag_ms: RwLock<Vec<f64>>,
-    book_top_lag_by_symbol_ms: RwLock<HashMap<String, Vec<f64>>>,
-    survival_probe_overall: RwLock<SurvivalProbeCounters>,
-    survival_probe_by_symbol: RwLock<HashMap<String, SurvivalProbeCounters>>,
-    signal_us: RwLock<Vec<f64>>,
-    quote_us: RwLock<Vec<f64>>,
-    risk_us: RwLock<Vec<f64>>,
-    shadow_fill_ms: RwLock<Vec<f64>>,
-    queue_depth: RwLock<Vec<f64>>,
-    event_backlog: RwLock<Vec<f64>>,
-    parse_us: RwLock<Vec<f64>>,
-    io_queue_depth: RwLock<Vec<f64>>,
-    data_total: AtomicU64,
-    data_invalid: AtomicU64,
-    seq_gap: AtomicU64,
-    ts_inversion: AtomicU64,
-    stale_tick_dropped: AtomicU64,
-    loss_streak: AtomicU64,
-    observe_only: AtomicBool,
-    paused: AtomicBool,
-    paused_since_ms: AtomicU64,
-    paused_total_ms: AtomicU64,
-}
-
-impl ShadowStats {
-    const SHADOW_CAP: usize = 200_000;
-    const SAMPLE_CAP: usize = 65_536;
-    const GATE_MIN_OUTCOMES: usize = 30;
-
-    fn new() -> Self {
-        Self {
-            window_id: AtomicU64::new(0),
-            started_at: RwLock::new(Instant::now()),
-            started_at_ms: AtomicI64::new(Utc::now().timestamp_millis()),
-            quote_attempted: AtomicU64::new(0),
-            quote_blocked: AtomicU64::new(0),
-            policy_blocked: AtomicU64::new(0),
-            seen_count: AtomicU64::new(0),
-            candidate_count: AtomicU64::new(0),
-            quoted_count: AtomicU64::new(0),
-            eligible_count: AtomicU64::new(0),
-            executed_count: AtomicU64::new(0),
-            filled_count: AtomicU64::new(0),
-            blocked_reasons: RwLock::new(HashMap::new()),
-            ref_ticks_total: AtomicU64::new(0),
-            book_ticks_total: AtomicU64::new(0),
-            last_ref_tick_ms: AtomicI64::new(0),
-            last_book_tick_ms: AtomicI64::new(0),
-            shots: RwLock::new(Vec::new()),
-            outcomes: RwLock::new(Vec::new()),
-            decision_queue_wait_ms: RwLock::new(Vec::new()),
-            decision_compute_ms: RwLock::new(Vec::new()),
-            tick_to_decision_ms: RwLock::new(Vec::new()),
-            ack_only_ms: RwLock::new(Vec::new()),
-            tick_to_ack_ms: RwLock::new(Vec::new()),
-            feed_in_ms: RwLock::new(Vec::new()),
-            source_latency_ms: RwLock::new(Vec::new()),
-            local_backlog_ms: RwLock::new(Vec::new()),
-            book_top_lag_ms: RwLock::new(Vec::new()),
-            book_top_lag_by_symbol_ms: RwLock::new(HashMap::new()),
-            survival_probe_overall: RwLock::new(SurvivalProbeCounters::default()),
-            survival_probe_by_symbol: RwLock::new(HashMap::new()),
-            signal_us: RwLock::new(Vec::new()),
-            quote_us: RwLock::new(Vec::new()),
-            risk_us: RwLock::new(Vec::new()),
-            shadow_fill_ms: RwLock::new(Vec::new()),
-            queue_depth: RwLock::new(Vec::new()),
-            event_backlog: RwLock::new(Vec::new()),
-            parse_us: RwLock::new(Vec::new()),
-            io_queue_depth: RwLock::new(Vec::new()),
-            data_total: AtomicU64::new(0),
-            data_invalid: AtomicU64::new(0),
-            seq_gap: AtomicU64::new(0),
-            ts_inversion: AtomicU64::new(0),
-            stale_tick_dropped: AtomicU64::new(0),
-            loss_streak: AtomicU64::new(0),
-            observe_only: AtomicBool::new(false),
-            paused: AtomicBool::new(false),
-            paused_since_ms: AtomicU64::new(0),
-            paused_total_ms: AtomicU64::new(0),
-        }
-    }
-
-    async fn reset(&self) -> u64 {
-        let window_id = self.window_id.fetch_add(1, Ordering::Relaxed) + 1;
-        *self.started_at.write().await = Instant::now();
-        self.started_at_ms
-            .store(Utc::now().timestamp_millis(), Ordering::Relaxed);
-        self.quote_attempted.store(0, Ordering::Relaxed);
-        self.quote_blocked.store(0, Ordering::Relaxed);
-        self.policy_blocked.store(0, Ordering::Relaxed);
-        self.seen_count.store(0, Ordering::Relaxed);
-        self.candidate_count.store(0, Ordering::Relaxed);
-        self.quoted_count.store(0, Ordering::Relaxed);
-        self.eligible_count.store(0, Ordering::Relaxed);
-        self.executed_count.store(0, Ordering::Relaxed);
-        self.filled_count.store(0, Ordering::Relaxed);
-        self.ref_ticks_total.store(0, Ordering::Relaxed);
-        self.book_ticks_total.store(0, Ordering::Relaxed);
-        self.last_ref_tick_ms.store(0, Ordering::Relaxed);
-        self.last_book_tick_ms.store(0, Ordering::Relaxed);
-        self.blocked_reasons.write().await.clear();
-        self.shots.write().await.clear();
-        self.outcomes.write().await.clear();
-        self.decision_queue_wait_ms.write().await.clear();
-        self.decision_compute_ms.write().await.clear();
-        self.tick_to_decision_ms.write().await.clear();
-        self.ack_only_ms.write().await.clear();
-        self.tick_to_ack_ms.write().await.clear();
-        self.feed_in_ms.write().await.clear();
-        self.source_latency_ms.write().await.clear();
-        self.local_backlog_ms.write().await.clear();
-        self.book_top_lag_ms.write().await.clear();
-        self.book_top_lag_by_symbol_ms.write().await.clear();
-        *self.survival_probe_overall.write().await = SurvivalProbeCounters::default();
-        self.survival_probe_by_symbol.write().await.clear();
-        self.signal_us.write().await.clear();
-        self.quote_us.write().await.clear();
-        self.risk_us.write().await.clear();
-        self.shadow_fill_ms.write().await.clear();
-        self.queue_depth.write().await.clear();
-        self.event_backlog.write().await.clear();
-        self.parse_us.write().await.clear();
-        self.io_queue_depth.write().await.clear();
-        self.data_total.store(0, Ordering::Relaxed);
-        self.data_invalid.store(0, Ordering::Relaxed);
-        self.seq_gap.store(0, Ordering::Relaxed);
-        self.ts_inversion.store(0, Ordering::Relaxed);
-        self.stale_tick_dropped.store(0, Ordering::Relaxed);
-        self.loss_streak.store(0, Ordering::Relaxed);
-        self.observe_only.store(false, Ordering::Relaxed);
-        self.paused.store(false, Ordering::Relaxed);
-        self.paused_since_ms.store(0, Ordering::Relaxed);
-        self.paused_total_ms.store(0, Ordering::Relaxed);
-        window_id
-    }
-
-    async fn push_shot(&self, shot: ShadowShot) {
-        let ingest_seq = next_normalized_ingest_seq();
-        let source_seq = shot.t0_ns.max(0) as u64;
-        append_jsonl(
-            &dataset_path("normalized", "shadow_shots.jsonl"),
-            &serde_json::json!({
-                "ts_ms": Utc::now().timestamp_millis(),
-                "source_seq": source_seq,
-                "ingest_seq": ingest_seq,
-                "shot": shot
-            }),
-        );
-        let mut shots = self.shots.write().await;
-        push_capped(&mut shots, shot, Self::SHADOW_CAP);
-    }
-
-    async fn push_outcome(&self, outcome: ShadowOutcome) {
-        // Loss-streak only considers primary delay (10ms) *fillable* outcomes, so "no fills"
-        // does not trip risk controls.
-        const PRIMARY_DELAY_MS: u64 = 10;
-        if outcome.delay_ms == PRIMARY_DELAY_MS && outcome.fillable {
-            if outcome.net_markout_10s_usdc.unwrap_or(0.0) < 0.0 {
-                self.loss_streak.fetch_add(1, Ordering::Relaxed);
-            } else {
-                self.loss_streak.store(0, Ordering::Relaxed);
-            }
-        }
-        let ingest_seq = next_normalized_ingest_seq();
-        let source_seq = outcome.ts_ns.max(0) as u64;
-        append_jsonl(
-            &dataset_path("normalized", "shadow_outcomes.jsonl"),
-            &serde_json::json!({
-                "ts_ms": Utc::now().timestamp_millis(),
-                "source_seq": source_seq,
-                "ingest_seq": ingest_seq,
-                "outcome": outcome
-            }),
-        );
-        let mut outcomes = self.outcomes.write().await;
-        push_capped(&mut outcomes, outcome, Self::SHADOW_CAP);
-    }
-
-    fn loss_streak(&self) -> u32 {
-        self.loss_streak.load(Ordering::Relaxed).min(u32::MAX as u64) as u32
-    }
-
-    async fn window_outcomes_len(&self) -> usize {
-        self.outcomes.read().await.len()
-    }
-
-    async fn push_tick_to_decision_ms(&self, ms: f64) {
-        let mut v = self.tick_to_decision_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_decision_queue_wait_ms(&self, ms: f64) {
-        let mut v = self.decision_queue_wait_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_decision_compute_ms(&self, ms: f64) {
-        let mut v = self.decision_compute_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_ack_only_ms(&self, ms: f64) {
-        let mut v = self.ack_only_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_tick_to_ack_ms(&self, ms: f64) {
-        let mut v = self.tick_to_ack_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_feed_in_ms(&self, ms: f64) {
-        let mut v = self.feed_in_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_source_latency_ms(&self, ms: f64) {
-        let mut v = self.source_latency_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
+mod strategy_policy;
+mod strategy_runtime;
+mod toxicity_report;
+mod toxicity_runtime;
 
-    async fn push_local_backlog_ms(&self, ms: f64) {
-        let mut v = self.local_backlog_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_book_top_lag_ms(&self, symbol: &str, ms: f64) {
-        let mut v = self.book_top_lag_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-        drop(v);
-
-        let mut by_symbol = self.book_top_lag_by_symbol_ms.write().await;
-        let entry = by_symbol.entry(symbol.to_string()).or_default();
-        push_capped(entry, ms, 4_096);
-    }
-
-    async fn record_survival_probe(&self, symbol: &str, delay_ms: u64, survived: bool) {
-        {
-            let mut c = self.survival_probe_overall.write().await;
-            c.record(delay_ms, survived);
-        }
-        let mut by_symbol = self.survival_probe_by_symbol.write().await;
-        let entry = by_symbol.entry(symbol.to_string()).or_default();
-        entry.record(delay_ms, survived);
-    }
-
-    async fn push_signal_us(&self, us: f64) {
-        let mut v = self.signal_us.write().await;
-        push_capped(&mut v, us, Self::SAMPLE_CAP);
-    }
-
-    async fn push_quote_us(&self, us: f64) {
-        let mut v = self.quote_us.write().await;
-        push_capped(&mut v, us, Self::SAMPLE_CAP);
-    }
-
-    async fn push_risk_us(&self, us: f64) {
-        let mut v = self.risk_us.write().await;
-        push_capped(&mut v, us, Self::SAMPLE_CAP);
-    }
-
-    async fn push_shadow_fill_ms(&self, ms: f64) {
-        let mut v = self.shadow_fill_ms.write().await;
-        push_capped(&mut v, ms, Self::SAMPLE_CAP);
-    }
-
-    async fn push_queue_depth(&self, depth: f64) {
-        let mut v = self.queue_depth.write().await;
-        push_capped(&mut v, depth, Self::SAMPLE_CAP);
-    }
-
-    async fn push_event_backlog(&self, depth: f64) {
-        let mut v = self.event_backlog.write().await;
-        push_capped(&mut v, depth, Self::SAMPLE_CAP);
-    }
-
-    async fn push_parse_us(&self, us: f64) {
-        let mut v = self.parse_us.write().await;
-        push_capped(&mut v, us, Self::SAMPLE_CAP);
-    }
-
-    async fn push_io_queue_depth(&self, depth: f64) {
-        let mut v = self.io_queue_depth.write().await;
-        push_capped(&mut v, depth, Self::SAMPLE_CAP);
-    }
-
-    fn mark_attempted(&self) {
-        self.quote_attempted.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_seen(&self) {
-        self.seen_count.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_candidate(&self) {
-        self.candidate_count.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_quoted(&self, n: u64) {
-        self.quoted_count.fetch_add(n, Ordering::Relaxed);
-    }
-
-    fn mark_eligible(&self) {
-        self.eligible_count.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_executed(&self) {
-        self.executed_count.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_filled(&self, n: u64) {
-        self.filled_count.fetch_add(n, Ordering::Relaxed);
-    }
-
-    fn mark_blocked(&self) {
-        self.quote_blocked.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_policy_blocked(&self) {
-        self.policy_blocked.fetch_add(1, Ordering::Relaxed);
-    }
-
-    async fn mark_blocked_with_reason(&self, reason: &str) {
-        if is_quote_reject_reason(reason) {
-            self.mark_blocked();
-        }
-        if is_policy_block_reason(reason) {
-            self.mark_policy_blocked();
-        }
-        let mut reasons = self.blocked_reasons.write().await;
-        *reasons.entry(reason.to_string()).or_insert(0) += 1;
-    }
-
-    async fn record_issue(&self, reason: &str) {
-        let mut reasons = self.blocked_reasons.write().await;
-        *reasons.entry(reason.to_string()).or_insert(0) += 1;
-    }
-
-    fn mark_ref_tick(&self, ts_ms: i64) {
-        self.ref_ticks_total.fetch_add(1, Ordering::Relaxed);
-        self.last_ref_tick_ms.store(ts_ms, Ordering::Relaxed);
-    }
-
-    fn mark_book_tick(&self, ts_ms: i64) {
-        self.book_ticks_total.fetch_add(1, Ordering::Relaxed);
-        self.last_book_tick_ms.store(ts_ms, Ordering::Relaxed);
-    }
-
-    fn mark_data_validity(&self, valid: bool) {
-        self.data_total.fetch_add(1, Ordering::Relaxed);
-        if !valid {
-            self.data_invalid.fetch_add(1, Ordering::Relaxed);
-        }
-    }
-
-    fn mark_ts_inversion(&self) {
-        self.ts_inversion.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn mark_stale_tick_dropped(&self) {
-        self.stale_tick_dropped.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn observe_only(&self) -> bool {
-        self.observe_only.load(Ordering::Relaxed)
-    }
-
-    fn set_observe_only(&self, v: bool) {
-        self.observe_only.store(v, Ordering::Relaxed);
-    }
-
-    fn set_paused(&self, v: bool) {
-        let now_ms = Utc::now().timestamp_millis().max(0) as u64;
-        let was = self.paused.swap(v, Ordering::Relaxed);
-        if was == v {
-            return;
-        }
-        if v {
-            self.paused_since_ms.store(now_ms, Ordering::Relaxed);
-            return;
-        }
-        let since = self.paused_since_ms.swap(0, Ordering::Relaxed);
-        if since > 0 {
-            self.paused_total_ms
-                .fetch_add(now_ms.saturating_sub(since), Ordering::Relaxed);
-        }
-    }
-
-    fn uptime_pct(&self, elapsed: Duration) -> f64 {
-        let elapsed_ms = elapsed.as_millis() as u64;
-        if elapsed_ms == 0 {
-            return 100.0;
-        }
-        let now_ms = Utc::now().timestamp_millis().max(0) as u64;
-        let base_paused = self.paused_total_ms.load(Ordering::Relaxed);
-        let paused_extra = if self.paused.load(Ordering::Relaxed) {
-            let since = self.paused_since_ms.load(Ordering::Relaxed);
-            if since > 0 {
-                now_ms.saturating_sub(since)
-            } else {
-                0
-            }
-        } else {
-            0
-        };
-        let paused_ms = base_paused.saturating_add(paused_extra).min(elapsed_ms);
-        let uptime_ms = elapsed_ms.saturating_sub(paused_ms);
-        ((uptime_ms as f64) * 100.0 / elapsed_ms as f64).clamp(0.0, 100.0)
-    }
-}
-
-impl ShadowStats {
-    async fn build_live_report(&self) -> ShadowLiveReport {
-        const PRIMARY_DELAY_MS: u64 = 10;
-        let shots = self.shots.read().await.clone();
-        let outcomes = self.outcomes.read().await.clone();
-        let decision_queue_wait_ms = self.decision_queue_wait_ms.read().await.clone();
-        let decision_compute_ms = self.decision_compute_ms.read().await.clone();
-        let tick_to_decision_ms = self.tick_to_decision_ms.read().await.clone();
-        let ack_only_ms = self.ack_only_ms.read().await.clone();
-        let tick_to_ack_ms = self.tick_to_ack_ms.read().await.clone();
-        let feed_in_ms = self.feed_in_ms.read().await.clone();
-        let source_latency_ms = self.source_latency_ms.read().await.clone();
-        let local_backlog_ms = self.local_backlog_ms.read().await.clone();
-        let book_top_lag_ms = self.book_top_lag_ms.read().await.clone();
-        let book_top_lag_by_symbol_ms = self.book_top_lag_by_symbol_ms.read().await.clone();
-        let signal_us = self.signal_us.read().await.clone();
-        let quote_us = self.quote_us.read().await.clone();
-        let risk_us = self.risk_us.read().await.clone();
-        let shadow_fill_ms = self.shadow_fill_ms.read().await.clone();
-        let queue_depth = self.queue_depth.read().await.clone();
-        let event_backlog = self.event_backlog.read().await.clone();
-        let parse_us = self.parse_us.read().await.clone();
-        let io_queue_depth = self.io_queue_depth.read().await.clone();
-        let blocked_reason_counts = self.blocked_reasons.read().await.clone();
-        let survival_probe_overall = *self.survival_probe_overall.read().await;
-        let survival_probe_by_symbol = self.survival_probe_by_symbol.read().await.clone();
-
-        let fillability_5 = fillability_ratio(&outcomes, 5);
-        let fillability_10 = fillability_ratio(&outcomes, 10);
-        let fillability_25 = fillability_ratio(&outcomes, 25);
-        let survival_5 = survival_ratio(&outcomes, 5);
-        let survival_10 = survival_ratio(&outcomes, 10);
-        let survival_25 = survival_ratio(&outcomes, 25);
-        let survival_probe_5 = survival_probe_overall.ratio(5);
-        let survival_probe_10 = survival_probe_overall.ratio(10);
-        let survival_probe_25 = survival_probe_overall.ratio(25);
-        let survival_probe_5_n = survival_probe_overall.n(5);
-        let survival_probe_10_n = survival_probe_overall.n(10);
-        let survival_probe_25_n = survival_probe_overall.n(25);
-
-        let shots_primary = shots
-            .iter()
-            .filter(|s| s.delay_ms == PRIMARY_DELAY_MS)
-            .collect::<Vec<_>>();
-        let outcomes_primary = outcomes
-            .iter()
-            .filter(|o| o.delay_ms == PRIMARY_DELAY_MS)
-            .collect::<Vec<_>>();
-        let outcomes_primary_valid = outcomes_primary
-            .iter()
-            .filter(|o| !o.is_stale_tick)
-            .collect::<Vec<_>>();
-        let net_edges = shots_primary
-            .iter()
-            .map(|s| s.edge_net_bps)
-            .collect::<Vec<_>>();
-        let net_edge_p50 = percentile(&net_edges, 0.50).unwrap_or(0.0);
-        let net_edge_p10 = percentile(&net_edges, 0.10).unwrap_or(0.0);
-        let pnl_1s = outcomes_primary_valid
-            .iter()
-            .filter_map(|o| o.net_markout_1s_bps.or(o.pnl_1s_bps))
-            .collect::<Vec<_>>();
-        let pnl_5s = outcomes_primary_valid
-            .iter()
-            .filter_map(|o| o.net_markout_5s_bps.or(o.pnl_5s_bps))
-            .collect::<Vec<_>>();
-        let pnl_10s = outcomes_primary_valid
-            .iter()
-            .filter_map(|o| o.net_markout_10s_bps.or(o.pnl_10s_bps))
-            .collect::<Vec<_>>();
-        let net_markout_10s_usdc = outcomes_primary_valid
-            .iter()
-            .filter_map(|o| o.net_markout_10s_usdc)
-            .collect::<Vec<_>>();
-        let roi_notional_10s_bps = outcomes_primary_valid
-            .iter()
-            .filter_map(|o| o.roi_notional_10s_bps)
-            .collect::<Vec<_>>();
-        let pnl_1s_p50 = percentile(&pnl_1s, 0.50).unwrap_or(0.0);
-        let pnl_5s_p50 = percentile(&pnl_5s, 0.50).unwrap_or(0.0);
-        let pnl_10s_p50_raw = percentile(&pnl_10s, 0.50).unwrap_or(0.0);
-        let net_markout_10s_usdc_p50 = percentile(&net_markout_10s_usdc, 0.50).unwrap_or(0.0);
-        let roi_notional_10s_bps_p50 = percentile(&roi_notional_10s_bps, 0.50).unwrap_or(0.0);
-        let ev_net_usdc_p50 = percentile(&net_markout_10s_usdc, 0.50).unwrap_or(0.0);
-        let ev_net_usdc_p10 = percentile(&net_markout_10s_usdc, 0.10).unwrap_or(0.0);
-        let ev_positive_ratio = if net_markout_10s_usdc.is_empty() {
-            0.0
-        } else {
-            net_markout_10s_usdc.iter().filter(|v| **v > 0.0).count() as f64
-                / net_markout_10s_usdc.len() as f64
-        };
-        let (pnl_10s_filtered, pnl_10s_outlier_ratio) = robust_filter_iqr(&pnl_10s);
-        let pnl_10s_p50_robust = percentile(&pnl_10s_filtered, 0.50).unwrap_or(pnl_10s_p50_raw);
-        let pnl_10s_sample_count = pnl_10s.len();
-
-        let attempted = self.quote_attempted.load(Ordering::Relaxed);
-        let blocked = self.quote_blocked.load(Ordering::Relaxed);
-        let policy_blocked = self.policy_blocked.load(Ordering::Relaxed);
-        let eligible_count = self.eligible_count.load(Ordering::Relaxed);
-        let executed_count = self.executed_count.load(Ordering::Relaxed);
-        let executed_over_eligible = if eligible_count == 0 {
-            0.0
-        } else {
-            executed_count as f64 / eligible_count as f64
-        };
-        let quote_block_ratio = quote_block_ratio(attempted, blocked);
-        let policy_ratio = policy_block_ratio(attempted, policy_blocked);
-
-        let elapsed = self.started_at.read().await.elapsed();
-        let uptime_pct = self.uptime_pct(elapsed);
-        let tick_to_ack_p99 = percentile(&tick_to_ack_ms, 0.99).unwrap_or(0.0);
-        let scorecard = build_market_scorecard(&shots, &outcomes);
-        let ref_ticks_total = self.ref_ticks_total.load(Ordering::Relaxed);
-        let book_ticks_total = self.book_ticks_total.load(Ordering::Relaxed);
-        let now_ms = Utc::now().timestamp_millis();
-        let last_ref_tick_ms = self.last_ref_tick_ms.load(Ordering::Relaxed);
-        let last_book_tick_ms = self.last_book_tick_ms.load(Ordering::Relaxed);
-        let ref_freshness_ms = freshness_ms(now_ms, last_ref_tick_ms);
-        let book_freshness_ms = freshness_ms(now_ms, last_book_tick_ms);
-        let data_total = self.data_total.load(Ordering::Relaxed);
-        let data_invalid = self.data_invalid.load(Ordering::Relaxed);
-        let seq_gap = self.seq_gap.load(Ordering::Relaxed);
-        let ts_inversion = self.ts_inversion.load(Ordering::Relaxed);
-        let stale_tick_dropped = self.stale_tick_dropped.load(Ordering::Relaxed);
-        let data_valid_ratio = if data_total == 0 {
-            1.0
-        } else {
-            1.0 - (data_invalid as f64 / data_total as f64)
-        };
-        let seq_gap_rate = if data_total == 0 {
-            0.0
-        } else {
-            seq_gap as f64 / data_total as f64
-        };
-        let ts_inversion_rate = if data_total == 0 {
-            0.0
-        } else {
-            ts_inversion as f64 / data_total as f64
-        };
-        let stale_tick_drop_ratio = if data_total == 0 {
-            0.0
-        } else {
-            stale_tick_dropped as f64 / data_total as f64
-        };
-
-        let book_top_lag_p50_ms = percentile(&book_top_lag_ms, 0.50).unwrap_or(0.0);
-        let book_top_lag_p90_ms = percentile(&book_top_lag_ms, 0.90).unwrap_or(0.0);
-        let book_top_lag_p99_ms = percentile(&book_top_lag_ms, 0.99).unwrap_or(0.0);
-        let mut book_top_lag_by_symbol_p50_ms = HashMap::new();
-        for (sym, samples) in book_top_lag_by_symbol_ms {
-            book_top_lag_by_symbol_p50_ms.insert(sym, percentile(&samples, 0.50).unwrap_or(0.0));
-        }
-
-        let mut survival_10ms_by_symbol = HashMap::new();
-        let mut survival_counts: HashMap<String, (u64, u64)> = HashMap::new();
-        for o in &outcomes_primary_valid {
-            let o = *o;
-            let e = survival_counts.entry(o.symbol.clone()).or_insert((0, 0));
-            e.0 = e.0.saturating_add(1);
-            if o.survived {
-                e.1 = e.1.saturating_add(1);
-            }
-        }
-        for (sym, (n, s)) in survival_counts {
-            survival_10ms_by_symbol.insert(sym, if n == 0 { 0.0 } else { s as f64 / n as f64 });
-        }
-        let mut survival_probe_10ms_by_symbol = HashMap::new();
-        for (sym, c) in survival_probe_by_symbol {
-            survival_probe_10ms_by_symbol.insert(sym, c.ratio(10));
-        }
-
-        let latency = LatencyBreakdown {
-            feed_in_p50_ms: percentile(&feed_in_ms, 0.50).unwrap_or(0.0),
-            feed_in_p90_ms: percentile(&feed_in_ms, 0.90).unwrap_or(0.0),
-            feed_in_p99_ms: percentile(&feed_in_ms, 0.99).unwrap_or(0.0),
-            signal_p50_us: percentile(&signal_us, 0.50).unwrap_or(0.0),
-            signal_p90_us: percentile(&signal_us, 0.90).unwrap_or(0.0),
-            signal_p99_us: percentile(&signal_us, 0.99).unwrap_or(0.0),
-            quote_p50_us: percentile(&quote_us, 0.50).unwrap_or(0.0),
-            quote_p90_us: percentile(&quote_us, 0.90).unwrap_or(0.0),
-            quote_p99_us: percentile(&quote_us, 0.99).unwrap_or(0.0),
-            risk_p50_us: percentile(&risk_us, 0.50).unwrap_or(0.0),
-            risk_p90_us: percentile(&risk_us, 0.90).unwrap_or(0.0),
-            risk_p99_us: percentile(&risk_us, 0.99).unwrap_or(0.0),
-            decision_queue_wait_p50_ms: percentile(&decision_queue_wait_ms, 0.50).unwrap_or(0.0),
-            decision_queue_wait_p90_ms: percentile(&decision_queue_wait_ms, 0.90).unwrap_or(0.0),
-            decision_queue_wait_p99_ms: percentile(&decision_queue_wait_ms, 0.99).unwrap_or(0.0),
-            decision_compute_p50_ms: percentile(&decision_compute_ms, 0.50).unwrap_or(0.0),
-            decision_compute_p90_ms: percentile(&decision_compute_ms, 0.90).unwrap_or(0.0),
-            decision_compute_p99_ms: percentile(&decision_compute_ms, 0.99).unwrap_or(0.0),
-            tick_to_decision_p50_ms: percentile(&tick_to_decision_ms, 0.50).unwrap_or(0.0),
-            tick_to_decision_p90_ms: percentile(&tick_to_decision_ms, 0.90).unwrap_or(0.0),
-            tick_to_decision_p99_ms: percentile(&tick_to_decision_ms, 0.99).unwrap_or(0.0),
-            ack_only_p50_ms: percentile(&ack_only_ms, 0.50).unwrap_or(0.0),
-            ack_only_p90_ms: percentile(&ack_only_ms, 0.90).unwrap_or(0.0),
-            ack_only_p99_ms: percentile(&ack_only_ms, 0.99).unwrap_or(0.0),
-            tick_to_ack_p50_ms: percentile(&tick_to_ack_ms, 0.50).unwrap_or(0.0),
-            tick_to_ack_p90_ms: percentile(&tick_to_ack_ms, 0.90).unwrap_or(0.0),
-            tick_to_ack_p99_ms: tick_to_ack_p99,
-            parse_p99_us: percentile(&parse_us, 0.99).unwrap_or(0.0),
-            io_queue_p99_ms: percentile(&io_queue_depth, 0.99).unwrap_or(0.0),
-            bus_lag_p99_ms: percentile(&event_backlog, 0.99).unwrap_or(0.0),
-            shadow_fill_p50_ms: percentile(&shadow_fill_ms, 0.50).unwrap_or(0.0),
-            shadow_fill_p90_ms: percentile(&shadow_fill_ms, 0.90).unwrap_or(0.0),
-            shadow_fill_p99_ms: percentile(&shadow_fill_ms, 0.99).unwrap_or(0.0),
-            source_latency_p50_ms: percentile(&source_latency_ms, 0.50).unwrap_or(0.0),
-            source_latency_p90_ms: percentile(&source_latency_ms, 0.90).unwrap_or(0.0),
-            source_latency_p99_ms: percentile(&source_latency_ms, 0.99).unwrap_or(0.0),
-            local_backlog_p50_ms: percentile(&local_backlog_ms, 0.50).unwrap_or(0.0),
-            local_backlog_p90_ms: percentile(&local_backlog_ms, 0.90).unwrap_or(0.0),
-            local_backlog_p99_ms: percentile(&local_backlog_ms, 0.99).unwrap_or(0.0),
-        };
-
-        let mut live = ShadowLiveReport {
-            window_id: self.window_id.load(Ordering::Relaxed),
-            window_shots: shots.len(),
-            window_outcomes: outcomes.len(),
-            gate_ready: outcomes.len() >= Self::GATE_MIN_OUTCOMES,
-            gate_fail_reasons: Vec::new(),
-            observe_only: self.observe_only(),
-            started_at_ms: self.started_at_ms.load(Ordering::Relaxed),
-            elapsed_sec: elapsed.as_secs(),
-            total_shots: shots.len(),
-            total_outcomes: outcomes.len(),
-            data_valid_ratio,
-            seq_gap_rate,
-            ts_inversion_rate,
-            stale_tick_drop_ratio,
-            quote_attempted: attempted,
-            quote_blocked: blocked,
-            policy_blocked,
-            fillability_5ms: fillability_5,
-            fillability_10ms: fillability_10,
-            fillability_25ms: fillability_25,
-            survival_5ms: survival_5,
-            survival_10ms: survival_10,
-            survival_25ms: survival_25,
-            survival_probe_5ms: survival_probe_5,
-            survival_probe_10ms: survival_probe_10,
-            survival_probe_25ms: survival_probe_25,
-            survival_probe_5ms_n: survival_probe_5_n,
-            survival_probe_10ms_n: survival_probe_10_n,
-            survival_probe_25ms_n: survival_probe_25_n,
-            net_edge_p50_bps: net_edge_p50,
-            net_edge_p10_bps: net_edge_p10,
-            pnl_1s_p50_bps: pnl_1s_p50,
-            pnl_5s_p50_bps: pnl_5s_p50,
-            pnl_10s_p50_bps: pnl_10s_p50_raw,
-            pnl_10s_p50_bps_raw: pnl_10s_p50_raw,
-            pnl_10s_p50_bps_robust: pnl_10s_p50_robust,
-            net_markout_10s_usdc_p50,
-            roi_notional_10s_bps_p50,
-            pnl_10s_sample_count,
-            pnl_10s_outlier_ratio,
-            eligible_count,
-            executed_count,
-            executed_over_eligible,
-            ev_net_usdc_p50,
-            ev_net_usdc_p10,
-            ev_positive_ratio,
-            quote_block_ratio,
-            policy_block_ratio: policy_ratio,
-            queue_depth_p99: percentile(&queue_depth, 0.99).unwrap_or(0.0),
-            event_backlog_p99: percentile(&event_backlog, 0.99).unwrap_or(0.0),
-            tick_to_decision_p50_ms: latency.tick_to_decision_p50_ms,
-            tick_to_decision_p90_ms: latency.tick_to_decision_p90_ms,
-            tick_to_decision_p99_ms: latency.tick_to_decision_p99_ms,
-            decision_queue_wait_p99_ms: latency.decision_queue_wait_p99_ms,
-            decision_compute_p99_ms: latency.decision_compute_p99_ms,
-            source_latency_p99_ms: latency.source_latency_p99_ms,
-            local_backlog_p99_ms: latency.local_backlog_p99_ms,
-            ack_only_p50_ms: latency.ack_only_p50_ms,
-            ack_only_p90_ms: latency.ack_only_p90_ms,
-            ack_only_p99_ms: latency.ack_only_p99_ms,
-            strategy_uptime_pct: uptime_pct,
-            tick_to_ack_p99_ms: tick_to_ack_p99,
-            ref_ticks_total,
-            book_ticks_total,
-            ref_freshness_ms,
-            book_freshness_ms,
-            book_top_lag_p50_ms,
-            book_top_lag_p90_ms,
-            book_top_lag_p99_ms,
-            book_top_lag_by_symbol_p50_ms,
-            survival_10ms_by_symbol,
-            survival_probe_10ms_by_symbol,
-            blocked_reason_counts,
-            latency,
-            market_scorecard: scorecard,
-        };
-        live.gate_fail_reasons =
-            gate_eval::compute_gate_fail_reasons(&live, Self::GATE_MIN_OUTCOMES);
-        live.gate_ready = live.window_outcomes >= Self::GATE_MIN_OUTCOMES;
-        live
-    }
-
-    async fn build_final_report(&self) -> ShadowFinalReport {
-        let live = self.build_live_report().await;
-        let failed = live.gate_fail_reasons.clone();
-
-        let gate = GateEvaluation {
-            window_id: live.window_id,
-            gate_ready: live.gate_ready,
-            min_outcomes: Self::GATE_MIN_OUTCOMES,
-            pass: failed.is_empty(),
-            data_valid_ratio: live.data_valid_ratio,
-            seq_gap_rate: live.seq_gap_rate,
-            ts_inversion_rate: live.ts_inversion_rate,
-            stale_tick_drop_ratio: live.stale_tick_drop_ratio,
-            fillability_10ms: live.fillability_10ms,
-            net_edge_p50_bps: live.net_edge_p50_bps,
-            net_edge_p10_bps: live.net_edge_p10_bps,
-            net_markout_10s_usdc_p50: live.net_markout_10s_usdc_p50,
-            roi_notional_10s_bps_p50: live.roi_notional_10s_bps_p50,
-            pnl_10s_p50_bps_raw: live.pnl_10s_p50_bps_raw,
-            pnl_10s_p50_bps_robust: live.pnl_10s_p50_bps_robust,
-            pnl_10s_sample_count: live.pnl_10s_sample_count,
-            pnl_10s_outlier_ratio: live.pnl_10s_outlier_ratio,
-            eligible_count: live.eligible_count,
-            executed_count: live.executed_count,
-            executed_over_eligible: live.executed_over_eligible,
-            ev_net_usdc_p50: live.ev_net_usdc_p50,
-            ev_net_usdc_p10: live.ev_net_usdc_p10,
-            ev_positive_ratio: live.ev_positive_ratio,
-            quote_block_ratio: live.quote_block_ratio,
-            policy_block_ratio: live.policy_block_ratio,
-            strategy_uptime_pct: live.strategy_uptime_pct,
-            tick_to_ack_p99_ms: live.tick_to_ack_p99_ms,
-            decision_queue_wait_p99_ms: live.decision_queue_wait_p99_ms,
-            decision_compute_p99_ms: live.decision_compute_p99_ms,
-            source_latency_p99_ms: live.latency.source_latency_p99_ms,
-            local_backlog_p99_ms: live.latency.local_backlog_p99_ms,
-            failed_reasons: failed,
-        };
-        ShadowFinalReport { live, gate }
-    }
-
-    async fn build_engine_pnl_report(&self) -> EnginePnlReport {
-        const PRIMARY_DELAY_MS: u64 = 10;
-        let shots = self.shots.read().await.clone();
-        let outcomes = self.outcomes.read().await.clone();
-        let mut style_by_shot = HashMap::<String, ExecutionStyle>::new();
-        for shot in shots.iter().filter(|s| s.delay_ms == PRIMARY_DELAY_MS) {
-            style_by_shot.insert(shot.shot_id.clone(), shot.execution_style.clone());
-        }
-
-        let mut maker = Vec::<f64>::new();
-        let mut taker = Vec::<f64>::new();
-        let mut arb = Vec::<f64>::new();
-
-        for outcome in outcomes
-            .iter()
-            .filter(|o| o.delay_ms == PRIMARY_DELAY_MS && !o.is_stale_tick)
-        {
-            let Some(markout) = outcome.net_markout_10s_usdc else {
-                continue;
-            };
-            let style = style_by_shot
-                .get(&outcome.shot_id)
-                .cloned()
-                .unwrap_or_else(|| outcome.execution_style.clone());
-            match style {
-                ExecutionStyle::Maker => maker.push(markout),
-                ExecutionStyle::Taker => taker.push(markout),
-                ExecutionStyle::Arb => arb.push(markout),
-            }
-        }
-
-        let maker_total = maker.iter().sum::<f64>();
-        let taker_total = taker.iter().sum::<f64>();
-        let arb_total = arb.iter().sum::<f64>();
-
-        EnginePnlReport {
-            window_id: self.window_id.load(Ordering::Relaxed),
-            breakdown: EnginePnLBreakdown {
-                maker_usdc: maker_total,
-                taker_usdc: taker_total,
-                arb_usdc: arb_total,
-            },
-            rows: vec![
-                build_engine_pnl_row("maker", &maker),
-                build_engine_pnl_row("taker", &taker),
-                build_engine_pnl_row("arb", &arb),
-            ],
-        }
-    }
-}
-
-fn build_engine_pnl_row(engine: &str, values: &[f64]) -> EnginePnlRow {
-    let samples = values.len();
-    let total_usdc = values.iter().sum::<f64>();
-    let p50_usdc = percentile(values, 0.50).unwrap_or(0.0);
-    let p10_usdc = percentile(values, 0.10).unwrap_or(0.0);
-    let positive_ratio = if values.is_empty() {
-        0.0
-    } else {
-        values.iter().filter(|v| **v > 0.0).count() as f64 / values.len() as f64
-    };
-    EnginePnlRow {
-        engine: engine.to_string(),
-        samples,
-        total_usdc,
-        p50_usdc,
-        p10_usdc,
-        positive_ratio,
-    }
-}
+use bootstrap::{async_main, install_rustls_provider};
 
 fn main() -> Result<()> {
     install_rustls_provider();
@@ -1488,3747 +42,43 @@ fn main() -> Result<()> {
     runtime.block_on(async_main())
 }
 
-async fn async_main() -> Result<()> {
-    init_tracing("app_runner");
-    let prometheus = init_metrics();
-    ensure_dataset_dirs();
-
-    let execution_cfg = load_execution_config();
-    let universe_cfg = load_universe_config();
-    let bus = RingBus::new(16_384);
-    let portfolio = Arc::new(PortfolioBook::default());
-    let exec_mode = if execution_cfg.mode.eq_ignore_ascii_case("live") {
-        ExecutionMode::Live
-    } else {
-        ExecutionMode::Paper
-    };
-    let execution = Arc::new(ClobExecution::new_with_timeout(
-        exec_mode,
-        execution_cfg.clob_endpoint.clone(),
-        Duration::from_millis(execution_cfg.http_timeout_ms),
-    ));
-    let shadow = Arc::new(ShadowExecutor::default());
-    let strategy_cfg = Arc::new(RwLock::new(load_strategy_config()));
-    let fair_value_cfg = Arc::new(StdRwLock::new(load_fair_value_config()));
-    let toxicity_cfg = Arc::new(RwLock::new(ToxicityConfig::default()));
-    let risk_limits = Arc::new(StdRwLock::new(load_risk_limits_config()));
-    let perf_profile = Arc::new(RwLock::new(load_perf_profile_config()));
-    let allocator_cfg = {
-        let strategy = strategy_cfg.read().await.clone();
-        let tox = toxicity_cfg.read().await.clone();
-        Arc::new(RwLock::new(AllocatorConfig {
-            capital_fraction_kelly: strategy.capital_fraction_kelly,
-            variance_penalty_lambda: strategy.variance_penalty_lambda,
-            active_top_n_markets: tox.active_top_n_markets,
-            ..AllocatorConfig::default()
-        }))
-    };
-    let tox_state = Arc::new(RwLock::new(HashMap::new()));
-    let shadow_stats = Arc::new(ShadowStats::new());
-    let paused = Arc::new(RwLock::new(false));
-    let universe_symbols = Arc::new(universe_cfg.assets.clone());
-    let universe_market_types = Arc::new(universe_cfg.market_types.clone());
-    let universe_timeframes = Arc::new(universe_cfg.timeframes.clone());
-    init_jsonl_writer(perf_profile.clone()).await;
-
-    let state = AppState {
-        paused: paused.clone(),
-        bus: bus.clone(),
-        portfolio: portfolio.clone(),
-        execution: execution.clone(),
-        _shadow: shadow.clone(),
-        prometheus,
-        strategy_cfg: strategy_cfg.clone(),
-        fair_value_cfg: fair_value_cfg.clone(),
-        toxicity_cfg: toxicity_cfg.clone(),
-        allocator_cfg: allocator_cfg.clone(),
-        risk_limits: risk_limits.clone(),
-        tox_state: tox_state.clone(),
-        shadow_stats: shadow_stats.clone(),
-        perf_profile: perf_profile.clone(),
-    };
-
-    let scoring_rebate_factor = std::env::var("POLYEDGE_SCORING_REBATE_FACTOR")
-        .ok()
-        .and_then(|v| v.parse::<f64>().ok())
-        // Worst-case by default: assume no rebate unless we have hard evidence.
-        .unwrap_or(0.0)
-        .clamp(0.0, 1.0);
-
-    let risk_manager = Arc::new(DefaultRiskManager::new(risk_limits.clone()));
-    let shared = Arc::new(EngineShared {
-        latest_books: Arc::new(RwLock::new(HashMap::new())),
-        market_to_symbol: Arc::new(RwLock::new(HashMap::new())),
-        token_to_symbol: Arc::new(RwLock::new(HashMap::new())),
-        fee_cache: Arc::new(RwLock::new(HashMap::new())),
-        fee_refresh_inflight: Arc::new(RwLock::new(HashMap::new())),
-        scoring_cache: Arc::new(RwLock::new(HashMap::new())),
-        scoring_refresh_inflight: Arc::new(RwLock::new(HashMap::new())),
-        http: Client::new(),
-        clob_endpoint: execution_cfg.clob_endpoint.clone(),
-        strategy_cfg,
-        fair_value_cfg,
-        toxicity_cfg,
-        risk_manager,
-        universe_symbols: universe_symbols.clone(),
-        universe_market_types: universe_market_types.clone(),
-        universe_timeframes: universe_timeframes.clone(),
-        rate_limit_rps: execution_cfg.rate_limit_rps.max(0.1),
-        scoring_rebate_factor,
-        tox_state,
-        shadow_stats,
-    });
-
-    spawn_reference_feed(
-        bus.clone(),
-        shared.shadow_stats.clone(),
-        (*universe_symbols).clone(),
-    );
-    spawn_market_feed(
-        bus.clone(),
-        shared.shadow_stats.clone(),
-        (*universe_symbols).clone(),
-        (*universe_market_types).clone(),
-        (*universe_timeframes).clone(),
-    );
-    spawn_strategy_engine(
-        bus.clone(),
-        portfolio,
-        execution.clone(),
-        shadow,
-        paused.clone(),
-        shared.clone(),
-    );
-    orchestration::spawn_periodic_report_persistor(
-        shared.shadow_stats.clone(),
-        shared.tox_state.clone(),
-        execution.clone(),
-        shared.toxicity_cfg.clone(),
-    );
-    orchestration::spawn_data_reconcile_task(
-        bus.clone(),
-        paused.clone(),
-        shared.shadow_stats.clone(),
-    );
-
-    let app = control_api::build_router(state);
-
-    let addr: SocketAddr = "0.0.0.0:8080".parse()?;
-    tracing::info!(%addr, "control api started");
-    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
-    Ok(())
-}
-
-fn install_rustls_provider() {
-    let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
+#[inline]
+fn publish_if_telemetry_subscribers(bus: &RingBus<EngineEvent>, event: EngineEvent) {
+    if bus.receiver_count() > 1 {
+        let _ = bus.publish(event);
+    }
 }
 
-fn spawn_reference_feed(bus: RingBus<EngineEvent>, stats: Arc<ShadowStats>, symbols: Vec<String>) {
-    const TS_INVERSION_TOLERANCE_MS: i64 = 250;
+fn spawn_detached<F>(task_name: &'static str, report_normal_exit: bool, fut: F)
+where
+    F: Future<Output = ()> + Send + 'static,
+{
     tokio::spawn(async move {
-        let feed = MultiSourceRefFeed::new(Duration::from_millis(50));
-        if symbols.is_empty() {
-            tracing::warn!("reference feed symbols empty; using fallback BTCUSDT");
-        }
-        let symbols = if symbols.is_empty() {
-            vec!["BTCUSDT".to_string()]
-        } else {
-            symbols
-        };
-        let Ok(mut stream) = feed.stream_ticks(symbols).await else {
-            tracing::error!("reference feed failed to start");
-            return;
-        };
-        let mut ingest_seq: u64 = 0;
-        let mut last_source_ts_by_stream: HashMap<String, i64> = HashMap::new();
-
-        while let Some(item) = stream.next().await {
-            match item {
-                Ok(tick) => {
-                    ingest_seq = ingest_seq.saturating_add(1);
-                    let source_ts = tick.event_ts_exchange_ms.max(tick.event_ts_ms);
-                    let source_seq = source_ts.max(0) as u64;
-                    let valid = !tick.symbol.is_empty()
-                        && tick.price.is_finite()
-                        && tick.price > 0.0
-                        && source_seq > 0;
-                    stats.mark_data_validity(valid);
-                    let stream_key = format!("{}:{}", tick.source, tick.symbol);
-                    if let Some(prev) = last_source_ts_by_stream.get(&stream_key).copied() {
-                        if source_ts + TS_INVERSION_TOLERANCE_MS < prev {
-                            stats.mark_ts_inversion();
-                        }
-                    }
-                    last_source_ts_by_stream.insert(stream_key, source_ts);
-                    stats.mark_ref_tick(tick.recv_ts_ms);
-                    // Hot-path logging: avoid dynamic JSON trees + extra stringify passes.
-                    // Build a single JSONL line and hand it to the async writer.
-                    let tick_json =
-                        serde_json::to_string(&tick).unwrap_or_else(|_| "{}".to_string());
-                    let hash = sha256_hex(&tick_json);
-                    let line = format!(
-                        "{{\"ts_ms\":{},\"source_seq\":{},\"ingest_seq\":{},\"valid\":{},\"sha256\":\"{}\",\"tick\":{}}}",
-                        Utc::now().timestamp_millis(),
-                        source_seq,
-                        ingest_seq,
-                        valid,
-                        hash,
-                        tick_json
-                    );
-                    append_jsonl_line(&dataset_path("raw", "ref_ticks.jsonl"), line);
-                    if !valid {
-                        stats.record_issue("invalid_ref_tick").await;
-                        continue;
-                    }
-                    let _ = bus.publish(EngineEvent::RefTick(tick));
-                }
-                Err(err) => {
-                    tracing::warn!(?err, "reference feed event error");
+        match AssertUnwindSafe(fut).catch_unwind().await {
+            Ok(()) => {
+                if report_normal_exit {
+                    tracing::warn!(task = task_name, "detached task exited");
                 }
             }
-        }
-    });
-}
-
-fn spawn_market_feed(
-    bus: RingBus<EngineEvent>,
-    stats: Arc<ShadowStats>,
-    symbols: Vec<String>,
-    market_types: Vec<String>,
-    timeframes: Vec<String>,
-) {
-    const TS_INVERSION_TOLERANCE_MS: i64 = 250;
-    tokio::spawn(async move {
-        let feed = PolymarketFeed::new_with_universe(
-            Duration::from_millis(50),
-            symbols,
-            market_types,
-            timeframes,
-        );
-        let Ok(mut stream) = feed.stream_books().await else {
-            tracing::error!("market feed failed to start");
-            return;
-        };
-        let mut ingest_seq: u64 = 0;
-        let mut last_source_ts_by_market: HashMap<String, i64> = HashMap::new();
-
-        while let Some(item) = stream.next().await {
-            match item {
-                Ok(book) => {
-                    ingest_seq = ingest_seq.saturating_add(1);
-                    let source_ts = book.ts_ms;
-                    let source_seq = source_ts.max(0) as u64;
-                    let valid = !book.market_id.is_empty()
-                        && book.bid_yes.is_finite()
-                        && book.ask_yes.is_finite()
-                        && book.bid_no.is_finite()
-                        && book.ask_no.is_finite()
-                        && source_seq > 0;
-                    stats.mark_data_validity(valid);
-                    if let Some(prev) = last_source_ts_by_market.get(&book.market_id).copied() {
-                        if source_ts + TS_INVERSION_TOLERANCE_MS < prev {
-                            stats.mark_ts_inversion();
-                        }
-                    }
-                    last_source_ts_by_market.insert(book.market_id.clone(), source_ts);
-                    stats.mark_book_tick(book.ts_ms);
-                    let book_json =
-                        serde_json::to_string(&book).unwrap_or_else(|_| "{}".to_string());
-                    let hash = sha256_hex(&book_json);
-                    let line = format!(
-                        "{{\"ts_ms\":{},\"source_seq\":{},\"ingest_seq\":{},\"valid\":{},\"sha256\":\"{}\",\"book\":{}}}",
-                        Utc::now().timestamp_millis(),
-                        source_seq,
-                        ingest_seq,
-                        valid,
-                        hash,
-                        book_json
-                    );
-                    append_jsonl_line(&dataset_path("raw", "book_tops.jsonl"), line);
-                    if !valid {
-                        stats.record_issue("invalid_book_top").await;
-                        continue;
-                    }
-                    let _ = bus.publish(EngineEvent::BookTop(book));
-                }
-                Err(err) => {
-                    tracing::warn!(?err, "market feed event error");
-                }
+            Err(payload) => {
+                let panic_msg = if let Some(msg) = payload.downcast_ref::<&str>() {
+                    (*msg).to_string()
+                } else if let Some(msg) = payload.downcast_ref::<String>() {
+                    msg.clone()
+                } else {
+                    "unknown panic payload".to_string()
+                };
+                tracing::error!(task = task_name, panic = %panic_msg, "detached task panicked");
+                metrics::counter!("runtime.detached_task_panic").increment(1);
             }
         }
     });
 }
 
-fn spawn_strategy_engine(
-    bus: RingBus<EngineEvent>,
-    portfolio: Arc<PortfolioBook>,
-    execution: Arc<ClobExecution>,
-    shadow: Arc<ShadowExecutor>,
-    paused: Arc<RwLock<bool>>,
-    shared: Arc<EngineShared>,
-) {
-    tokio::spawn(async move {
-        let fair = BasisMrFairValue::new(shared.fair_value_cfg.clone());
-        // Separate fast reference ticks (exchange WS) from anchor ticks (Chainlink RTDS).
-        // Fast ticks drive stale filtering + fair value evaluation; anchor ticks are tracked for
-        // auditing/diagnostics so the trigger stays latency-sensitive.
-        let mut latest_fast_ticks: HashMap<String, RefTick> = HashMap::new();
-        let mut latest_anchor_ticks: HashMap<String, RefTick> = HashMap::new();
-        let mut market_inventory: HashMap<String, InventoryState> = HashMap::new();
-        let mut market_rate_budget: HashMap<String, TokenBucket> = HashMap::new();
-        let mut untracked_issue_cooldown: HashMap<String, Instant> = HashMap::new();
-        let mut book_lag_sample_at: HashMap<String, Instant> = HashMap::new();
-        let mut global_rate_budget = TokenBucket::new(
-            shared.rate_limit_rps,
-            (shared.rate_limit_rps * 2.0).max(1.0),
-        );
-        let mut rx = bus.subscribe();
-        let mut last_discovery_refresh = Instant::now() - Duration::from_secs(3600);
-        let mut last_symbol_retry_refresh = Instant::now() - Duration::from_secs(3600);
-        refresh_market_symbol_map(&shared).await;
-
-        loop {
-            if last_discovery_refresh.elapsed() >= Duration::from_secs(300) {
-                refresh_market_symbol_map(&shared).await;
-                last_discovery_refresh = Instant::now();
-            }
-
-            let recv = rx.recv().await;
-            let Ok(event) = recv else {
-                continue;
-            };
-            let dispatch_start = Instant::now();
-
-            match event {
-                EngineEvent::RefTick(tick) => {
-                    let parse_us = dispatch_start.elapsed().as_secs_f64() * 1_000_000.0;
-                    shared.shadow_stats.push_parse_us(parse_us).await;
-                    insert_latest_ref_tick(&mut latest_fast_ticks, &mut latest_anchor_ticks, tick);
-                }
-                EngineEvent::BookTop(mut book) => {
-                    let parse_us = dispatch_start.elapsed().as_secs_f64() * 1_000_000.0;
-                    shared.shadow_stats.push_parse_us(parse_us).await;
-                    // Coalesce bursty queue traffic to the freshest observable state.
-                    // This trims local backlog and avoids spending cycles on superseded snapshots.
-                    let mut coalesced = 0_u64;
-                    let dynamic_cap = rx.len().saturating_add(64).min(4_096);
-                    let max_coalesced = dynamic_cap.max(256);
-                    while coalesced < max_coalesced as u64 {
-                        match rx.try_recv() {
-                            Ok(EngineEvent::BookTop(next_book)) => {
-                                book = next_book;
-                                coalesced += 1;
-                            }
-                            Ok(EngineEvent::RefTick(next_tick)) => {
-                                insert_latest_ref_tick(
-                                    &mut latest_fast_ticks,
-                                    &mut latest_anchor_ticks,
-                                    next_tick,
-                                );
-                                coalesced += 1;
-                            }
-                            Ok(_) => {
-                                // This subscriber doesn't consume other event kinds.
-                                // Drain them here to keep queue pressure bounded.
-                                coalesced += 1;
-                            }
-                            Err(tokio::sync::broadcast::error::TryRecvError::Empty) => break,
-                            Err(tokio::sync::broadcast::error::TryRecvError::Lagged(_)) => {
-                                shared.shadow_stats.record_issue("bus_lagged").await;
-                                break;
-                            }
-                            Err(tokio::sync::broadcast::error::TryRecvError::Closed) => break,
-                        }
-                    }
-                    if coalesced > 0 {
-                        metrics::counter!("runtime.coalesced_events").increment(coalesced);
-                    }
-
-                    let backlog_depth = rx.len() as f64;
-                    shared.shadow_stats.push_event_backlog(backlog_depth).await;
-                    metrics::histogram!("runtime.event_backlog_depth").record(backlog_depth);
-                    let queue_depth = execution.open_orders_count() as f64;
-                    shared.shadow_stats.push_queue_depth(queue_depth).await;
-                    metrics::histogram!("runtime.open_order_depth").record(queue_depth);
-                    let io_depth = current_jsonl_queue_depth() as f64;
-                    shared.shadow_stats.push_io_queue_depth(io_depth).await;
-                    metrics::histogram!("runtime.jsonl_queue_depth").record(io_depth);
-                    shared
-                        .latest_books
-                        .write()
-                        .await
-                        .insert(book.market_id.clone(), book.clone());
-
-                    let fills = shadow.on_book(&book);
-                    shared.shadow_stats.mark_filled(fills.len() as u64);
-                    for fill in fills {
-                        portfolio.apply_fill(&fill);
-                        let _ = bus.publish(EngineEvent::Fill(fill.clone()));
-                        let ingest_seq = next_normalized_ingest_seq();
-                        append_jsonl(
-                            &dataset_path("normalized", "fills.jsonl"),
-                            &serde_json::json!({
-                                "ts_ms": Utc::now().timestamp_millis(),
-                                "source_seq": Utc::now().timestamp_millis().max(0) as u64,
-                                "ingest_seq": ingest_seq,
-                                "fill": fill
-                            }),
-                        );
-                    }
-
-                    if *paused.read().await {
-                        shared.shadow_stats.record_issue("paused").await;
-                        continue;
-                    }
-                    if shared.shadow_stats.observe_only() {
-                        shared.shadow_stats.record_issue("observe_only").await;
-                        continue;
-                    }
-
-                    let symbol = pick_market_symbol(&shared, &book).await;
-                    let Some(symbol) = symbol else {
-                        if market_is_tracked(&shared, &book).await {
-                            {
-                                let mut states = shared.tox_state.write().await;
-                                let st = states.entry(book.market_id.clone()).or_default();
-                                st.symbol_missing = st.symbol_missing.saturating_add(1);
-                            }
-                            shared.shadow_stats.record_issue("symbol_missing").await;
-                        } else {
-                            let now = Instant::now();
-                            let should_record = untracked_issue_cooldown
-                                .get(&book.market_id)
-                                .map(|last| last.elapsed() >= Duration::from_secs(60))
-                                .unwrap_or(true);
-                            if should_record {
-                                shared.shadow_stats.record_issue("market_untracked").await;
-                                untracked_issue_cooldown.insert(book.market_id.clone(), now);
-                            }
-                        }
-                        if last_symbol_retry_refresh.elapsed() >= Duration::from_secs(15) {
-                            refresh_market_symbol_map(&shared).await;
-                            last_symbol_retry_refresh = Instant::now();
-                        }
-                        continue;
-                    };
-                    let tick_fast = pick_latest_tick(&latest_fast_ticks, &symbol);
-                    let Some(tick_fast) = tick_fast else {
-                        shared.shadow_stats.record_issue("tick_missing").await;
-                        continue;
-                    };
-                    let tick_anchor = pick_latest_tick(&latest_anchor_ticks, &symbol);
-                    if let Some(anchor) = tick_anchor {
-                        let now_ms = Utc::now().timestamp_millis();
-                        let age_ms = now_ms - ref_event_ts_ms(anchor);
-                        if age_ms > 5_000 {
-                            shared.shadow_stats.record_issue("anchor_stale").await;
-                        }
-                    } else {
-                        shared.shadow_stats.record_issue("anchor_missing").await;
-                    }
-                    // For latency-sensitive trading, evaluate fair value on the fastest observable
-                    // reference tick. The Chainlink anchor is tracked for correctness auditing and
-                    // can be used for future calibration, but should not slow down the trigger.
-                    let eval_tick = tick_fast;
-                    shared.shadow_stats.mark_seen();
-
-                    // Positive value means: our fast reference tick arrived earlier than the
-                    // Polymarket book update (i.e. the exploitable lag window).
-                    //
-                    // Guardrail: if the tick is already old, this is not a meaningful "lag window"
-                    // measurement and would inflate p50/p99. We only sample when the tick is fresh.
-                    let tick_age_ms = freshness_ms(Utc::now().timestamp_millis(), tick_fast.recv_ts_ms);
-                    let book_top_lag_ms = if tick_age_ms <= 1_500
-                        && tick_fast.recv_ts_local_ns > 0
-                        && book.recv_ts_local_ns > 0
-                    {
-                        ((book.recv_ts_local_ns - tick_fast.recv_ts_local_ns).max(0) as f64)
-                            / 1_000_000.0
-                    } else {
-                        0.0
-                    };
-                    let should_sample_book_lag = book_lag_sample_at
-                        .get(&symbol)
-                        .map(|t| t.elapsed() >= Duration::from_millis(200))
-                        .unwrap_or(true);
-                    if should_sample_book_lag {
-                        book_lag_sample_at.insert(symbol.clone(), Instant::now());
-                        shared
-                            .shadow_stats
-                            .push_book_top_lag_ms(&symbol, book_top_lag_ms)
-                            .await;
-                    }
-
-                    let latency_sample = estimate_feed_latency(tick_fast, &book);
-                    let feed_in_ms = latency_sample.feed_in_ms;
-                    let stale_tick_filter_ms =
-                        shared.strategy_cfg.read().await.stale_tick_filter_ms;
-                    if feed_in_ms > stale_tick_filter_ms {
-                        shared.shadow_stats.mark_stale_tick_dropped();
-                        shared.shadow_stats.record_issue("stale_tick_dropped").await;
-                        continue;
-                    }
-                    shared.shadow_stats.push_feed_in_ms(feed_in_ms).await;
-                    shared
-                        .shadow_stats
-                        .push_source_latency_ms(latency_sample.source_latency_ms)
-                        .await;
-                    shared
-                        .shadow_stats
-                        .push_local_backlog_ms(latency_sample.local_backlog_ms)
-                        .await;
-                    shared
-                        .shadow_stats
-                        .push_decision_queue_wait_ms(latency_sample.local_backlog_ms)
-                        .await;
-                    metrics::histogram!("latency.feed_in_ms").record(feed_in_ms);
-                    metrics::histogram!("latency.source_latency_ms")
-                        .record(latency_sample.source_latency_ms);
-                    metrics::histogram!("latency.local_backlog_ms")
-                        .record(latency_sample.local_backlog_ms);
-                    let signal_start = Instant::now();
-                    let signal = fair.evaluate(eval_tick, &book);
-                    if signal.edge_bps_bid > 0.0 || signal.edge_bps_ask > 0.0 {
-                        shared.shadow_stats.mark_candidate();
-                    }
-                    let signal_us = signal_start.elapsed().as_secs_f64() * 1_000_000.0;
-                    shared.shadow_stats.push_signal_us(signal_us).await;
-                    metrics::histogram!("latency.signal_us").record(signal_us);
-                    let _ = bus.publish(EngineEvent::Signal(signal.clone()));
-                    if should_sample_book_lag && book_top_lag_ms >= 5.0 {
-                        // "Orderless" survival probe: measure whether an observed top-of-book
-                        // price survives for +Œî ms, independent of order placement.
-                        let mid_yes = (book.bid_yes + book.ask_yes) * 0.5;
-                        let probe_side = if signal.fair_yes >= mid_yes {
-                            OrderSide::BuyYes
-                        } else {
-                            OrderSide::BuyNo
-                        };
-                        let probe_px = aggressive_price_for_side(&book, &probe_side);
-                        if probe_px > 0.0 {
-                            for delay_ms in [5_u64, 10_u64, 25_u64] {
-                                spawn_survival_probe_task(
-                                    shared.clone(),
-                                    book.market_id.clone(),
-                                    symbol.clone(),
-                                    probe_side.clone(),
-                                    probe_px,
-                                    delay_ms,
-                                );
-                            }
-                        }
-                    }
-
-                    let cfg = shared.strategy_cfg.read().await.clone();
-                    let tox_cfg = shared.toxicity_cfg.read().await.clone();
-                    let quote_start = Instant::now();
-                    let inventory = market_inventory
-                        .entry(book.market_id.clone())
-                        .or_insert_with(|| inventory_for_market(&portfolio, &book.market_id))
-                        .clone();
-                    let pending_market_exposure =
-                        execution.open_order_notional_for_market(&book.market_id);
-                    let pending_total_exposure = execution.open_order_notional_total();
-
-                    let (
-                        tox_features,
-                        tox_decision,
-                        market_score,
-                        pending_exposure,
-                        no_quote_rate,
-                        symbol_missing_rate,
-                        markout_samples,
-                        markout_10s_p50,
-                        markout_10s_p25,
-                        active_by_rank,
-                    ) = {
-                        let mut states = shared.tox_state.write().await;
-                        let (
-                            features,
-                            decision,
-                            score,
-                            pending_exposure,
-                            no_quote_rate,
-                            symbol_missing_rate,
-                            markout_samples,
-                            markout_10s_p50,
-                            markout_10s_p25,
-                        ) = {
-                            let st = states.entry(book.market_id.clone()).or_default();
-                            st.attempted = st.attempted.saturating_add(1);
-                            st.symbol = symbol.clone();
-
-                            let features = build_toxic_features(
-                                &book,
-                                &symbol,
-                                feed_in_ms,
-                                signal.fair_yes,
-                                st,
-                            );
-                            let mut decision = evaluate_toxicity(&features, &tox_cfg);
-                            let score_scale = (tox_cfg.k_spread / 1.5).clamp(0.25, 4.0);
-                            decision.tox_score = (decision.tox_score * score_scale).clamp(0.0, 1.0);
-                            decision.regime = if decision.tox_score >= tox_cfg.caution_threshold {
-                                ToxicRegime::Danger
-                            } else if decision.tox_score >= tox_cfg.safe_threshold {
-                                ToxicRegime::Caution
-                            } else {
-                                ToxicRegime::Safe
-                            };
-                            let now_ms = Utc::now().timestamp_millis();
-
-                            if now_ms < st.cooldown_until_ms {
-                                decision.regime = ToxicRegime::Danger;
-                                decision.reason_codes.push("cooldown_active".to_string());
-                            }
-                            if matches!(decision.regime, ToxicRegime::Danger) {
-                                let cool = cooldown_secs_for_score(decision.tox_score, &tox_cfg);
-                                st.cooldown_until_ms =
-                                    st.cooldown_until_ms.max(now_ms + (cool as i64) * 1_000);
-                            }
-                            let markout_samples = st
-                                .markout_1s
-                                .len()
-                                .max(st.markout_5s.len())
-                                .max(st.markout_10s.len());
-                            if markout_samples < 20 {
-                                decision.tox_score =
-                                    decision.tox_score.min(tox_cfg.safe_threshold * 0.8);
-                                decision.regime = ToxicRegime::Safe;
-                                decision
-                                    .reason_codes
-                                    .push("warmup_samples_lt_20".to_string());
-                            }
-                            st.last_tox_score = decision.tox_score;
-                            st.last_regime = decision.regime.clone();
-                            let score =
-                                compute_market_score(st, decision.tox_score, markout_samples);
-                            let markout_10s_p50 =
-                                percentile_deque(&st.markout_10s, 0.50).unwrap_or(0.0);
-                            let markout_10s_p25 =
-                                percentile_deque(&st.markout_10s, 0.25).unwrap_or(0.0);
-                            let pending_exposure = pending_market_exposure;
-                            let attempted = st.attempted.max(1);
-                            let no_quote_rate = st.no_quote as f64 / attempted as f64;
-                            let symbol_missing_rate = st.symbol_missing as f64 / attempted as f64;
-                            (
-                                features,
-                                decision,
-                                score,
-                                pending_exposure,
-                                no_quote_rate,
-                                symbol_missing_rate,
-                                markout_samples,
-                                markout_10s_p50,
-                                markout_10s_p25,
-                            )
-                        };
-                        let active_by_rank = is_market_in_top_n(
-                            &states,
-                            &book.market_id,
-                            tox_cfg.active_top_n_markets,
-                        );
-                        (
-                            features,
-                            decision,
-                            score,
-                            pending_exposure,
-                            no_quote_rate,
-                            symbol_missing_rate,
-                            markout_samples,
-                            markout_10s_p50,
-                            markout_10s_p25,
-                            active_by_rank,
-                        )
-                    };
-                    let spread_yes = (book.ask_yes - book.bid_yes).max(0.0);
-                    let window_outcomes = shared.shadow_stats.window_outcomes_len().await;
-                    let effective_min_edge_bps = adaptive_min_edge_bps(
-                        cfg.min_edge_bps,
-                        tox_decision.tox_score,
-                        markout_samples,
-                        no_quote_rate,
-                        markout_10s_p50,
-                        markout_10s_p25,
-                        window_outcomes,
-                        ShadowStats::GATE_MIN_OUTCOMES,
-                    );
-                    let effective_max_spread = adaptive_max_spread(
-                        cfg.max_spread,
-                        tox_decision.tox_score,
-                        markout_samples,
-                    );
-                    if should_observe_only_symbol(
-                        &symbol,
-                        &cfg,
-                        &tox_decision,
-                        feed_in_ms,
-                        spread_yes,
-                        book_top_lag_ms,
-                    ) {
-                        shared
-                            .shadow_stats
-                            .mark_blocked_with_reason("symbol_quality_guard")
-                            .await;
-                        continue;
-                    }
-                    let queue_fill_proxy =
-                        estimate_queue_fill_proxy(tox_decision.tox_score, spread_yes, feed_in_ms);
-
-                    if spread_yes > effective_max_spread {
-                        {
-                            let mut states = shared.tox_state.write().await;
-                            let st = states.entry(book.market_id.clone()).or_default();
-                            st.no_quote = st.no_quote.saturating_add(1);
-                        }
-                        shared
-                            .shadow_stats
-                            .mark_blocked_with_reason("no_quote_spread")
-                            .await;
-                        continue;
-                    }
-                    if signal.confidence <= 0.0 {
-                        {
-                            let mut states = shared.tox_state.write().await;
-                            let st = states.entry(book.market_id.clone()).or_default();
-                            st.no_quote = st.no_quote.saturating_add(1);
-                        }
-                        shared
-                            .shadow_stats
-                            .mark_blocked_with_reason("no_quote_confidence")
-                            .await;
-                        continue;
-                    }
-
-                    let _ = bus.publish(EngineEvent::ToxicFeatures(tox_features.clone()));
-                    let _ = bus.publish(EngineEvent::ToxicDecision(tox_decision.clone()));
-                    let ingest_seq_features = next_normalized_ingest_seq();
-                    append_jsonl(
-                        &dataset_path("normalized", "tox_features.jsonl"),
-                        &serde_json::json!({
-                            "ts_ms": Utc::now().timestamp_millis(),
-                            "source_seq": book.ts_ms.max(0) as u64,
-                            "ingest_seq": ingest_seq_features,
-                            "features": tox_features
-                        }),
-                    );
-                    let ingest_seq_decisions = next_normalized_ingest_seq();
-                    append_jsonl(
-                        &dataset_path("normalized", "tox_decisions.jsonl"),
-                        &serde_json::json!({
-                            "ts_ms": Utc::now().timestamp_millis(),
-                            "source_seq": book.ts_ms.max(0) as u64,
-                            "ingest_seq": ingest_seq_decisions,
-                            "decision": tox_decision
-                        }),
-                    );
-                    let market_health = MarketHealth {
-                        market_id: book.market_id.clone(),
-                        symbol: symbol.clone(),
-                        symbol_missing_rate,
-                        no_quote_rate,
-                        pending_exposure,
-                        queue_fill_proxy,
-                        ts_ns: now_ns(),
-                    };
-                    let ingest_seq_health = next_normalized_ingest_seq();
-                    append_jsonl(
-                        &dataset_path("normalized", "market_health.jsonl"),
-                        &serde_json::json!({
-                            "ts_ms": Utc::now().timestamp_millis(),
-                            "source_seq": book.ts_ms.max(0) as u64,
-                            "ingest_seq": ingest_seq_health,
-                            "health": market_health
-                        }),
-                    );
-
-                    if market_score < tox_cfg.min_market_score {
-                        shared
-                            .shadow_stats
-                            .mark_blocked_with_reason("market_score_low")
-                            .await;
-                        continue;
-                    }
-                    if !active_by_rank {
-                        shared
-                            .shadow_stats
-                            .mark_blocked_with_reason("market_rank_blocked")
-                            .await;
-                        continue;
-                    }
-
-                    let mut effective_cfg = cfg.clone();
-                    effective_cfg.min_edge_bps = effective_min_edge_bps;
-                    let policy = MakerQuotePolicy::new(effective_cfg);
-                    let mut intents =
-                        policy.build_quotes_with_toxicity(&signal, &inventory, &tox_decision);
-                    if !intents.is_empty() {
-                        let markout_dispersion = (markout_10s_p50 - markout_10s_p25).abs();
-                        let var_penalty = (cfg.variance_penalty_lambda
-                            * (markout_dispersion / 200.0).clamp(0.0, 1.0))
-                        .clamp(0.0, 0.90);
-                        let kelly_scale =
-                            (cfg.capital_fraction_kelly * signal.confidence * (1.0 - var_penalty))
-                                .clamp(0.05, 1.0);
-                        for intent in &mut intents {
-                            intent.size = (intent.size * kelly_scale).max(0.01);
-                        }
-                    }
-                    if !intents.is_empty() {
-                        shared.shadow_stats.mark_quoted(intents.len() as u64);
-                    }
-                    let quote_us = quote_start.elapsed().as_secs_f64() * 1_000_000.0;
-                    shared.shadow_stats.push_quote_us(quote_us).await;
-                    metrics::histogram!("latency.quote_us").record(quote_us);
-
-                    if intents.is_empty() {
-                        {
-                            let mut states = shared.tox_state.write().await;
-                            let st = states.entry(book.market_id.clone()).or_default();
-                            st.no_quote = st.no_quote.saturating_add(1);
-                        }
-                        let edge_blocked = signal.edge_bps_bid < effective_min_edge_bps
-                            && signal.edge_bps_ask < effective_min_edge_bps;
-                        if edge_blocked {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("no_quote_edge")
-                                .await;
-                        } else {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("no_quote_policy")
-                                .await;
-                        }
-                        continue;
-                    }
-
-                    let fee_bps = get_fee_rate_bps_cached(&shared, &book.market_id).await;
-                    let drawdown = portfolio.snapshot().max_drawdown_pct;
-
-                    for mut intent in intents.drain(..) {
-                        let intent_decision_start = Instant::now();
-                        shared.shadow_stats.mark_attempted();
-
-                        let risk_start = Instant::now();
-                        let proposed_notional_usdc =
-                            (intent.price.max(0.0) * intent.size.max(0.0)).max(0.0);
-                        let ctx = RiskContext {
-                            market_id: intent.market_id.clone(),
-                            symbol: symbol.clone(),
-                            order_count: execution.open_orders_count(),
-                            proposed_size: intent.size,
-                            proposed_notional_usdc,
-                            market_notional: inventory.exposure_notional + pending_market_exposure,
-                            asset_notional: inventory.exposure_notional + pending_total_exposure,
-                            drawdown_pct: drawdown,
-                            loss_streak: shared.shadow_stats.loss_streak(),
-                            now_ms: Utc::now().timestamp_millis(),
-                        };
-                        let decision = shared.risk_manager.evaluate(&ctx);
-                        let risk_us = risk_start.elapsed().as_secs_f64() * 1_000_000.0;
-                        shared.shadow_stats.push_risk_us(risk_us).await;
-                        metrics::histogram!("latency.risk_us").record(risk_us);
-
-                        if !decision.allow {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason(&format!("risk:{}", decision.reason))
-                                .await;
-                            metrics::counter!("strategy.blocked").increment(1);
-                            continue;
-                        }
-                        if decision.capped_size <= 0.0 {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("risk_capped_zero")
-                                .await;
-                            metrics::counter!("strategy.blocked").increment(1);
-                            continue;
-                        }
-                        intent.size = intent.size.min(decision.capped_size);
-
-                        let edge_gross = edge_for_intent(signal.fair_yes, &intent);
-                        let rebate_est_bps =
-                            get_rebate_bps_cached(&shared, &book.market_id, fee_bps).await;
-                        let edge_net = edge_gross - fee_bps + rebate_est_bps;
-                        if edge_net < effective_min_edge_bps {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("edge_below_threshold")
-                                .await;
-                            continue;
-                        }
-                        let intended_notional_usdc =
-                            (intent.price.max(0.0) * intent.size.max(0.0)).max(0.0);
-                        if intended_notional_usdc < cfg.min_eval_notional_usdc {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("tiny_notional")
-                                .await;
-                            continue;
-                        }
-                        let edge_net_usdc = (edge_net / 10_000.0) * intended_notional_usdc;
-                        if edge_net_usdc < cfg.min_expected_edge_usdc {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("edge_notional_too_small")
-                                .await;
-                            continue;
-                        }
-
-                        let mut force_taker = false;
-                        if should_force_taker(
-                            &cfg,
-                            &tox_decision,
-                            edge_net,
-                            signal.confidence,
-                            markout_samples,
-                            no_quote_rate,
-                            window_outcomes,
-                            ShadowStats::GATE_MIN_OUTCOMES,
-                            &symbol,
-                        ) {
-                            let aggressive_price = aggressive_price_for_side(&book, &intent.side);
-                            let passive_price = intent.price.max(1e-6);
-                            let price_move_bps = ((aggressive_price - intent.price).abs()
-                                / passive_price)
-                                * 10_000.0;
-                            let taker_slippage_budget = adaptive_taker_slippage_bps(
-                                cfg.taker_max_slippage_bps,
-                                &cfg.market_tier_profile,
-                                &symbol,
-                                markout_samples,
-                                no_quote_rate,
-                                window_outcomes,
-                                ShadowStats::GATE_MIN_OUTCOMES,
-                            );
-                            if price_move_bps <= taker_slippage_budget {
-                                intent.price = aggressive_price;
-                                intent.ttl_ms = intent.ttl_ms.min(150);
-                                force_taker = true;
-                            } else {
-                                shared
-                                    .shadow_stats
-                                    .mark_blocked_with_reason("taker_slippage_budget")
-                                    .await;
-                                continue;
-                            }
-                        }
-                        let per_market_rps = (shared.rate_limit_rps / 8.0).max(0.5);
-                        let market_bucket = market_rate_budget
-                            .entry(book.market_id.clone())
-                            .or_insert_with(|| {
-                                TokenBucket::new(per_market_rps, (per_market_rps * 2.0).max(1.0))
-                            });
-                        if !global_rate_budget.try_take(1.0) {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("rate_budget_global")
-                                .await;
-                            continue;
-                        }
-                        if !market_bucket.try_take(1.0) {
-                            shared
-                                .shadow_stats
-                                .mark_blocked_with_reason("rate_budget_market")
-                                .await;
-                            continue;
-                        }
-                        shared.shadow_stats.mark_eligible();
-
-                        let decision_compute_ms =
-                            intent_decision_start.elapsed().as_secs_f64() * 1_000.0;
-                        let tick_to_decision_ms =
-                            latency_sample.local_backlog_ms + decision_compute_ms;
-                        let place_start = Instant::now();
-                        let execution_style = if force_taker {
-                            ExecutionStyle::Taker
-                        } else {
-                            classify_execution_style(&book, &intent)
-                        };
-                        let tif = match execution_style {
-                            ExecutionStyle::Maker => OrderTimeInForce::PostOnly,
-                            ExecutionStyle::Taker | ExecutionStyle::Arb => OrderTimeInForce::Fak,
-                        };
-                        let v2_intent = OrderIntentV2 {
-                            market_id: intent.market_id.clone(),
-                            side: intent.side.clone(),
-                            price: intent.price,
-                            size: intent.size,
-                            ttl_ms: intent.ttl_ms,
-                            style: execution_style.clone(),
-                            tif,
-                            max_slippage_bps: cfg.taker_max_slippage_bps,
-                            fee_rate_bps: fee_bps,
-                            expected_edge_net_bps: edge_net,
-                            hold_to_resolution: false,
-                        };
-                        match execution.place_order_v2(v2_intent).await {
-                            Ok(ack_v2) if ack_v2.accepted => {
-                                let accepted_size = ack_v2.accepted_size.max(0.0).min(intent.size);
-                                if accepted_size <= 0.0 {
-                                    shared
-                                        .shadow_stats
-                                        .mark_blocked_with_reason("exchange_reject_zero_size")
-                                        .await;
-                                    continue;
-                                }
-                                intent.size = accepted_size;
-                                shared.shadow_stats.mark_executed();
-                                if execution.is_live() && execution_style == ExecutionStyle::Maker {
-                                    maybe_spawn_scoring_refresh(
-                                        &shared,
-                                        &book.market_id,
-                                        &ack_v2.order_id,
-                                        fee_bps,
-                                        Instant::now(),
-                                        Duration::from_secs(2),
-                                    )
-                                    .await;
-                                }
-                                let ack_only_ms = if ack_v2.exchange_latency_ms > 0.0 {
-                                    ack_v2.exchange_latency_ms
-                                } else {
-                                    place_start.elapsed().as_secs_f64() * 1_000.0
-                                };
-                                let tick_to_ack_ms = tick_to_decision_ms + ack_only_ms;
-                                shared
-                                    .shadow_stats
-                                    .push_decision_compute_ms(decision_compute_ms)
-                                    .await;
-                                shared
-                                    .shadow_stats
-                                    .push_tick_to_decision_ms(tick_to_decision_ms)
-                                    .await;
-                                shared.shadow_stats.push_ack_only_ms(ack_only_ms).await;
-                                shared
-                                    .shadow_stats
-                                    .push_tick_to_ack_ms(tick_to_ack_ms)
-                                    .await;
-                                metrics::histogram!("latency.tick_to_decision_ms")
-                                    .record(tick_to_decision_ms);
-                                metrics::histogram!("latency.decision_compute_ms")
-                                    .record(decision_compute_ms);
-                                metrics::histogram!("latency.decision_queue_wait_ms")
-                                    .record(latency_sample.local_backlog_ms);
-                                metrics::histogram!("latency.ack_only_ms").record(ack_only_ms);
-                                metrics::histogram!("latency.tick_to_ack_ms")
-                                    .record(tick_to_ack_ms);
-
-                                let ack = OrderAck {
-                                    order_id: ack_v2.order_id,
-                                    market_id: ack_v2.market_id,
-                                    accepted: true,
-                                    ts_ms: ack_v2.ts_ms,
-                                };
-                                let _ = bus.publish(EngineEvent::OrderAck(ack.clone()));
-                                shadow.register_order(&ack, intent.clone());
-
-                                for delay_ms in [5_u64, 10_u64, 25_u64] {
-                                    let shot = ShadowShot {
-                                        shot_id: new_id(),
-                                        market_id: intent.market_id.clone(),
-                                        symbol: symbol.clone(),
-                                        side: intent.side.clone(),
-                                        execution_style: execution_style.clone(),
-                                        // Use taker top-of-book only for "opportunity survival" probing.
-                                        // Keep intended_price as maker entry for markout/PnL attribution.
-                                        survival_probe_price: aggressive_price_for_side(
-                                            &book,
-                                            &intent.side,
-                                        ),
-                                        intended_price: intent.price,
-                                        size: intent.size,
-                                        edge_gross_bps: edge_gross,
-                                        edge_net_bps: edge_net,
-                                        fee_paid_bps: fee_bps,
-                                        rebate_est_bps,
-                                        delay_ms,
-                                        t0_ns: now_ns(),
-                                        min_edge_bps: effective_min_edge_bps,
-                                        tox_score: tox_decision.tox_score,
-                                        ttl_ms: intent.ttl_ms,
-                                    };
-                                    shared.shadow_stats.push_shot(shot.clone()).await;
-                                    let _ = bus.publish(EngineEvent::ShadowShot(shot.clone()));
-                                    spawn_shadow_outcome_task(shared.clone(), bus.clone(), shot);
-                                }
-                            }
-                            Ok(ack_v2) => {
-                                let reject_code = ack_v2
-                                    .reject_code
-                                    .as_deref()
-                                    .map(normalize_reject_code)
-                                    .unwrap_or_else(|| "unknown".to_string());
-                                shared
-                                    .shadow_stats
-                                    .mark_blocked_with_reason(&format!(
-                                        "exchange_reject_{reject_code}"
-                                    ))
-                                    .await;
-                                metrics::counter!("execution.place_rejected").increment(1);
-                            }
-                            Err(err) => {
-                                let reason = classify_execution_error_reason(&err);
-                                shared.shadow_stats.mark_blocked_with_reason(reason).await;
-                                tracing::warn!(?err, "place_order failed");
-                                metrics::counter!("execution.place_error").increment(1);
-                            }
-                        }
-                    }
-
-                    market_inventory.insert(
-                        book.market_id.clone(),
-                        inventory_for_market(&portfolio, &book.market_id),
-                    );
-                }
-                EngineEvent::Control(ControlCommand::Pause) => {
-                    *paused.write().await = true;
-                    shared.shadow_stats.set_paused(true);
-                }
-                EngineEvent::Control(ControlCommand::Resume) => {
-                    *paused.write().await = false;
-                    shared.shadow_stats.set_paused(false);
-                }
-                EngineEvent::Control(ControlCommand::Flatten) => {
-                    if let Err(err) = execution.flatten_all().await {
-                        tracing::warn!(?err, "flatten from control event failed");
-                    }
-                }
-                _ => {}
-            }
-        }
-    });
-}
-
-fn spawn_shadow_outcome_task(
-    shared: Arc<EngineShared>,
-    bus: RingBus<EngineEvent>,
-    shot: ShadowShot,
-) {
-    tokio::spawn(async move {
-        tokio::time::sleep(Duration::from_millis(shot.delay_ms)).await;
-
-        let book = shared
-            .latest_books
-            .read()
-            .await
-            .get(&shot.market_id)
-            .cloned();
-        let latency_ms = ((now_ns() - shot.t0_ns).max(0) as f64) / 1_000_000.0;
-        shared.shadow_stats.push_shadow_fill_ms(latency_ms).await;
-        metrics::histogram!("latency.shadow_fill_ms").record(latency_ms);
-
-        let (
-            survived,
-            fillable,
-            slippage_bps,
-            queue_fill_prob,
-            attribution,
-            pnl_1s_bps,
-            pnl_5s_bps,
-            pnl_10s_bps,
-        ) = if let Some(book) = book {
-            let survived = evaluate_survival(&shot, &book);
-            let (fillable, slippage_bps, queue_fill_prob) =
-                evaluate_fillable(&shot, &book, latency_ms);
-            if fillable {
-                let p1 = pnl_after_horizon(&shared, &shot, Duration::from_secs(1)).await;
-                let p5 = pnl_after_horizon(&shared, &shot, Duration::from_secs(5)).await;
-                let p10 = pnl_after_horizon(&shared, &shot, Duration::from_secs(10)).await;
-                let attribution = classify_filled_outcome(shot.edge_net_bps, p10, slippage_bps);
-                (
-                    survived,
-                    true,
-                    slippage_bps,
-                    queue_fill_prob,
-                    attribution,
-                    p1,
-                    p5,
-                    p10,
-                )
-            } else {
-                let attribution = classify_unfilled_outcome(
-                    &book,
-                    latency_ms,
-                    shot.delay_ms,
-                    survived,
-                    queue_fill_prob,
-                );
-                (
-                    survived,
-                    false,
-                    slippage_bps,
-                    queue_fill_prob,
-                    attribution,
-                    None,
-                    None,
-                    None,
-                )
-            }
-        } else {
-            (
-                false,
-                false,
-                None,
-                0.0,
-                EdgeAttribution::SignalLag,
-                None,
-                None,
-                None,
-            )
-        };
-        let net_markout_1s_bps = net_markout(pnl_1s_bps, &shot);
-        let net_markout_5s_bps = net_markout(pnl_5s_bps, &shot);
-        let net_markout_10s_bps = net_markout(pnl_10s_bps, &shot);
-        let entry_notional_usdc = estimate_entry_notional_usdc(&shot);
-        let net_markout_10s_usdc = bps_to_usdc(net_markout_10s_bps, entry_notional_usdc);
-        let roi_notional_10s_bps = roi_bps_from_usdc(net_markout_10s_usdc, entry_notional_usdc);
-
-        let outcome = ShadowOutcome {
-            shot_id: shot.shot_id.clone(),
-            market_id: shot.market_id.clone(),
-            symbol: shot.symbol.clone(),
-            side: shot.side.clone(),
-            delay_ms: shot.delay_ms,
-            survived,
-            fillable,
-            execution_style: shot.execution_style.clone(),
-            slippage_bps,
-            pnl_1s_bps,
-            pnl_5s_bps,
-            pnl_10s_bps,
-            net_markout_1s_bps,
-            net_markout_5s_bps,
-            net_markout_10s_bps,
-            entry_notional_usdc,
-            net_markout_10s_usdc,
-            roi_notional_10s_bps,
-            queue_fill_prob,
-            is_stale_tick: false,
-            is_outlier: false,
-            robust_weight: 1.0,
-            attribution,
-            ts_ns: now_ns(),
-        };
-        shared.shadow_stats.push_outcome(outcome.clone()).await;
-        update_toxic_state_from_outcome(&shared, &outcome).await;
-        if shot.delay_ms == 10 {
-            let eval = QuoteEval {
-                market_id: shot.market_id.clone(),
-                symbol: shot.symbol.clone(),
-                survival_10ms: if outcome.survived { 1.0 } else { 0.0 },
-                maker_markout_10s_bps: outcome.net_markout_10s_bps.unwrap_or(0.0),
-                adverse_flag: outcome.net_markout_10s_bps.unwrap_or(0.0) < 0.0,
-                ts_ns: now_ns(),
-            };
-            let ingest_seq = next_normalized_ingest_seq();
-            append_jsonl(
-                &dataset_path("normalized", "quote_eval.jsonl"),
-                &serde_json::json!({
-                    "ts_ms": Utc::now().timestamp_millis(),
-                    "source_seq": shot.t0_ns.max(0) as u64,
-                    "ingest_seq": ingest_seq,
-                    "eval": eval
-                }),
-            );
-            let _ = bus.publish(EngineEvent::QuoteEval(eval));
-        }
-        let _ = bus.publish(EngineEvent::ShadowOutcome(outcome));
-    });
-}
-
-fn spawn_survival_probe_task(
-    shared: Arc<EngineShared>,
-    market_id: String,
-    symbol: String,
-    side: OrderSide,
-    probe_px: f64,
-    delay_ms: u64,
-) {
-    tokio::spawn(async move {
-        tokio::time::sleep(Duration::from_millis(delay_ms)).await;
-        let book = shared.latest_books.read().await.get(&market_id).cloned();
-        let survived = match book {
-            Some(ref b) => is_crossable(&side, probe_px, b),
-            None => false,
-        };
-        shared
-            .shadow_stats
-            .record_survival_probe(&symbol, delay_ms, survived)
-            .await;
-    });
-}
-
-async fn refresh_market_symbol_map(shared: &EngineShared) {
-    let discovery = MarketDiscovery::new(DiscoveryConfig {
-        symbols: (*shared.universe_symbols).clone(),
-        market_types: (*shared.universe_market_types).clone(),
-        timeframes: (*shared.universe_timeframes).clone(),
-        ..DiscoveryConfig::default()
-    });
-    match discovery.discover().await {
-        Ok(markets) => {
-            let mut market_map = HashMap::new();
-            let mut token_map = HashMap::new();
-            for m in markets {
-                market_map.insert(m.market_id.clone(), m.symbol.clone());
-                if let Some(t) = m.token_id_yes {
-                    token_map.insert(t, m.symbol.clone());
-                }
-                if let Some(t) = m.token_id_no {
-                    token_map.insert(t, m.symbol.clone());
-                }
-            }
-            {
-                let mut map = shared.market_to_symbol.write().await;
-                *map = market_map;
-            }
-            {
-                let mut map = shared.token_to_symbol.write().await;
-                *map = token_map;
-            }
-        }
-        Err(err) => {
-            tracing::warn!(?err, "market discovery refresh failed");
-        }
-    }
-}
-
-async fn pick_market_symbol(shared: &EngineShared, book: &BookTop) -> Option<String> {
-    if let Some(v) = shared
-        .market_to_symbol
-        .read()
-        .await
-        .get(&book.market_id)
-        .cloned()
-    {
-        return Some(v);
-    }
-    let token_map = shared.token_to_symbol.read().await;
-    token_map
-        .get(&book.token_id_yes)
-        .cloned()
-        .or_else(|| token_map.get(&book.token_id_no).cloned())
-}
-
-async fn market_is_tracked(shared: &EngineShared, book: &BookTop) -> bool {
-    if shared
-        .market_to_symbol
-        .read()
-        .await
-        .contains_key(&book.market_id)
-    {
-        return true;
-    }
-    let token_map = shared.token_to_symbol.read().await;
-    token_map.contains_key(&book.token_id_yes) || token_map.contains_key(&book.token_id_no)
-}
-
-fn inventory_for_market(portfolio: &PortfolioBook, market_id: &str) -> InventoryState {
-    let positions = portfolio.positions();
-    if let Some(pos) = positions.get(market_id) {
-        InventoryState {
-            market_id: market_id.to_string(),
-            net_yes: pos.yes,
-            net_no: pos.no,
-            exposure_notional: pos.yes.abs() + pos.no.abs(),
-        }
-    } else {
-        InventoryState {
-            market_id: market_id.to_string(),
-            net_yes: 0.0,
-            net_no: 0.0,
-            exposure_notional: 0.0,
-        }
-    }
-}
-fn build_toxic_features(
-    book: &BookTop,
-    symbol: &str,
-    stale_ms: f64,
-    fair_yes: f64,
-    state: &MarketToxicState,
-) -> ToxicFeatures {
-    let mid_yes = ((book.bid_yes + book.ask_yes) * 0.5).max(0.0001);
-    let spread_bps = ((book.ask_yes - book.bid_yes).max(0.0) / mid_yes) * 10_000.0;
-    let microprice_drift = fair_yes - mid_yes;
-    let imbalance_den = (book.bid_yes + book.ask_yes + book.bid_no + book.ask_no).abs();
-    let imbalance = if imbalance_den <= 1e-12 {
-        0.0
-    } else {
-        ((book.bid_yes + book.ask_no) - (book.ask_yes + book.bid_no)) / imbalance_den
-    };
-    let attempted = state.attempted.max(1);
-    let cancel_burst = (state.no_quote as f64 / attempted as f64).clamp(0.0, 1.0);
-
-    ToxicFeatures {
-        market_id: book.market_id.clone(),
-        symbol: symbol.to_string(),
-        markout_1s: percentile_deque(&state.markout_1s, 0.50).unwrap_or(0.0),
-        markout_5s: percentile_deque(&state.markout_5s, 0.50).unwrap_or(0.0),
-        markout_10s: percentile_deque(&state.markout_10s, 0.50).unwrap_or(0.0),
-        spread_bps,
-        microprice_drift,
-        stale_ms,
-        imbalance,
-        cancel_burst,
-        ts_ns: now_ns(),
-    }
-}
-
-fn evaluate_toxicity(features: &ToxicFeatures, cfg: &ToxicityConfig) -> ToxicDecision {
-    let neg_markout_1s = (-features.markout_1s).max(0.0) / 20.0;
-    let neg_markout_5s = (-features.markout_5s).max(0.0) / 20.0;
-    let neg_markout_10s = (-features.markout_10s).max(0.0) / 20.0;
-    let spread_z = features.spread_bps / 50.0;
-    let microprice_drift_z = (features.microprice_drift.abs() * 10_000.0) / 20.0;
-    let stale_z = features.stale_ms / 1_500.0;
-    let raw = cfg.w1 * neg_markout_1s
-        + cfg.w2 * neg_markout_5s
-        + cfg.w3 * neg_markout_10s
-        + cfg.w4 * spread_z
-        + cfg.w5 * microprice_drift_z
-        + cfg.w6 * stale_z;
-    let markout_1s_danger = features.markout_1s <= cfg.markout_1s_danger_bps;
-    let markout_5s_danger = features.markout_5s <= cfg.markout_5s_danger_bps;
-    let markout_10s_danger = features.markout_10s <= cfg.markout_10s_danger_bps;
-    let markout_1s_caution = features.markout_1s <= cfg.markout_1s_caution_bps;
-    let markout_5s_caution = features.markout_5s <= cfg.markout_5s_caution_bps;
-    let markout_10s_caution = features.markout_10s <= cfg.markout_10s_caution_bps;
-
-    let mut horizon_boost = 0.0;
-    if markout_1s_danger {
-        horizon_boost += 0.30;
-    } else if markout_1s_caution {
-        horizon_boost += 0.15;
-    }
-    if markout_5s_danger {
-        horizon_boost += 0.25;
-    } else if markout_5s_caution {
-        horizon_boost += 0.12;
-    }
-    if markout_10s_danger {
-        horizon_boost += 0.20;
-    } else if markout_10s_caution {
-        horizon_boost += 0.10;
-    }
-    let tox_score = (sigmoid(raw) + horizon_boost).clamp(0.0, 1.0);
-
-    let mut reasons = Vec::new();
-    if markout_1s_danger {
-        reasons.push("markout_1s_danger".to_string());
-    } else if markout_1s_caution {
-        reasons.push("markout_1s_caution".to_string());
-    } else if features.markout_1s < 0.0 {
-        reasons.push("markout_1s_negative".to_string());
-    }
-    if markout_5s_danger {
-        reasons.push("markout_5s_danger".to_string());
-    } else if markout_5s_caution {
-        reasons.push("markout_5s_caution".to_string());
-    } else if features.markout_5s < 0.0 {
-        reasons.push("markout_5s_negative".to_string());
-    }
-    if markout_10s_danger {
-        reasons.push("markout_10s_danger".to_string());
-    } else if markout_10s_caution {
-        reasons.push("markout_10s_caution".to_string());
-    } else if features.markout_10s < 0.0 {
-        reasons.push("markout_10s_negative".to_string());
-    }
-    if features.spread_bps > 60.0 {
-        reasons.push("spread_wide".to_string());
-    }
-    if features.stale_ms > 1_500.0 {
-        reasons.push("stale_feed".to_string());
-    }
-    if reasons.is_empty() {
-        reasons.push("normal".to_string());
-    }
-
-    let regime = if markout_1s_danger || markout_5s_danger || markout_10s_danger {
-        ToxicRegime::Danger
-    } else if markout_1s_caution || markout_5s_caution || markout_10s_caution {
-        ToxicRegime::Caution
-    } else if tox_score >= cfg.caution_threshold {
-        ToxicRegime::Danger
-    } else if tox_score >= cfg.safe_threshold {
-        ToxicRegime::Caution
-    } else {
-        ToxicRegime::Safe
-    };
-
-    ToxicDecision {
-        market_id: features.market_id.clone(),
-        symbol: features.symbol.clone(),
-        tox_score,
-        regime,
-        reason_codes: reasons,
-        ts_ns: now_ns(),
-    }
-}
-
-fn compute_market_score(state: &MarketToxicState, tox_score: f64, markout_samples: usize) -> f64 {
-    let attempted = state.attempted.max(1);
-    let no_quote_rate = state.no_quote as f64 / attempted as f64;
-    let symbol_missing_rate = state.symbol_missing as f64 / attempted as f64;
-    let markout_10s = percentile_deque(&state.markout_10s, 0.50).unwrap_or(0.0);
-    if markout_samples < 20 {
-        let warmup_score = 80.0 - no_quote_rate * 6.0 - symbol_missing_rate * 6.0;
-        return warmup_score.clamp(45.0, 100.0);
-    }
-    let score = 70.0 + (markout_10s * 1.5).clamp(-30.0, 30.0)
-        - no_quote_rate * 25.0
-        - symbol_missing_rate * 30.0
-        - tox_score * 20.0;
-    score.clamp(0.0, 100.0)
-}
-
-fn adaptive_min_edge_bps(
-    base_min_edge_bps: f64,
-    tox_score: f64,
-    markout_samples: usize,
-    no_quote_rate: f64,
-    markout_10s_p50: f64,
-    markout_10s_p25: f64,
-    window_outcomes: usize,
-    gate_min_outcomes: usize,
-) -> f64 {
-    if window_outcomes < gate_min_outcomes {
-        let progress = (window_outcomes as f64 / gate_min_outcomes.max(1) as f64).clamp(0.0, 1.0);
-        let warmup_floor = (base_min_edge_bps * 0.15).max(0.5);
-        let warmup_target = (base_min_edge_bps * 0.50).max(warmup_floor);
-        let mut warmup_edge = warmup_floor + (warmup_target - warmup_floor) * progress;
-        if no_quote_rate > 0.85 {
-            warmup_edge *= 0.80;
-        }
-        return warmup_edge.clamp(0.25, base_min_edge_bps.max(0.25));
-    }
-
-    if markout_samples < 20 {
-        return (base_min_edge_bps * 0.5).max(1.0);
-    }
-    let mut out = base_min_edge_bps * (1.0 + tox_score * 0.6);
-    if markout_10s_p50 < 0.0 {
-        out += (-markout_10s_p50) * 0.50;
-    }
-    if markout_10s_p25 < 0.0 {
-        out += (-markout_10s_p25) * 0.35;
-    }
-    if no_quote_rate > 0.95 {
-        out *= 0.9;
-    }
-    out.clamp(1.0, base_min_edge_bps * 2.5)
-}
-
-fn adaptive_max_spread(base_max_spread: f64, tox_score: f64, markout_samples: usize) -> f64 {
-    if markout_samples < 20 {
-        return (base_max_spread * 1.2).clamp(0.003, 0.08);
-    }
-    (base_max_spread * (1.0 - tox_score * 0.35)).clamp(0.002, base_max_spread)
-}
-
-fn should_force_taker(
-    cfg: &MakerConfig,
-    tox: &ToxicDecision,
-    edge_net_bps: f64,
-    confidence: f64,
-    markout_samples: usize,
-    no_quote_rate: f64,
-    window_outcomes: usize,
-    gate_min_outcomes: usize,
-    symbol: &str,
-) -> bool {
-    let profile = cfg.market_tier_profile.to_ascii_lowercase();
-    let aggressive_profile =
-        profile.contains("taker") || profile.contains("aggressive") || profile.contains("latency");
-
-    let warmup_factor = if window_outcomes < gate_min_outcomes {
-        let progress = (window_outcomes as f64 / gate_min_outcomes.max(1) as f64).clamp(0.0, 1.0);
-        // Lower trigger during warmup so the funnel can collect enough comparable samples.
-        (0.70 + 0.30 * progress).clamp(0.60, 1.0)
-    } else {
-        1.0
-    };
-    let no_quote_factor = if no_quote_rate > 0.90 { 0.85 } else { 1.0 };
-    let mut trigger_bps = cfg.taker_trigger_bps.max(0.0) * warmup_factor * no_quote_factor;
-    if symbol.eq_ignore_ascii_case("SOLUSDT")
-        && (profile.contains("sol_guard") || !aggressive_profile)
-    {
-        trigger_bps *= 1.25;
-    }
-
-    if edge_net_bps < trigger_bps {
-        return false;
-    }
-    if matches!(tox.regime, ToxicRegime::Danger) {
-        return false;
-    }
-
-    if matches!(tox.regime, ToxicRegime::Caution) && !aggressive_profile {
-        return false;
-    }
-
-    let min_conf = if markout_samples < 20 || window_outcomes < gate_min_outcomes {
-        0.45
-    } else {
-        0.55
-    };
-    if confidence < min_conf && !aggressive_profile {
-        return false;
-    }
-
-    true
-}
-
-fn adaptive_taker_slippage_bps(
-    base_slippage_bps: f64,
-    market_tier_profile: &str,
-    symbol: &str,
-    markout_samples: usize,
-    no_quote_rate: f64,
-    window_outcomes: usize,
-    gate_min_outcomes: usize,
-) -> f64 {
-    let mut out = base_slippage_bps.max(1.0);
-    let profile = market_tier_profile.to_ascii_lowercase();
-    let aggressive = profile.contains("aggressive") || profile.contains("latency");
-
-    if window_outcomes < gate_min_outcomes || markout_samples < 20 {
-        out *= if no_quote_rate > 0.85 { 1.40 } else { 1.20 };
-    }
-    if aggressive {
-        out *= 1.10;
-    }
-    if symbol.eq_ignore_ascii_case("SOLUSDT") && (profile.contains("sol_guard") || !aggressive) {
-        out *= 0.80;
-    }
-
-    out.clamp(5.0, 60.0)
-}
-
-fn should_observe_only_symbol(
-    symbol: &str,
-    cfg: &MakerConfig,
-    tox: &ToxicDecision,
-    feed_in_ms: f64,
-    spread_yes: f64,
-    book_top_lag_ms: f64,
-) -> bool {
-    if !symbol.eq_ignore_ascii_case("SOLUSDT") {
-        return false;
-    }
-    let profile = cfg.market_tier_profile.to_ascii_lowercase();
-    if !(profile.contains("sol_guard") || profile.contains("balanced")) {
-        return false;
-    }
-
-    // Keep SOL observe-only unless the local "ref lead vs book" lag is within a tight bound.
-    // This avoids letting one slow/volatile venue degrade the overall engine quality.
-    book_top_lag_ms > 130.0
-        || matches!(tox.regime, ToxicRegime::Danger)
-        || feed_in_ms > 250.0
-        || spread_yes > 0.020
-}
-
-fn estimate_queue_fill_proxy(tox_score: f64, spread_yes: f64, feed_in_ms: f64) -> f64 {
-    let spread_pen = (spread_yes / 0.03).clamp(0.0, 1.0);
-    let latency_pen = (feed_in_ms / 800.0).clamp(0.0, 1.0);
-    (1.0 - (tox_score * 0.45 + spread_pen * 0.35 + latency_pen * 0.20)).clamp(0.0, 1.0)
-}
-
-fn estimate_queue_fill_prob(shot: &ShadowShot, book: &BookTop, latency_ms: f64) -> f64 {
-    let spread = match shot.side {
-        OrderSide::BuyYes | OrderSide::SellYes => (book.ask_yes - book.bid_yes).max(0.0),
-        OrderSide::BuyNo | OrderSide::SellNo => (book.ask_no - book.bid_no).max(0.0),
-    };
-    let spread_pen = (spread / 0.03).clamp(0.0, 1.0);
-    let delay_pen = (shot.delay_ms as f64 / 25.0).clamp(0.0, 1.0);
-    let latency_pen = (latency_ms / 100.0).clamp(0.0, 1.0);
-    (1.0 - (shot.tox_score * 0.35 + spread_pen * 0.30 + delay_pen * 0.20 + latency_pen * 0.15))
-        .clamp(0.0, 1.0)
-}
-
-fn is_market_in_top_n(
-    states: &HashMap<String, MarketToxicState>,
-    market_id: &str,
-    top_n: usize,
-) -> bool {
-    if top_n == 0 {
-        return true;
-    }
-    let mut ranked = states
-        .iter()
-        .map(|(id, st)| {
-            let samples = st
-                .markout_1s
-                .len()
-                .max(st.markout_5s.len())
-                .max(st.markout_10s.len());
-            (
-                id.clone(),
-                compute_market_score(st, st.last_tox_score, samples),
-            )
-        })
-        .collect::<Vec<_>>();
-    if ranked.is_empty() {
-        return true;
-    }
-    ranked.sort_by(|a, b| b.1.total_cmp(&a.1));
-    ranked
-        .into_iter()
-        .take(top_n.max(1))
-        .any(|(id, _)| id == market_id)
-}
-
-fn cooldown_secs_for_score(tox_score: f64, cfg: &ToxicityConfig) -> u64 {
-    let t = tox_score.clamp(0.0, 1.0);
-    ((cfg.cooldown_min_sec as f64)
-        + ((cfg.cooldown_max_sec as f64) - (cfg.cooldown_min_sec as f64)) * t)
-        .round() as u64
-}
-
-fn net_markout(markout_bps: Option<f64>, shot: &ShadowShot) -> Option<f64> {
-    markout_bps.map(|v| v - shot.fee_paid_bps + shot.rebate_est_bps)
-}
-
-fn estimate_entry_notional_usdc(shot: &ShadowShot) -> f64 {
-    (shot.intended_price.max(0.0) * shot.size.max(0.0)).max(0.0)
-}
-
-fn bps_to_usdc(bps: Option<f64>, notional_usdc: f64) -> Option<f64> {
-    if notional_usdc <= 0.0 {
-        return None;
-    }
-    bps.map(|v| (v / 10_000.0) * notional_usdc)
-}
-
-fn roi_bps_from_usdc(markout_usdc: Option<f64>, notional_usdc: f64) -> Option<f64> {
-    if notional_usdc <= 0.0 {
-        return None;
-    }
-    markout_usdc.map(|v| (v / notional_usdc) * 10_000.0)
-}
-
-async fn update_toxic_state_from_outcome(shared: &EngineShared, outcome: &ShadowOutcome) {
-    if !outcome.fillable || outcome.delay_ms != 10 {
-        return;
-    }
-    let mut states = shared.tox_state.write().await;
-    let st = states.entry(outcome.market_id.clone()).or_default();
-    if let Some(v) = outcome.net_markout_1s_bps.or(outcome.pnl_1s_bps) {
-        push_rolling(&mut st.markout_1s, v, 2048);
-    }
-    if let Some(v) = outcome.net_markout_5s_bps.or(outcome.pnl_5s_bps) {
-        push_rolling(&mut st.markout_5s, v, 2048);
-    }
-    if let Some(v) = outcome.net_markout_10s_bps.or(outcome.pnl_10s_bps) {
-        push_rolling(&mut st.markout_10s, v, 2048);
-    }
-}
-
-fn push_rolling(dst: &mut VecDeque<f64>, value: f64, cap: usize) {
-    dst.push_back(value);
-    while dst.len() > cap {
-        dst.pop_front();
-    }
-}
-
-fn sigmoid(x: f64) -> f64 {
-    if x >= 0.0 {
-        1.0 / (1.0 + (-x).exp())
-    } else {
-        let ex = x.exp();
-        ex / (1.0 + ex)
-    }
-}
-
-#[derive(Debug, Clone, Copy, Default)]
-struct FeedLatencySample {
-    feed_in_ms: f64,
-    source_latency_ms: f64,
-    local_backlog_ms: f64,
-}
-
-#[derive(Debug, Clone)]
-struct TokenBucket {
-    rps: f64,
-    burst: f64,
-    tokens: f64,
-    last_refill: Instant,
-}
-
-impl TokenBucket {
-    fn new(rps: f64, burst: f64) -> Self {
-        let rps = rps.max(0.1);
-        let burst = burst.max(1.0);
-        Self {
-            rps,
-            burst,
-            tokens: burst,
-            last_refill: Instant::now(),
-        }
-    }
-
-    fn try_take(&mut self, n: f64) -> bool {
-        let now = Instant::now();
-        let dt = now.duration_since(self.last_refill).as_secs_f64();
-        self.last_refill = now;
-        self.tokens = (self.tokens + dt * self.rps).clamp(0.0, self.burst);
-        if self.tokens >= n {
-            self.tokens -= n;
-            true
-        } else {
-            false
-        }
-    }
-}
-
-fn estimate_feed_latency(tick: &RefTick, book: &BookTop) -> FeedLatencySample {
-    let now = now_ns();
-    let now_ms = now / 1_000_000;
-    let tick_source_ms = tick.event_ts_exchange_ms.max(tick.event_ts_ms);
-    let tick_ingest_ms = (tick.recv_ts_ms - tick_source_ms).max(0) as f64;
-    let book_recv_ms = if book.recv_ts_local_ns > 0 {
-        (book.recv_ts_local_ns / 1_000_000).max(0)
-    } else {
-        now_ms
-    };
-    let book_ingest_ms = (book_recv_ms - book.ts_ms).max(0) as f64;
-    let source_latency_ms = tick_ingest_ms.max(book_ingest_ms);
-
-    let latest_recv_ns = if book.recv_ts_local_ns > 0 {
-        tick.recv_ts_local_ns.max(book.recv_ts_local_ns)
-    } else {
-        tick.recv_ts_local_ns
-    };
-    let local_backlog_ms = if latest_recv_ns > 0 {
-        ((now - latest_recv_ns).max(0) as f64) / 1_000_000.0
-    } else {
-        (now_ms - tick.recv_ts_ms.max(book.ts_ms)).max(0) as f64
-    };
-
-    let feed_in_ms = source_latency_ms + local_backlog_ms;
-    FeedLatencySample {
-        feed_in_ms,
-        source_latency_ms,
-        local_backlog_ms,
-    }
-}
-
-fn is_anchor_ref_source(source: &str) -> bool {
-    source == "chainlink_rtds"
-}
-
-fn ref_event_ts_ms(tick: &RefTick) -> i64 {
-    tick.event_ts_exchange_ms.max(tick.event_ts_ms)
-}
-
-fn should_replace_ref_tick(current: &RefTick, next: &RefTick) -> bool {
-    let current_event = ref_event_ts_ms(current);
-    let next_event = ref_event_ts_ms(next);
-    if next_event + 50 < current_event {
-        return false;
-    }
-    if next_event > current_event + 1 {
-        return true;
-    }
-    // If the event timestamps are effectively equal, keep the first-arriving tick for speed.
-    // (The later-arriving copy is usually strictly worse for latency-arb triggers.)
-    false
-}
-
-fn should_replace_anchor_tick(current: &RefTick, next: &RefTick) -> bool {
-    let current_event = ref_event_ts_ms(current);
-    let next_event = ref_event_ts_ms(next);
-    if next_event + 50 < current_event {
-        return false;
-    }
-    if next_event > current_event + 1 {
-        return true;
-    }
-    next.recv_ts_local_ns > current.recv_ts_local_ns + 1_000_000
-}
-
-fn insert_latest_tick(latest_ticks: &mut HashMap<String, RefTick>, tick: RefTick) {
-    match latest_ticks.get(tick.symbol.as_str()) {
-        Some(current) => {
-            if should_replace_ref_tick(current, &tick) {
-                latest_ticks.insert(tick.symbol.clone(), tick);
-            }
-        }
-        None => {
-            latest_ticks.insert(tick.symbol.clone(), tick);
-        }
-    }
-}
-
-fn insert_latest_anchor_tick(latest_ticks: &mut HashMap<String, RefTick>, tick: RefTick) {
-    match latest_ticks.get(tick.symbol.as_str()) {
-        Some(current) => {
-            if should_replace_anchor_tick(current, &tick) {
-                latest_ticks.insert(tick.symbol.clone(), tick);
-            }
-        }
-        None => {
-            latest_ticks.insert(tick.symbol.clone(), tick);
-        }
-    }
-}
-
-fn insert_latest_ref_tick(
-    latest_fast_ticks: &mut HashMap<String, RefTick>,
-    latest_anchor_ticks: &mut HashMap<String, RefTick>,
-    tick: RefTick,
-) {
-    if is_anchor_ref_source(tick.source.as_str()) {
-        insert_latest_anchor_tick(latest_anchor_ticks, tick);
-    } else {
-        insert_latest_tick(latest_fast_ticks, tick);
-    }
-}
-
-fn pick_latest_tick<'a>(
-    latest_ticks: &'a HashMap<String, RefTick>,
-    symbol: &str,
-) -> Option<&'a RefTick> {
-    latest_ticks
-        .get(symbol)
-        .or_else(|| latest_ticks.values().max_by_key(|t| t.recv_ts_ms))
-}
-
-async fn get_fee_rate_bps_cached(shared: &EngineShared, market_id: &str) -> f64 {
-    const DEFAULT_FEE_BPS: f64 = 2.0;
-    const TTL: Duration = Duration::from_secs(60);
-    const REFRESH_BACKOFF: Duration = Duration::from_secs(3);
-
-    let now = Instant::now();
-    let (cached_fee, needs_refresh) =
-        if let Some(entry) = shared.fee_cache.read().await.get(market_id).cloned() {
-            (
-                entry.fee_bps,
-                now.duration_since(entry.fetched_at) >= TTL || entry.fee_bps <= 0.0,
-            )
-        } else {
-            (DEFAULT_FEE_BPS, true)
-        };
-
-    if needs_refresh {
-        maybe_spawn_fee_refresh(shared, market_id, now, REFRESH_BACKOFF).await;
-    }
-
-    cached_fee
-}
-
-async fn get_rebate_bps_cached(shared: &EngineShared, market_id: &str, fee_bps: f64) -> f64 {
-    const TTL: Duration = Duration::from_secs(120);
-    let now = Instant::now();
-    let maybe = shared.scoring_cache.read().await.get(market_id).cloned();
-    match maybe {
-        Some(entry) if now.duration_since(entry.fetched_at) <= TTL => {
-            entry.rebate_bps_est.clamp(0.0, fee_bps.max(0.0))
-        }
-        _ => 0.0,
-    }
-}
-
-async fn maybe_spawn_fee_refresh(
-    shared: &EngineShared,
-    market_id: &str,
-    now: Instant,
-    refresh_backoff: Duration,
-) {
-    {
-        let inflight = shared.fee_refresh_inflight.read().await;
-        if let Some(last_attempt) = inflight.get(market_id) {
-            if now.duration_since(*last_attempt) < refresh_backoff {
-                return;
-            }
-        }
-    }
-
-    {
-        let mut inflight = shared.fee_refresh_inflight.write().await;
-        if let Some(last_attempt) = inflight.get(market_id) {
-            if now.duration_since(*last_attempt) < refresh_backoff {
-                return;
-            }
-        }
-        inflight.insert(market_id.to_string(), now);
-    }
-
-    let market = market_id.to_string();
-    let http = shared.http.clone();
-    let clob_endpoint = shared.clob_endpoint.clone();
-    let fee_cache = shared.fee_cache.clone();
-    let inflight = shared.fee_refresh_inflight.clone();
-    tokio::spawn(async move {
-        if let Some(fee_bps) = fetch_fee_rate_bps(&http, &clob_endpoint, &market).await {
-            fee_cache.write().await.insert(
-                market.clone(),
-                FeeRateEntry {
-                    fee_bps,
-                    fetched_at: Instant::now(),
-                },
-            );
-        }
-        inflight.write().await.remove(&market);
-    });
-}
-
-async fn maybe_spawn_scoring_refresh(
-    shared: &EngineShared,
-    market_id: &str,
-    order_id: &str,
-    fee_bps: f64,
-    now: Instant,
-    refresh_backoff: Duration,
-) {
-    if market_id.is_empty() || order_id.is_empty() {
-        return;
-    }
-    {
-        let inflight = shared.scoring_refresh_inflight.read().await;
-        if let Some(last_attempt) = inflight.get(market_id) {
-            if now.duration_since(*last_attempt) < refresh_backoff {
-                return;
-            }
-        }
-    }
-    {
-        let mut inflight = shared.scoring_refresh_inflight.write().await;
-        if let Some(last_attempt) = inflight.get(market_id) {
-            if now.duration_since(*last_attempt) < refresh_backoff {
-                return;
-            }
-        }
-        inflight.insert(market_id.to_string(), now);
-    }
-
-    let market = market_id.to_string();
-    let order = order_id.to_string();
-    let http = shared.http.clone();
-    let clob_endpoint = shared.clob_endpoint.clone();
-    let scoring_cache = shared.scoring_cache.clone();
-    let inflight = shared.scoring_refresh_inflight.clone();
-    let rebate_factor = shared.scoring_rebate_factor;
-    tokio::spawn(async move {
-        if let Some((scoring_ok, raw)) = fetch_order_scoring(&http, &clob_endpoint, &order).await {
-            let mut cache = scoring_cache.write().await;
-            let mut entry = cache.get(&market).cloned().unwrap_or(ScoringState {
-                scoring_true: 0,
-                scoring_total: 0,
-                rebate_bps_est: 0.0,
-                fetched_at: Instant::now(),
-            });
-            entry.scoring_total = entry.scoring_total.saturating_add(1);
-            if scoring_ok {
-                entry.scoring_true = entry.scoring_true.saturating_add(1);
-            }
-            let hit_ratio = if entry.scoring_total == 0 {
-                0.0
-            } else {
-                (entry.scoring_true as f64 / entry.scoring_total as f64).clamp(0.0, 1.0)
-            };
-            // Conservative estimate: maker rebates are a fraction of taker fees and depend on
-            // scoring + market share. Default rebate_factor is 0.0 unless explicitly configured.
-            // Cap the pool fraction at 20% of fee_bps as a hard upper bound.
-            entry.rebate_bps_est = (fee_bps.max(0.0) * 0.20 * hit_ratio * rebate_factor)
-                .clamp(0.0, fee_bps.max(0.0));
-            entry.fetched_at = Instant::now();
-            let log_row = serde_json::json!({
-                "ts_ms": Utc::now().timestamp_millis(),
-                "market_id": market,
-                "order_id": order,
-                "scoring_ok": scoring_ok,
-                "scoring_true": entry.scoring_true,
-                "scoring_total": entry.scoring_total,
-                "hit_ratio": hit_ratio,
-                "rebate_bps_est": entry.rebate_bps_est,
-                "raw": raw
-            });
-            cache.insert(market.clone(), entry);
-            append_jsonl(
-                &dataset_path("normalized", "scoring_feedback.jsonl"),
-                &log_row,
-            );
-        }
-        inflight.write().await.remove(&market);
-    });
-}
-
-async fn fetch_fee_rate_bps(http: &Client, clob_endpoint: &str, market_id: &str) -> Option<f64> {
-    let base = clob_endpoint.trim_end_matches('/');
-    let endpoints = [
-        format!("{base}/fee-rate?market_id={market_id}"),
-        format!("{base}/fee-rate?market={market_id}"),
-        format!("{base}/fee-rate?token_id={market_id}"),
-    ];
-
-    for url in endpoints {
-        let Ok(resp) = http.get(&url).send().await else {
-            continue;
-        };
-        let Ok(resp) = resp.error_for_status() else {
-            continue;
-        };
-        let Ok(v) = resp.json::<serde_json::Value>().await else {
-            continue;
-        };
-        let candidate = v
-            .get("fee_rate_bps")
-            .and_then(value_to_f64)
-            .or_else(|| v.get("feeRateBps").and_then(value_to_f64))
-            .or_else(|| v.get("makerFeeRateBps").and_then(value_to_f64))
-            .or_else(|| v.get("maker_fee_rate_bps").and_then(value_to_f64));
-        if candidate.is_some() {
-            return candidate;
-        }
-    }
-    None
-}
-
-async fn fetch_order_scoring(
-    http: &Client,
-    clob_endpoint: &str,
-    order_id: &str,
-) -> Option<(bool, serde_json::Value)> {
-    let base = clob_endpoint.trim_end_matches('/');
-    let endpoints = [
-        format!("{base}/order-scoring?order_id={order_id}"),
-        format!("{base}/order-scoring?orderId={order_id}"),
-        format!("{base}/orders-scoring?order_id={order_id}"),
-    ];
-    for url in endpoints {
-        let Ok(resp) = http.get(&url).send().await else {
-            continue;
-        };
-        let Ok(resp) = resp.error_for_status() else {
-            continue;
-        };
-        let Ok(value) = resp.json::<serde_json::Value>().await else {
-            continue;
-        };
-        let scoring = value
-            .get("scoring")
-            .and_then(|v| v.as_bool())
-            .or_else(|| value.get("is_scoring").and_then(|v| v.as_bool()))
-            .or_else(|| value.get("isScoring").and_then(|v| v.as_bool()))
-            .or_else(|| value.get("eligible").and_then(|v| v.as_bool()))
-            .or_else(|| value.as_bool())
-            .unwrap_or(false);
-        return Some((scoring, value));
-    }
-    None
-}
-
-async fn pnl_after_horizon(
-    shared: &EngineShared,
-    shot: &ShadowShot,
-    horizon: Duration,
-) -> Option<f64> {
-    tokio::time::sleep(horizon).await;
-    let book = shared
-        .latest_books
-        .read()
-        .await
-        .get(&shot.market_id)
-        .cloned()?;
-    let mark = mid_for_side(&book, &shot.side);
-    if shot.intended_price <= 0.0 {
-        return None;
-    }
-    let pnl = match shot.side {
-        OrderSide::BuyYes | OrderSide::BuyNo => {
-            ((mark - shot.intended_price) / shot.intended_price) * 10_000.0
-        }
-        OrderSide::SellYes | OrderSide::SellNo => {
-            ((shot.intended_price - mark) / shot.intended_price) * 10_000.0
-        }
-    };
-    Some(pnl)
-}
-
-fn evaluate_survival(shot: &ShadowShot, book: &BookTop) -> bool {
-    let probe_px = if shot.survival_probe_price > 0.0 {
-        shot.survival_probe_price
-    } else {
-        shot.intended_price
-    };
-    is_crossable(&shot.side, probe_px, book)
-}
-
-fn is_crossable(side: &OrderSide, probe_px: f64, book: &BookTop) -> bool {
-    if probe_px <= 0.0 {
-        return false;
-    }
-    match side {
-        OrderSide::BuyYes => probe_px >= book.ask_yes,
-        OrderSide::SellYes => probe_px <= book.bid_yes,
-        OrderSide::BuyNo => probe_px >= book.ask_no,
-        OrderSide::SellNo => probe_px <= book.bid_no,
-    }
-}
-
-fn evaluate_fillable(
-    shot: &ShadowShot,
-    book: &BookTop,
-    latency_ms: f64,
-) -> (bool, Option<f64>, f64) {
-    let probe_px = if shot.survival_probe_price > 0.0 {
-        shot.survival_probe_price
-    } else {
-        shot.intended_price
-    };
-    let (crossable, fill_px) = match shot.side {
-        OrderSide::BuyYes => (probe_px >= book.ask_yes, book.ask_yes),
-        OrderSide::SellYes => (probe_px <= book.bid_yes, book.bid_yes),
-        OrderSide::BuyNo => (probe_px >= book.ask_no, book.ask_no),
-        OrderSide::SellNo => (probe_px <= book.bid_no, book.bid_no),
-    };
-    if !crossable || probe_px <= 0.0 {
-        return (false, None, 0.0);
-    }
-    let queue_fill_prob = estimate_queue_fill_prob(shot, book, latency_ms);
-    if queue_fill_prob < 0.55 {
-        return (false, None, queue_fill_prob);
-    }
-    let mut slippage = match shot.side {
-        OrderSide::BuyYes | OrderSide::BuyNo => ((fill_px - probe_px) / probe_px) * 10_000.0,
-        OrderSide::SellYes | OrderSide::SellNo => ((probe_px - fill_px) / probe_px) * 10_000.0,
-    };
-    slippage += (1.0 - queue_fill_prob) * 8.0;
-    (true, Some(slippage), queue_fill_prob)
-}
-
-fn classify_unfilled_outcome(
-    book: &BookTop,
-    latency_ms: f64,
-    delay_ms: u64,
-    survived: bool,
-    queue_fill_prob: f64,
-) -> EdgeAttribution {
-    let spread = (book.ask_yes - book.bid_yes).max(0.0);
-    if delay_ms >= 400 {
-        return EdgeAttribution::StaleQuote;
-    }
-    if !survived {
-        return EdgeAttribution::BookMoved;
-    }
-    if book.ask_yes <= 0.0 || book.bid_yes <= 0.0 {
-        return EdgeAttribution::LiquidityThin;
-    }
-    if spread > 0.05 {
-        return EdgeAttribution::SpreadTooWide;
-    }
-    if queue_fill_prob < 0.55 {
-        return EdgeAttribution::LatencyTail;
-    }
-    if latency_ms > 100.0 {
-        return EdgeAttribution::LatencyTail;
-    }
-    EdgeAttribution::BookMoved
-}
-
-fn classify_filled_outcome(
-    edge_net_bps: f64,
-    pnl_10s_bps: Option<f64>,
-    slippage_bps: Option<f64>,
-) -> EdgeAttribution {
-    if edge_net_bps < 0.0 {
-        return EdgeAttribution::FeeOverrun;
-    }
-    if slippage_bps.unwrap_or(0.0) > edge_net_bps.abs() {
-        return EdgeAttribution::SignalLag;
-    }
-    if pnl_10s_bps.unwrap_or(0.0) < 0.0 {
-        return EdgeAttribution::AdverseSelection;
-    }
-    EdgeAttribution::Unknown
-}
-
-fn mid_for_side(book: &BookTop, side: &OrderSide) -> f64 {
-    match side {
-        OrderSide::BuyYes | OrderSide::SellYes => (book.bid_yes + book.ask_yes) * 0.5,
-        OrderSide::BuyNo | OrderSide::SellNo => (book.bid_no + book.ask_no) * 0.5,
-    }
-}
-
-fn aggressive_price_for_side(book: &BookTop, side: &OrderSide) -> f64 {
-    match side {
-        OrderSide::BuyYes => book.ask_yes,
-        OrderSide::SellYes => book.bid_yes,
-        OrderSide::BuyNo => book.ask_no,
-        OrderSide::SellNo => book.bid_no,
-    }
-}
-
-fn edge_for_intent(fair_yes: f64, intent: &QuoteIntent) -> f64 {
-    let px = intent.price.max(1e-6);
-    match intent.side {
-        // Expected edge vs. intended entry price in bps of entry.
-        OrderSide::BuyYes | OrderSide::BuyNo => ((fair_yes - px) / px) * 10_000.0,
-        OrderSide::SellYes | OrderSide::SellNo => ((px - fair_yes) / px) * 10_000.0,
-    }
-}
-
-async fn build_toxicity_live_report(
-    tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
-    shadow_stats: Arc<ShadowStats>,
-    execution: Arc<ClobExecution>,
-    toxicity_cfg: Arc<RwLock<ToxicityConfig>>,
-) -> ToxicityLiveReport {
-    let cfg = toxicity_cfg.read().await.clone();
-    let states = tox_state.read().await.clone();
-    let shots = shadow_stats.shots.read().await.clone();
-    let outcomes = shadow_stats.outcomes.read().await.clone();
-
-    let mut rows = Vec::<ToxicityMarketRow>::new();
-    let mut safe = 0usize;
-    let mut caution = 0usize;
-    let mut danger = 0usize;
-    let mut tox_sum = 0.0;
-
-    for (market_id, st) in states {
-        let symbol = if !st.symbol.is_empty() {
-            st.symbol.clone()
-        } else {
-            shots
-                .iter()
-                .find(|s| s.market_id == market_id)
-                .map(|s| s.symbol.clone())
-                .or_else(|| {
-                    outcomes
-                        .iter()
-                        .find(|o| o.market_id == market_id)
-                        .map(|o| o.symbol.clone())
-                })
-                .unwrap_or_else(|| "UNKNOWN".to_string())
-        };
-        let attempted = st.attempted.max(1);
-        let no_quote_rate = st.no_quote as f64 / attempted as f64;
-        let symbol_missing_rate = st.symbol_missing as f64 / attempted as f64;
-        let markout_10s_bps = percentile_deque(&st.markout_10s, 0.50).unwrap_or(0.0);
-        let markout_samples = st
-            .markout_1s
-            .len()
-            .max(st.markout_5s.len())
-            .max(st.markout_10s.len());
-        let market_score = compute_market_score(&st, st.last_tox_score, markout_samples);
-        let pending_exposure = execution.open_order_notional_for_market(&market_id);
-
-        tox_sum += st.last_tox_score;
-        match st.last_regime {
-            ToxicRegime::Safe => safe += 1,
-            ToxicRegime::Caution => caution += 1,
-            ToxicRegime::Danger => danger += 1,
-        }
-
-        rows.push(ToxicityMarketRow {
-            market_rank: 0,
-            market_id,
-            symbol,
-            tox_score: st.last_tox_score,
-            regime: st.last_regime,
-            market_score,
-            markout_10s_bps,
-            no_quote_rate,
-            symbol_missing_rate,
-            pending_exposure,
-            active_for_quoting: false,
-        });
-    }
-
-    rows.sort_by(|a, b| b.market_score.total_cmp(&a.market_score));
-    let top_n = cfg.active_top_n_markets;
-    for (idx, row) in rows.iter_mut().enumerate() {
-        row.market_rank = idx + 1;
-        row.active_for_quoting = top_n == 0 || (idx < top_n);
-    }
-    let avg = if rows.is_empty() {
-        0.0
-    } else {
-        tox_sum / (rows.len() as f64)
-    };
-
-    ToxicityLiveReport {
-        ts_ms: Utc::now().timestamp_millis(),
-        average_tox_score: avg,
-        safe_count: safe,
-        caution_count: caution,
-        danger_count: danger,
-        rows,
-    }
-}
-
-fn load_fair_value_config() -> BasisMrConfig {
-    let path = Path::new("configs/strategy.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        return BasisMrConfig::default();
-    };
-
-    let mut cfg = BasisMrConfig::default();
-    let mut in_section = false;
-    for line in raw.lines() {
-        let line = line.trim();
-        if line.is_empty() || line.starts_with('#') {
-            continue;
-        }
-        if line.starts_with('[') && line.ends_with(']') {
-            in_section = line == "[fair_value.basis_mr]";
-            continue;
-        }
-        if !in_section {
-            continue;
-        }
-        let Some((k, v)) = line.split_once('=') else {
-            continue;
-        };
-        let key = k.trim();
-        let val = v.trim().trim_matches('"');
-        match key {
-            "enabled" => {
-                if let Ok(parsed) = val.parse::<bool>() {
-                    cfg.enabled = parsed;
-                }
-            }
-            "alpha_mean" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.alpha_mean = parsed.clamp(0.0, 1.0);
-                }
-            }
-            "alpha_var" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.alpha_var = parsed.clamp(0.0, 1.0);
-                }
-            }
-            "alpha_ret" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.alpha_ret = parsed.clamp(0.0, 1.0);
-                }
-            }
-            "alpha_vol" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.alpha_vol = parsed.clamp(0.0, 1.0);
-                }
-            }
-            "k_revert" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.k_revert = parsed.clamp(0.0, 5.0);
-                }
-            }
-            "z_cap" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.z_cap = parsed.clamp(0.5, 8.0);
-                }
-            }
-            "min_confidence" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.min_confidence = parsed.clamp(0.0, 1.0);
-                }
-            }
-            "warmup_ticks" => {
-                if let Ok(parsed) = val.parse::<usize>() {
-                    cfg.warmup_ticks = parsed.max(1);
-                }
-            }
-            _ => {}
-        }
-    }
-    cfg
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-struct UniverseConfig {
-    assets: Vec<String>,
-    market_types: Vec<String>,
-    timeframes: Vec<String>,
-    tier_whitelist: Vec<String>,
-    tier_blacklist: Vec<String>,
-}
-
-impl Default for UniverseConfig {
-    fn default() -> Self {
-        Self {
-            assets: vec![
-                "BTCUSDT".to_string(),
-                "ETHUSDT".to_string(),
-                "SOLUSDT".to_string(),
-                "XRPUSDT".to_string(),
-            ],
-            market_types: vec![
-                "updown".to_string(),
-                "above_below".to_string(),
-                "range".to_string(),
-            ],
-            timeframes: vec![
-                "5m".to_string(),
-                "15m".to_string(),
-                "1h".to_string(),
-                "1d".to_string(),
-            ],
-            tier_whitelist: Vec::new(),
-            tier_blacklist: Vec::new(),
-        }
-    }
-}
-
-fn parse_toml_array_of_strings(val: &str) -> Vec<String> {
-    let trimmed = val.trim();
-    if !(trimmed.starts_with('[') && trimmed.ends_with(']')) {
-        return Vec::new();
-    }
-    let inner = &trimmed[1..trimmed.len() - 1];
-    inner
-        .split(',')
-        .map(|s| s.trim().trim_matches('"').trim_matches('\'').to_string())
-        .filter(|s| !s.is_empty())
-        .collect::<Vec<_>>()
-}
-
-fn parse_toml_array_for_key(raw: &str, key: &str) -> Option<Vec<String>> {
-    let mut collecting = false;
-    let mut buf = String::new();
-
-    for line in raw.lines() {
-        let trimmed = line.trim();
-        if trimmed.is_empty() || trimmed.starts_with('#') {
-            continue;
-        }
-
-        if !collecting {
-            let Some((k, v)) = trimmed.split_once('=') else {
-                continue;
-            };
-            if k.trim() != key {
-                continue;
-            }
-            let value = v.trim();
-            buf.push_str(value);
-            collecting = !(value.starts_with('[') && value.ends_with(']'));
-            if !collecting {
-                break;
-            }
-            continue;
-        }
-
-        // Keep concatenating multiline array items until closing ']'.
-        buf.push_str(trimmed);
-        if trimmed.ends_with(']') {
-            break;
-        }
-    }
-
-    if buf.is_empty() {
-        return None;
-    }
-    let parsed = parse_toml_array_of_strings(&buf);
-    if parsed.is_empty() {
-        None
-    } else {
-        Some(parsed)
-    }
-}
-
-fn load_strategy_config() -> MakerConfig {
-    let path = Path::new("configs/strategy.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        return MakerConfig::default();
-    };
-    let mut cfg = MakerConfig::default();
-    let mut in_maker = false;
-    let mut in_taker = false;
-    let mut in_online = false;
-    for line in raw.lines() {
-        let line = line.trim();
-        if line.is_empty() || line.starts_with('#') {
-            continue;
-        }
-        if line.starts_with('[') && line.ends_with(']') {
-            in_maker = line == "[maker]";
-            in_taker = line == "[taker]";
-            in_online = line == "[online_calibration]";
-            continue;
-        }
-        let Some((k, v)) = line.split_once('=') else {
-            continue;
-        };
-        let key = k.trim();
-        let val = v.trim().trim_matches('"');
-        if in_maker {
-            match key {
-                "base_quote_size" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.base_quote_size = parsed.max(0.01);
-                    }
-                }
-                "min_edge_bps" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.min_edge_bps = parsed.max(0.0);
-                    }
-                }
-                "inventory_skew" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.inventory_skew = parsed.clamp(0.0, 1.0);
-                    }
-                }
-                "max_spread" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.max_spread = parsed.max(0.0001);
-                    }
-                }
-                "ttl_ms" => {
-                    if let Ok(parsed) = val.parse::<u64>() {
-                        cfg.ttl_ms = parsed.max(50);
-                    }
-                }
-                _ => {}
-            }
-        } else if in_taker {
-            match key {
-                "trigger_bps" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.taker_trigger_bps = parsed.max(0.0);
-                    }
-                }
-                "max_slippage_bps" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.taker_max_slippage_bps = parsed.max(0.0);
-                    }
-                }
-                "stale_tick_filter_ms" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.stale_tick_filter_ms = parsed.clamp(50.0, 5_000.0);
-                    }
-                }
-                "market_tier_profile" => {
-                    cfg.market_tier_profile = val.to_string();
-                }
-                _ => {}
-            }
-        } else if in_online {
-            match key {
-                "capital_fraction_kelly" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.capital_fraction_kelly = parsed.clamp(0.01, 1.0);
-                    }
-                }
-                "variance_penalty_lambda" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.variance_penalty_lambda = parsed.clamp(0.0, 5.0);
-                    }
-                }
-                "min_eval_notional_usdc" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.min_eval_notional_usdc = parsed.max(0.0);
-                    }
-                }
-                "min_expected_edge_usdc" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.min_expected_edge_usdc = parsed.max(0.0);
-                    }
-                }
-                _ => {}
-            }
-        }
-    }
-    cfg
-}
-
-fn load_risk_limits_config() -> RiskLimits {
-    let path = Path::new("configs/risk.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        let mut defaults = RiskLimits::default();
-        defaults.max_drawdown_pct = 0.015;
-        return defaults;
-    };
-    let mut cfg = RiskLimits::default();
-    cfg.max_drawdown_pct = 0.015;
-    let mut in_max = false;
-    for line in raw.lines() {
-        let line = line.trim();
-        if line.is_empty() || line.starts_with('#') {
-            continue;
-        }
-        if line.starts_with('[') && line.ends_with(']') {
-            in_max = line == "[max]";
-            continue;
-        }
-        let Some((k, v)) = line.split_once('=') else {
-            continue;
-        };
-        let key = k.trim();
-        let val = v.trim().trim_matches('"');
-        if in_max {
-            match key {
-                "market_notional" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.max_market_notional = parsed.max(0.0);
-                    }
-                }
-                "asset_notional" => {
-                    if let Ok(parsed) = val.parse::<f64>() {
-                        cfg.max_asset_notional = parsed.max(0.0);
-                    }
-                }
-                "open_orders" => {
-                    if let Ok(parsed) = val.parse::<usize>() {
-                        cfg.max_open_orders = parsed.max(1);
-                    }
-                }
-                "max_loss_streak" => {
-                    if let Ok(parsed) = val.parse::<u32>() {
-                        cfg.max_loss_streak = parsed.max(1);
-                    }
-                }
-                "cooldown_sec" => {
-                    if let Ok(parsed) = val.parse::<u64>() {
-                        cfg.cooldown_sec = parsed.max(1);
-                    }
-                }
-                _ => {}
-            }
-        }
-        if key == "drawdown_stop_pct" {
-            if let Ok(parsed) = val.parse::<f64>() {
-                cfg.max_drawdown_pct = parsed.clamp(0.001, 1.0);
-            }
-        } else if key == "max_loss_streak" {
-            if let Ok(parsed) = val.parse::<u32>() {
-                cfg.max_loss_streak = parsed.max(1);
-            }
-        } else if key == "cooldown_sec" {
-            if let Ok(parsed) = val.parse::<u64>() {
-                cfg.cooldown_sec = parsed.max(1);
-            }
-        }
-    }
-    cfg
-}
-
-fn load_execution_config() -> ExecutionConfig {
-    let path = Path::new("configs/execution.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        return ExecutionConfig::default();
-    };
-    let mut cfg = ExecutionConfig::default();
-    let mut in_execution = false;
-    for line in raw.lines() {
-        let line = line.trim();
-        if line.is_empty() || line.starts_with('#') {
-            continue;
-        }
-        if line.starts_with('[') && line.ends_with(']') {
-            in_execution = line == "[execution]";
-            continue;
-        }
-        if !in_execution {
-            continue;
-        }
-        let Some((k, v)) = line.split_once('=') else {
-            continue;
-        };
-        let key = k.trim();
-        let val = v.trim().trim_matches('"');
-        match key {
-            "mode" => cfg.mode = val.to_string(),
-            "rate_limit_rps" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.rate_limit_rps = parsed.max(0.1);
-                }
-            }
-            "http_timeout_ms" => {
-                if let Ok(parsed) = val.parse::<u64>() {
-                    cfg.http_timeout_ms = parsed.max(100);
-                }
-            }
-            "clob_endpoint" => cfg.clob_endpoint = val.to_string(),
-            _ => {}
-        }
-    }
-    cfg
-}
-
-fn load_universe_config() -> UniverseConfig {
-    let path = Path::new("configs/universe.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        return UniverseConfig::default();
-    };
-    let mut cfg = UniverseConfig::default();
-    if let Some(parsed) = parse_toml_array_for_key(&raw, "assets") {
-        cfg.assets = parsed;
-    }
-    if let Some(parsed) = parse_toml_array_for_key(&raw, "market_types") {
-        cfg.market_types = parsed;
-    }
-    if let Some(parsed) = parse_toml_array_for_key(&raw, "timeframes") {
-        cfg.timeframes = parsed;
-    }
-    if let Some(parsed) = parse_toml_array_for_key(&raw, "tier_whitelist") {
-        cfg.tier_whitelist = parsed;
-    }
-    if let Some(parsed) = parse_toml_array_for_key(&raw, "tier_blacklist") {
-        cfg.tier_blacklist = parsed;
-    }
-    cfg
-}
-
-fn load_perf_profile_config() -> PerfProfile {
-    let path = Path::new("configs/latency.toml");
-    let Ok(raw) = fs::read_to_string(path) else {
-        return PerfProfile::default();
-    };
-
-    let mut cfg = PerfProfile::default();
-    let mut in_runtime = false;
-    for line in raw.lines() {
-        let line = line.trim();
-        if line.is_empty() || line.starts_with('#') {
-            continue;
-        }
-        if line.starts_with('[') && line.ends_with(']') {
-            in_runtime = line == "[runtime]";
-            continue;
-        }
-        if !in_runtime {
-            continue;
-        }
-        let Some((k, v)) = line.split_once('=') else {
-            continue;
-        };
-        let key = k.trim();
-        let val = v.trim().trim_matches('"');
-        match key {
-            "tail_guard" => {
-                if let Ok(parsed) = val.parse::<f64>() {
-                    cfg.tail_guard = parsed.clamp(0.50, 0.9999);
-                }
-            }
-            "io_flush_batch" => {
-                if let Ok(parsed) = val.parse::<usize>() {
-                    cfg.io_flush_batch = parsed.clamp(1, 4096);
-                }
-            }
-            "io_queue_capacity" => {
-                if let Ok(parsed) = val.parse::<usize>() {
-                    cfg.io_queue_capacity = parsed.clamp(256, 262_144);
-                }
-            }
-            "json_mode" => {
-                cfg.json_mode = val.to_string();
-            }
-            "io_drop_on_full" => {
-                if let Ok(parsed) = val.parse::<bool>() {
-                    cfg.io_drop_on_full = parsed;
-                }
-            }
-            _ => {}
-        }
-    }
-    cfg
-}
-
-fn ensure_dataset_dirs() {
-    for bucket in ["raw", "normalized", "reports"] {
-        let path = dataset_dir(bucket);
-        let _ = fs::create_dir_all(path);
-    }
-}
-
-fn dataset_date() -> String {
-    Utc::now().format("%Y-%m-%d").to_string()
-}
-
-fn dataset_dir(kind: &str) -> PathBuf {
-    PathBuf::from("datasets").join(kind).join(dataset_date())
-}
-
-fn dataset_path(kind: &str, filename: &str) -> PathBuf {
-    dataset_dir(kind).join(filename)
-}
-
-fn sha256_hex(input: &str) -> String {
-    let mut hasher = Sha256::new();
-    hasher.update(input.as_bytes());
-    format!("{:x}", hasher.finalize())
-}
-
-fn count_jsonl_lines(path: &Path) -> i64 {
-    let Ok(raw) = fs::read_to_string(path) else {
-        return 0;
-    };
-    raw.lines().filter(|l| !l.trim().is_empty()).count() as i64
-}
-
-#[derive(Debug)]
-struct JsonlWriteReq {
-    path: PathBuf,
-    line: String,
-}
-
-static JSONL_WRITER: OnceLock<mpsc::Sender<JsonlWriteReq>> = OnceLock::new();
-static JSONL_QUEUE_DEPTH: AtomicU64 = AtomicU64::new(0);
-static JSONL_QUEUE_CAP: AtomicU64 = AtomicU64::new(0);
-static JSONL_DROP_ON_FULL: AtomicBool = AtomicBool::new(true);
-static NORMALIZED_INGEST_SEQ: AtomicU64 = AtomicU64::new(0);
-
-fn next_normalized_ingest_seq() -> u64 {
-    NORMALIZED_INGEST_SEQ.fetch_add(1, Ordering::Relaxed) + 1
-}
-
-async fn init_jsonl_writer(perf_profile: Arc<RwLock<PerfProfile>>) {
-    if JSONL_WRITER.get().is_some() {
-        return;
-    }
-    let cfg = perf_profile.read().await.clone();
-    let (tx, mut rx) = mpsc::channel::<JsonlWriteReq>(cfg.io_queue_capacity.max(256));
-    JSONL_QUEUE_CAP.store(cfg.io_queue_capacity.max(256) as u64, Ordering::Relaxed);
-    JSONL_DROP_ON_FULL.store(cfg.io_drop_on_full, Ordering::Relaxed);
-    if JSONL_WRITER.set(tx.clone()).is_err() {
-        return;
-    }
-    tokio::spawn(async move {
-        let mut batch = Vec::<JsonlWriteReq>::new();
-        let mut ticker = tokio::time::interval(Duration::from_millis(200));
-        loop {
-            tokio::select! {
-                maybe_req = rx.recv() => {
-                    match maybe_req {
-                        Some(req) => {
-                            batch.push(req);
-                            let flush_batch = perf_profile.read().await.io_flush_batch.max(1);
-                            if batch.len() >= flush_batch {
-                                let to_flush = std::mem::take(&mut batch);
-                                let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
-                            }
-                        }
-                        None => {
-                            if !batch.is_empty() {
-                                let to_flush = std::mem::take(&mut batch);
-                                let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
-                            }
-                            break;
-                        }
-                    }
-                }
-                _ = ticker.tick() => {
-                    if !batch.is_empty() {
-                        let to_flush = std::mem::take(&mut batch);
-                        let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
-                    }
-                }
-            }
-            let cap = JSONL_QUEUE_CAP.load(Ordering::Relaxed) as usize;
-            JSONL_QUEUE_DEPTH.store(cap.saturating_sub(tx.capacity()) as u64, Ordering::Relaxed);
-        }
-    });
-}
-
-fn flush_jsonl_batch_sync(batch: Vec<JsonlWriteReq>) {
-    let mut grouped = HashMap::<PathBuf, Vec<String>>::new();
-    for req in batch {
-        grouped.entry(req.path).or_default().push(req.line);
-    }
-    for (path, lines) in grouped {
-        if let Some(parent) = path.parent() {
-            let _ = fs::create_dir_all(parent);
-        }
-        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&path) {
-            for line in lines {
-                let _ = writeln!(file, "{line}");
-            }
-        }
-    }
-}
-
-fn current_jsonl_queue_depth() -> u64 {
-    JSONL_QUEUE_DEPTH.load(Ordering::Relaxed)
-}
-
-fn append_jsonl_sync(path: &Path, line: &str) {
-    if let Some(parent) = path.parent() {
-        let _ = fs::create_dir_all(parent);
-    }
-    if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(path) {
-        let _ = writeln!(file, "{line}");
-    }
-}
-
-fn append_jsonl_line(path: &Path, line: String) {
-    if let Some(tx) = JSONL_WRITER.get() {
-        let req = JsonlWriteReq {
-            path: path.to_path_buf(),
-            line,
-        };
-        match tx.try_send(req) {
-            Ok(_) => {
-                let cap = JSONL_QUEUE_CAP.load(Ordering::Relaxed) as usize;
-                JSONL_QUEUE_DEPTH.store(cap.saturating_sub(tx.capacity()) as u64, Ordering::Relaxed);
-                return;
-            }
-            Err(tokio::sync::mpsc::error::TrySendError::Full(req)) => {
-                metrics::counter!("io.jsonl.queue_full").increment(1);
-                if JSONL_DROP_ON_FULL.load(Ordering::Relaxed) {
-                    metrics::counter!("io.jsonl.dropped").increment(1);
-                    return;
-                }
-                append_jsonl_sync(&req.path, &req.line);
-                return;
-            }
-            Err(tokio::sync::mpsc::error::TrySendError::Closed(req)) => {
-                metrics::counter!("io.jsonl.queue_closed").increment(1);
-                if JSONL_DROP_ON_FULL.load(Ordering::Relaxed) {
-                    metrics::counter!("io.jsonl.dropped").increment(1);
-                    return;
-                }
-                append_jsonl_sync(&req.path, &req.line);
-                return;
-            }
-        }
-    }
-    append_jsonl_sync(path, &line);
-}
-
-fn append_jsonl(path: &Path, value: &serde_json::Value) {
-    append_jsonl_line(path, value.to_string());
-}
-
-fn persist_live_report_files(live: &ShadowLiveReport) {
-    let reports_dir = dataset_dir("reports");
-    let _ = fs::create_dir_all(&reports_dir);
-
-    let live_json_path = reports_dir.join("shadow_live_latest.json");
-    if let Ok(raw) = serde_json::to_string_pretty(live) {
-        let _ = fs::write(live_json_path, raw);
-    }
-}
-
-fn persist_engine_pnl_report(report: &EnginePnlReport) {
-    let reports_dir = dataset_dir("reports");
-    let _ = fs::create_dir_all(&reports_dir);
-
-    let json_path = reports_dir.join("engine_pnl_breakdown_latest.json");
-    if let Ok(raw) = serde_json::to_string_pretty(report) {
-        let _ = fs::write(json_path, raw);
-    }
-
-    let csv_path = reports_dir.join("engine_pnl_breakdown.csv");
-    let mut rows = String::new();
-    rows.push_str("window_id,engine,samples,total_usdc,p50_usdc,p10_usdc,positive_ratio\n");
-    for row in &report.rows {
-        rows.push_str(&format!(
-            "{},{},{},{:.6},{:.6},{:.6},{:.6}\n",
-            report.window_id,
-            row.engine,
-            row.samples,
-            row.total_usdc,
-            row.p50_usdc,
-            row.p10_usdc,
-            row.positive_ratio
-        ));
-    }
-    let _ = fs::write(csv_path, rows);
-}
-
-fn persist_final_report_files(report: &ShadowFinalReport) {
-    let reports_dir = dataset_dir("reports");
-    let _ = fs::create_dir_all(&reports_dir);
-
-    let md_path = reports_dir.join("report_shadow_12h.md");
-    let gate_label = if report.gate.pass { "PASS" } else { "FAIL" };
-    let mut md = String::new();
-    md.push_str("# Shadow 12h Report\n\n");
-    md.push_str(&format!("- gate: {gate_label}\n"));
-    md.push_str(&format!(
-        "- fillability@10ms: {:.4}\n",
-        report.gate.fillability_10ms
-    ));
-    md.push_str(&format!(
-        "- net_edge_p50_bps: {:.4}\n",
-        report.gate.net_edge_p50_bps
-    ));
-    md.push_str(&format!(
-        "- net_edge_p10_bps: {:.4}\n",
-        report.gate.net_edge_p10_bps
-    ));
-    md.push_str(&format!(
-        "- net_markout_10s_usdc_p50: {:.6}\n",
-        report.gate.net_markout_10s_usdc_p50
-    ));
-    md.push_str(&format!(
-        "- roi_notional_10s_bps_p50: {:.6}\n",
-        report.gate.roi_notional_10s_bps_p50
-    ));
-    md.push_str(&format!(
-        "- ev_net_usdc_p50: {:.6}\n",
-        report.gate.ev_net_usdc_p50
-    ));
-    md.push_str(&format!(
-        "- ev_net_usdc_p10: {:.6}\n",
-        report.gate.ev_net_usdc_p10
-    ));
-    md.push_str(&format!(
-        "- ev_positive_ratio: {:.4}\n",
-        report.gate.ev_positive_ratio
-    ));
-    md.push_str(&format!(
-        "- executed_over_eligible: {:.4}\n",
-        report.gate.executed_over_eligible
-    ));
-    md.push_str(&format!(
-        "- eligible_count: {}\n",
-        report.gate.eligible_count
-    ));
-    md.push_str(&format!(
-        "- executed_count: {}\n",
-        report.gate.executed_count
-    ));
-    md.push_str(&format!(
-        "- pnl_10s_p50_bps_raw: {:.4}\n",
-        report.gate.pnl_10s_p50_bps_raw
-    ));
-    md.push_str(&format!(
-        "- pnl_10s_p50_bps_robust: {:.4}\n",
-        report.gate.pnl_10s_p50_bps_robust
-    ));
-    md.push_str(&format!(
-        "- pnl_10s_sample_count: {}\n",
-        report.gate.pnl_10s_sample_count
-    ));
-    md.push_str(&format!(
-        "- pnl_10s_outlier_ratio: {:.4}\n",
-        report.gate.pnl_10s_outlier_ratio
-    ));
-    md.push_str(&format!(
-        "- quote_block_ratio: {:.4}\n",
-        report.gate.quote_block_ratio
-    ));
-    md.push_str(&format!(
-        "- policy_block_ratio: {:.4}\n",
-        report.gate.policy_block_ratio
-    ));
-    md.push_str(&format!(
-        "- strategy_uptime_pct: {:.2}\n",
-        report.gate.strategy_uptime_pct
-    ));
-    md.push_str(&format!(
-        "- data_valid_ratio: {:.5}\n",
-        report.gate.data_valid_ratio
-    ));
-    md.push_str(&format!(
-        "- seq_gap_rate: {:.5}\n",
-        report.gate.seq_gap_rate
-    ));
-    md.push_str(&format!(
-        "- ts_inversion_rate: {:.5}\n",
-        report.gate.ts_inversion_rate
-    ));
-    md.push_str(&format!(
-        "- stale_tick_drop_ratio: {:.5}\n",
-        report.gate.stale_tick_drop_ratio
-    ));
-    md.push_str(&format!(
-        "- tick_to_ack_p99_ms: {:.4}\n\n",
-        report.gate.tick_to_ack_p99_ms
-    ));
-    md.push_str(&format!(
-        "- tick_to_decision_p99_ms: {:.4}\n",
-        report.live.tick_to_decision_p99_ms
-    ));
-    md.push_str(&format!(
-        "- ack_only_p99_ms: {:.4}\n",
-        report.live.ack_only_p99_ms
-    ));
-    md.push_str(&format!(
-        "- decision_queue_wait_p99_ms: {:.4}\n",
-        report.gate.decision_queue_wait_p99_ms
-    ));
-    md.push_str(&format!(
-        "- decision_compute_p99_ms: {:.4}\n",
-        report.gate.decision_compute_p99_ms
-    ));
-    md.push_str(&format!(
-        "- source_latency_p99_ms: {:.4}\n",
-        report.gate.source_latency_p99_ms
-    ));
-    md.push_str(&format!(
-        "- local_backlog_p99_ms: {:.4}\n",
-        report.gate.local_backlog_p99_ms
-    ));
-    md.push_str(&format!(
-        "- queue_depth_p99: {:.4}\n",
-        report.live.queue_depth_p99
-    ));
-    md.push_str(&format!(
-        "- event_backlog_p99: {:.4}\n\n",
-        report.live.event_backlog_p99
-    ));
-    md.push_str(&format!(
-        "- quote_attempted: {}\n- quote_blocked: {}\n- policy_blocked: {}\n- ref_ticks_total: {}\n- book_ticks_total: {}\n- ref_freshness_ms: {}\n- book_freshness_ms: {}\n\n",
-        report.live.quote_attempted,
-        report.live.quote_blocked,
-        report.live.policy_blocked,
-        report.live.ref_ticks_total,
-        report.live.book_ticks_total,
-        report.live.ref_freshness_ms,
-        report.live.book_freshness_ms
-    ));
-    if report.gate.failed_reasons.is_empty() {
-        md.push_str("## Failed Reasons\n- none\n");
-    } else {
-        md.push_str("## Failed Reasons\n");
-        for reason in &report.gate.failed_reasons {
-            md.push_str(&format!("- {reason}\n"));
-        }
-    }
-    if report.live.blocked_reason_counts.is_empty() {
-        md.push_str("\n## Blocked Reasons\n- none\n");
-    } else {
-        md.push_str("\n## Blocked Reasons\n");
-        let mut rows = report.live.blocked_reason_counts.iter().collect::<Vec<_>>();
-        rows.sort_by(|a, b| b.1.cmp(a.1));
-        for (reason, count) in rows {
-            md.push_str(&format!("- {}: {}\n", reason, count));
-        }
-    }
-    let _ = fs::write(md_path, md);
-
-    let latency_csv = reports_dir.join("latency_breakdown_12h.csv");
-    let mut latency_rows = String::new();
-    latency_rows.push_str("stage,p50,p90,p99,unit\n");
-    latency_rows.push_str(&format!(
-        "feed_in,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.feed_in_p50_ms,
-        report.live.latency.feed_in_p90_ms,
-        report.live.latency.feed_in_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "signal,{:.6},{:.6},{:.6},us\n",
-        report.live.latency.signal_p50_us,
-        report.live.latency.signal_p90_us,
-        report.live.latency.signal_p99_us
-    ));
-    latency_rows.push_str(&format!(
-        "quote,{:.6},{:.6},{:.6},us\n",
-        report.live.latency.quote_p50_us,
-        report.live.latency.quote_p90_us,
-        report.live.latency.quote_p99_us
-    ));
-    latency_rows.push_str(&format!(
-        "risk,{:.6},{:.6},{:.6},us\n",
-        report.live.latency.risk_p50_us,
-        report.live.latency.risk_p90_us,
-        report.live.latency.risk_p99_us
-    ));
-    latency_rows.push_str(&format!(
-        "decision_queue_wait,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.decision_queue_wait_p50_ms,
-        report.live.latency.decision_queue_wait_p90_ms,
-        report.live.latency.decision_queue_wait_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "decision_compute,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.decision_compute_p50_ms,
-        report.live.latency.decision_compute_p90_ms,
-        report.live.latency.decision_compute_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "tick_to_decision,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.tick_to_decision_p50_ms,
-        report.live.latency.tick_to_decision_p90_ms,
-        report.live.latency.tick_to_decision_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "ack_only,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.ack_only_p50_ms,
-        report.live.latency.ack_only_p90_ms,
-        report.live.latency.ack_only_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "tick_to_ack,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.tick_to_ack_p50_ms,
-        report.live.latency.tick_to_ack_p90_ms,
-        report.live.latency.tick_to_ack_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "parse,{:.6},{:.6},{:.6},us\n",
-        0.0, 0.0, report.live.latency.parse_p99_us
-    ));
-    latency_rows.push_str(&format!(
-        "io_queue,{:.6},{:.6},{:.6},count\n",
-        0.0, 0.0, report.live.latency.io_queue_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "bus_lag,{:.6},{:.6},{:.6},count\n",
-        0.0, 0.0, report.live.latency.bus_lag_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "shadow_fill,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.shadow_fill_p50_ms,
-        report.live.latency.shadow_fill_p90_ms,
-        report.live.latency.shadow_fill_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "source_latency,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.source_latency_p50_ms,
-        report.live.latency.source_latency_p90_ms,
-        report.live.latency.source_latency_p99_ms
-    ));
-    latency_rows.push_str(&format!(
-        "local_backlog,{:.6},{:.6},{:.6},ms\n",
-        report.live.latency.local_backlog_p50_ms,
-        report.live.latency.local_backlog_p90_ms,
-        report.live.latency.local_backlog_p99_ms
-    ));
-    let _ = fs::write(latency_csv, latency_rows);
-
-    let score_path = reports_dir.join("market_scorecard.csv");
-    let mut score_rows = String::new();
-    score_rows.push_str("market_id,symbol,shots,outcomes,fillability_10ms,net_edge_p50_bps,net_edge_p10_bps,pnl_10s_p50_bps,net_markout_10s_usdc_p50,roi_notional_10s_bps_p50\n");
-    for row in &report.live.market_scorecard {
-        score_rows.push_str(&format!(
-            "{},{},{},{},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6}\n",
-            row.market_id,
-            row.symbol,
-            row.shots,
-            row.outcomes,
-            row.fillability_10ms,
-            row.net_edge_p50_bps,
-            row.net_edge_p10_bps,
-            row.pnl_10s_p50_bps,
-            row.net_markout_10s_usdc_p50,
-            row.roi_notional_10s_bps_p50
-        ));
-    }
-    let _ = fs::write(score_path, score_rows);
-
-    let fixlist_path = reports_dir.join("next_fixlist.md");
-    let mut fixlist = String::new();
-    fixlist.push_str("# Next Fixlist\n\n");
-    if report.gate.failed_reasons.is_empty() {
-        fixlist.push_str("- Gate passed. Keep conservative limits and continue monitoring.\n");
-    } else {
-        for reason in &report.gate.failed_reasons {
-            fixlist.push_str(&format!("- {reason}\n"));
-        }
-    }
-    let _ = fs::write(fixlist_path, fixlist);
-
-    let truth_manifest_path = reports_dir.join("truth_manifest.json");
-    let truth_manifest = serde_json::json!({
-        "generated_at_utc": Utc::now().to_rfc3339(),
-        "metrics_contract_version": "2026-02-14.v1",
-        "window": {
-            "window_id": report.live.window_id,
-            "window_shots": report.live.window_shots,
-            "window_outcomes": report.live.window_outcomes,
-            "gate_ready": report.live.gate_ready,
-        },
-        "data_chain": {
-            "raw_fields": ["sha256", "source_seq", "ingest_seq", "event_ts_exchange_ms", "recv_ts_local_ns"],
-            "normalized_fields": ["source_seq", "ingest_seq", "market_id", "symbol", "delay_ms", "fillable", "net_markout_10s_usdc"],
-            "invalid_excluded_from_gate": true
-        },
-        "formulas": {
-            "quote_block_ratio": "quote_blocked / (quote_attempted + quote_blocked)",
-            "policy_block_ratio": "policy_blocked / (quote_attempted + policy_blocked)",
-            "policy_blocked_scope": "risk:* and risk_capped_zero only",
-            "executed_over_eligible": "executed_count / eligible_count",
-            "ev_net_usdc_p50": "p50(net_markout_10s_usdc)",
-            "ev_positive_ratio": "count(net_markout_10s_usdc > 0) / count(valid outcomes)"
-        },
-        "hard_gates": {
-            "data_valid_ratio_min": 0.999,
-            "seq_gap_rate_max": 0.001,
-            "ts_inversion_rate_max": 0.0005,
-            "tick_to_ack_p99_ms_max": 450.0,
-            "decision_compute_p99_ms_max": 2.0,
-            "feed_in_p99_ms_max": 800.0,
-            "executed_over_eligible_min": 0.60,
-            "quote_block_ratio_max": 0.10,
-            "policy_block_ratio_max": 0.10,
-            "ev_net_usdc_p50_min": 0.0,
-            "roi_notional_10s_bps_p50_min": 0.0
-        }
-    });
-    if let Ok(raw) = serde_json::to_string_pretty(&truth_manifest) {
-        let _ = fs::write(truth_manifest_path, raw);
-    }
-}
-
-fn persist_toxicity_report_files(report: &ToxicityLiveReport) {
-    let reports_dir = dataset_dir("reports");
-    let _ = fs::create_dir_all(&reports_dir);
-
-    let live_json_path = reports_dir.join("toxicity_live_latest.json");
-    if let Ok(raw) = serde_json::to_string_pretty(report) {
-        let _ = fs::write(live_json_path, raw);
-    }
-
-    let csv_path = reports_dir.join("toxicity_scorecard.csv");
-    let mut rows = String::new();
-    rows.push_str("market_rank,active_for_quoting,market_id,symbol,tox_score,regime,market_score,markout_10s_bps,no_quote_rate,symbol_missing_rate,pending_exposure\n");
-    for row in &report.rows {
-        rows.push_str(&format!(
-            "{},{},{},{},{:.6},{:?},{:.6},{:.6},{:.6},{:.6},{:.6}\n",
-            row.market_rank,
-            row.active_for_quoting,
-            row.market_id,
-            row.symbol,
-            row.tox_score,
-            row.regime,
-            row.market_score,
-            row.markout_10s_bps,
-            row.no_quote_rate,
-            row.symbol_missing_rate,
-            row.pending_exposure
-        ));
-    }
-    let _ = fs::write(csv_path, rows);
-}
-
-fn fillability_ratio(outcomes: &[ShadowOutcome], delay_ms: u64) -> f64 {
-    let scoped = outcomes
-        .iter()
-        .filter(|o| o.delay_ms == delay_ms)
-        .collect::<Vec<_>>();
-    if scoped.is_empty() {
-        return 0.0;
-    }
-    let filled = scoped.iter().filter(|o| o.fillable).count();
-    filled as f64 / scoped.len() as f64
-}
-
-fn survival_ratio(outcomes: &[ShadowOutcome], delay_ms: u64) -> f64 {
-    let scoped = outcomes
-        .iter()
-        .filter(|o| o.delay_ms == delay_ms)
-        .collect::<Vec<_>>();
-    if scoped.is_empty() {
-        return 0.0;
-    }
-    let survived = scoped.iter().filter(|o| o.survived).count();
-    survived as f64 / scoped.len() as f64
-}
-
-fn build_market_scorecard(shots: &[ShadowShot], outcomes: &[ShadowOutcome]) -> Vec<MarketScoreRow> {
-    const PRIMARY_DELAY_MS: u64 = 10;
-    let mut keys: HashMap<(String, String), ()> = HashMap::new();
-    for shot in shots {
-        keys.insert((shot.market_id.clone(), shot.symbol.clone()), ());
-    }
-    for outcome in outcomes {
-        keys.insert((outcome.market_id.clone(), outcome.symbol.clone()), ());
-    }
-
-    let mut rows = Vec::new();
-    for (market_id, symbol) in keys.into_keys() {
-        let market_shots = shots
-            .iter()
-            .filter(|s| s.market_id == market_id && s.symbol == symbol)
-            .cloned()
-            .collect::<Vec<_>>();
-        let market_outcomes = outcomes
-            .iter()
-            .filter(|o| o.market_id == market_id && o.symbol == symbol)
-            .cloned()
-            .collect::<Vec<_>>();
-        let market_shots_primary = market_shots
-            .iter()
-            .filter(|s| s.delay_ms == PRIMARY_DELAY_MS)
-            .collect::<Vec<_>>();
-        let market_outcomes_primary = market_outcomes
-            .iter()
-            .filter(|o| o.delay_ms == PRIMARY_DELAY_MS)
-            .collect::<Vec<_>>();
-
-        let net_edges = market_shots_primary
-            .iter()
-            .map(|s| s.edge_net_bps)
-            .collect::<Vec<_>>();
-        let pnl_10s = market_outcomes_primary
-            .iter()
-            .filter_map(|o| o.net_markout_10s_bps.or(o.pnl_10s_bps))
-            .collect::<Vec<_>>();
-        let net_markout_10s_usdc = market_outcomes_primary
-            .iter()
-            .filter_map(|o| o.net_markout_10s_usdc)
-            .collect::<Vec<_>>();
-        let roi_notional_10s_bps = market_outcomes_primary
-            .iter()
-            .filter_map(|o| o.roi_notional_10s_bps)
-            .collect::<Vec<_>>();
-
-        rows.push(MarketScoreRow {
-            market_id,
-            symbol,
-            shots: market_shots_primary.len(),
-            outcomes: market_outcomes_primary.len(),
-            fillability_10ms: fillability_ratio(&market_outcomes, 10),
-            net_edge_p50_bps: percentile(&net_edges, 0.50).unwrap_or(0.0),
-            net_edge_p10_bps: percentile(&net_edges, 0.10).unwrap_or(0.0),
-            pnl_10s_p50_bps: percentile(&pnl_10s, 0.50).unwrap_or(0.0),
-            net_markout_10s_usdc_p50: percentile(&net_markout_10s_usdc, 0.50).unwrap_or(0.0),
-            roi_notional_10s_bps_p50: percentile(&roi_notional_10s_bps, 0.50).unwrap_or(0.0),
-        });
-    }
-
-    rows.sort_by(|a, b| {
-        b.net_markout_10s_usdc_p50
-            .total_cmp(&a.net_markout_10s_usdc_p50)
-    });
-    rows
-}
+pub(crate) use engine_loop::{
+    spawn_predator_exit_lifecycle, spawn_shadow_outcome_task, spawn_strategy_engine,
+    PredatorExecResult,
+};
 
 #[cfg(test)]
-mod tests {
-    use super::*;
-    use core_types::QuoteIntent;
-
-    #[test]
-    fn robust_filter_marks_outliers() {
-        let values = vec![1.0, 1.1, 1.2, 1.3, 99.0];
-        let (filtered, outlier_ratio) = robust_filter_iqr(&values);
-        assert!(filtered.len() < values.len());
-        assert!(outlier_ratio > 0.0);
-    }
-
-    #[test]
-    fn robust_filter_small_sample_passthrough() {
-        let values = vec![1.0, 2.0, 3.0, 4.0];
-        let (filtered, outlier_ratio) = robust_filter_iqr(&values);
-        assert_eq!(filtered, values);
-        assert_eq!(outlier_ratio, 0.0);
-    }
-
-    #[test]
-    fn percentile_basic_behavior() {
-        let values = vec![1.0, 5.0, 3.0, 2.0, 4.0];
-        assert_eq!(percentile(&values, 0.50), Some(3.0));
-        assert_eq!(percentile(&values, 0.0), Some(1.0));
-        assert_eq!(percentile(&values, 1.0), Some(5.0));
-    }
-
-    #[test]
-    fn classify_execution_style_for_yes_side() {
-        let book = BookTop {
-            market_id: "m".to_string(),
-            token_id_yes: "yes".to_string(),
-            token_id_no: "no".to_string(),
-            bid_yes: 0.49,
-            ask_yes: 0.51,
-            bid_no: 0.49,
-            ask_no: 0.51,
-            ts_ms: 1,
-            recv_ts_local_ns: 1_000_000,
-        };
-        let maker = QuoteIntent {
-            market_id: "m".to_string(),
-            side: OrderSide::BuyYes,
-            price: 0.50,
-            size: 1.0,
-            ttl_ms: 300,
-        };
-        let taker = QuoteIntent {
-            price: 0.51,
-            ..maker.clone()
-        };
-        assert_eq!(
-            classify_execution_style(&book, &maker),
-            ExecutionStyle::Maker
-        );
-        assert_eq!(
-            classify_execution_style(&book, &taker),
-            ExecutionStyle::Taker
-        );
-    }
-
-    #[test]
-    fn normalize_reject_code_sanitizes_non_alnum() {
-        let normalized = normalize_reject_code("HTTP 429/Too Many Requests");
-        assert_eq!(normalized, "http_429_too_many_requests");
-    }
-
-    #[test]
-    fn estimate_feed_latency_separates_source_and_backlog() {
-        let now = now_ns();
-        let now_ms = now / 1_000_000;
-        let tick = RefTick {
-            source: "binance_ws".to_string(),
-            symbol: "BTCUSDT".to_string(),
-            event_ts_ms: now_ms - 300,
-            recv_ts_ms: now_ms - 200,
-            event_ts_exchange_ms: now_ms - 300,
-            recv_ts_local_ns: now - 200_000_000,
-            price: 70_000.0,
-        };
-        let book = BookTop {
-            market_id: "m".to_string(),
-            token_id_yes: "yes".to_string(),
-            token_id_no: "no".to_string(),
-            bid_yes: 0.49,
-            ask_yes: 0.51,
-            bid_no: 0.49,
-            ask_no: 0.51,
-            ts_ms: now_ms - 40,
-            recv_ts_local_ns: now - 20_000_000,
-        };
-
-        let sample = estimate_feed_latency(&tick, &book);
-        assert!(sample.source_latency_ms >= 95.0);
-        assert!(sample.source_latency_ms <= 110.0);
-        assert!(sample.local_backlog_ms >= 10.0);
-        assert!(sample.local_backlog_ms <= 40.0);
-        assert!(sample.feed_in_ms >= sample.source_latency_ms);
-        assert!(
-            (sample.feed_in_ms - (sample.source_latency_ms + sample.local_backlog_ms)).abs() < 3.0
-        );
-    }
-
-    #[test]
-    fn should_force_taker_respects_profile_and_regime() {
-        let mut cfg = MakerConfig::default();
-        cfg.taker_trigger_bps = 10.0;
-        cfg.market_tier_profile = "balanced".to_string();
-
-        let safe = ToxicDecision {
-            market_id: "m".to_string(),
-            symbol: "BTCUSDT".to_string(),
-            tox_score: 0.1,
-            regime: ToxicRegime::Safe,
-            reason_codes: vec![],
-            ts_ns: 1,
-        };
-        assert!(should_force_taker(
-            &cfg, &safe, 12.0, 0.8, 30, 0.1, 40, 30, "BTCUSDT"
-        ));
-        assert!(!should_force_taker(
-            &cfg, &safe, 8.0, 0.8, 30, 0.1, 40, 30, "BTCUSDT"
-        ));
-        assert!(!should_force_taker(
-            &cfg, &safe, 12.0, 0.4, 30, 0.1, 40, 30, "BTCUSDT"
-        ));
-
-        let caution = ToxicDecision {
-            regime: ToxicRegime::Caution,
-            ..safe.clone()
-        };
-        assert!(!should_force_taker(
-            &cfg, &caution, 12.0, 0.8, 30, 0.1, 40, 30, "BTCUSDT"
-        ));
-        cfg.market_tier_profile = "latency_aggressive".to_string();
-        assert!(should_force_taker(
-            &cfg, &caution, 12.0, 0.8, 30, 0.1, 40, 30, "BTCUSDT"
-        ));
-    }
-
-    #[test]
-    fn adaptive_min_edge_bps_warmup_relaxes_threshold() {
-        let relaxed = adaptive_min_edge_bps(5.0, 0.3, 0, 0.95, 0.0, 0.0, 0, 30);
-        assert!(relaxed <= 1.0);
-        let progressed = adaptive_min_edge_bps(5.0, 0.3, 0, 0.20, 0.0, 0.0, 25, 30);
-        assert!(progressed >= relaxed);
-    }
-
-    #[test]
-    fn sol_guard_observe_only_for_high_latency_or_spread() {
-        let mut cfg = MakerConfig::default();
-        cfg.market_tier_profile = "balanced_sol_guard".to_string();
-        let tox = ToxicDecision {
-            market_id: "m".to_string(),
-            symbol: "SOLUSDT".to_string(),
-            tox_score: 0.2,
-            regime: ToxicRegime::Safe,
-            reason_codes: vec![],
-            ts_ns: 1,
-        };
-        assert!(should_observe_only_symbol(
-            "SOLUSDT", &cfg, &tox, 120.0, 0.01, 180.0
-        ));
-        assert!(should_observe_only_symbol(
-            "SOLUSDT", &cfg, &tox, 260.0, 0.01, 80.0
-        ));
-        assert!(should_observe_only_symbol(
-            "SOLUSDT", &cfg, &tox, 120.0, 0.03, 80.0
-        ));
-        assert!(!should_observe_only_symbol(
-            "SOLUSDT", &cfg, &tox, 120.0, 0.01, 80.0
-        ));
-        assert!(!should_observe_only_symbol(
-            "BTCUSDT", &cfg, &tox, 260.0, 0.03, 999.0
-        ));
-    }
-
-    #[test]
-    fn quote_block_ratio_matches_contract_and_is_bounded() {
-        assert_eq!(quote_block_ratio(0, 0), 0.0);
-        assert_eq!(quote_block_ratio(10, 0), 0.0);
-        assert_eq!(quote_block_ratio(0, 10), 1.0);
-
-        let r = quote_block_ratio(10, 2);
-        assert!(r > 0.0 && r < 1.0);
-    }
-
-    #[test]
-    fn policy_block_ratio_matches_contract_and_is_bounded() {
-        assert_eq!(policy_block_ratio(0, 0), 0.0);
-        assert_eq!(policy_block_ratio(10, 0), 0.0);
-        assert_eq!(policy_block_ratio(0, 10), 1.0);
-
-        let r = policy_block_ratio(10, 2);
-        assert!(r > 0.0 && r < 1.0);
-    }
-
-    #[test]
-    fn uptime_pct_is_bounded() {
-        let stats = ShadowStats::new();
-        let u = stats.uptime_pct(Duration::from_secs(1));
-        assert!((0.0..=100.0).contains(&u));
-    }
-
-    #[test]
-    fn parse_toml_array_for_key_handles_multiline_arrays() {
-        let raw = r#"
-assets = [
-  "BTCUSDT",
-  "ETHUSDT",
-  "XRPUSDT",
-]
-market_types = ["updown", "range"]
-timeframes = ["5m", "15m", "1h", "1d"]
-"#;
-        let assets = parse_toml_array_for_key(raw, "assets").unwrap_or_default();
-        assert_eq!(
-            assets,
-            vec![
-                "BTCUSDT".to_string(),
-                "ETHUSDT".to_string(),
-                "XRPUSDT".to_string()
-            ]
-        );
-        let market_types = parse_toml_array_for_key(raw, "market_types").unwrap_or_default();
-        assert_eq!(
-            market_types,
-            vec!["updown".to_string(), "range".to_string()]
-        );
-        let timeframes = parse_toml_array_for_key(raw, "timeframes").unwrap_or_default();
-        assert_eq!(
-            timeframes,
-            vec![
-                "5m".to_string(),
-                "15m".to_string(),
-                "1h".to_string(),
-                "1d".to_string()
-            ]
-        );
-    }
-
-    #[test]
-    fn parse_toml_array_for_key_returns_none_for_missing_or_empty() {
-        let raw = "foo = 1\nassets = []\n";
-        assert!(parse_toml_array_for_key(raw, "missing").is_none());
-        assert!(parse_toml_array_for_key(raw, "assets").is_none());
-    }
-}
+mod tests;
diff --git a/crates/app_runner/src/orchestration.rs b/crates/app_runner/src/orchestration.rs
index 34ba575..b156dce 100644
--- a/crates/app_runner/src/orchestration.rs
+++ b/crates/app_runner/src/orchestration.rs
@@ -1,12 +1,97 @@
-use super::*;
+use std::collections::HashMap;
+use std::fs;
+use std::io::{Read, Seek};
+use std::path::PathBuf;
+use std::sync::Arc;
+use std::time::{Duration, Instant};
+
+use chrono::Utc;
+use core_types::{ControlCommand, EngineEvent};
+use execution_clob::ClobExecution;
+use infra_bus::RingBus;
+use tokio::sync::RwLock;
+
+use crate::report_io::{
+    append_jsonl, dataset_path, persist_engine_pnl_report, persist_final_report_files,
+    persist_live_report_files, persist_toxicity_report_files,
+};
+use crate::state::{MarketToxicState, ShadowStats, ToxicityConfig};
+use crate::toxicity_report::build_toxicity_live_report;
+use crate::spawn_detached;
+
+#[derive(Debug, Clone, Default)]
+struct JsonlTailCounter {
+    /// Current file path being tracked (bucketed by date).
+    path: PathBuf,
+    /// Byte offset we have already scanned up to.
+    offset: u64,
+    /// Cumulative line count observed since the current baseline/rotation.
+    lines: i64,
+}
+
+impl JsonlTailCounter {
+    fn tick(mut self, path: PathBuf) -> Self {
+        // If the date rolled over (or path otherwise changed), reset baseline.
+        if self.path != path {
+            self.path = path;
+            self.offset = 0;
+            self.lines = 0;
+        }
+
+        let Ok(meta) = fs::metadata(&self.path) else {
+            return self;
+        };
+        let len = meta.len();
+
+        // Baseline: do not scan historical data on startup. We only care about deltas while the
+        // current process is running to detect drops/gaps in the JSONL writer.
+        if self.offset == 0 {
+            self.offset = len;
+            return self;
+        }
+
+        // Handle truncation/rotation.
+        if len < self.offset {
+            self.offset = len;
+            self.lines = 0;
+            return self;
+        }
+
+        let Ok(mut file) = std::fs::File::open(&self.path) else {
+            return self;
+        };
+        if file.seek(std::io::SeekFrom::Start(self.offset)).is_err() {
+            return self;
+        }
+
+        let mut buf = [0_u8; 64 * 1024];
+        let mut added: i64 = 0;
+        loop {
+            let Ok(n) = file.read(&mut buf) else {
+                break;
+            };
+            if n == 0 {
+                break;
+            }
+            for &b in &buf[..n] {
+                if b == b'\n' {
+                    added = added.saturating_add(1);
+                }
+            }
+        }
+        self.lines = self.lines.saturating_add(added);
+        self.offset = len;
+        self
+    }
+}
 
 pub(super) fn spawn_periodic_report_persistor(
     stats: Arc<ShadowStats>,
     tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
     execution: Arc<ClobExecution>,
-    toxicity_cfg: Arc<RwLock<ToxicityConfig>>,
+    toxicity_cfg: Arc<RwLock<Arc<ToxicityConfig>>>,
 ) {
-    tokio::spawn(async move {
+    spawn_detached("periodic_report_persistor", false, async move {
         let mut last_final = Instant::now() - Duration::from_secs(600);
         loop {
             let live = stats.build_live_report().await;
@@ -38,30 +123,81 @@ pub(super) fn spawn_data_reconcile_task(
     paused: Arc<RwLock<bool>>,
     stats: Arc<ShadowStats>,
 ) {
-    tokio::spawn(async move {
+    spawn_detached("data_reconcile_task", false, async move {
         let mut interval = tokio::time::interval(Duration::from_secs(600));
+        // The raw JSONL files are bucketed by date, while `ShadowStats` counters are reset on
+        // `/control/reset_shadow` (window reset). Comparing absolute totals would therefore
+        // generate false "gap" alarms after any reset. Track deltas between intervals and
+        // automatically re-baseline on resets/rotations.
+        let mut last_window_id: u64 = 0;
+        let mut last_ref_lines: i64 = 0;
+        let mut last_book_lines: i64 = 0;
+        let mut last_ref_expected: i64 = 0;
+        let mut last_book_expected: i64 = 0;
+        let mut ref_tail = JsonlTailCounter::default();
+        let mut book_tail = JsonlTailCounter::default();
         loop {
             interval.tick().await;
             let live = stats.build_live_report().await;
-            let ref_lines = count_jsonl_lines(&dataset_path("raw", "ref_ticks.jsonl"));
-            let book_lines = count_jsonl_lines(&dataset_path("raw", "book_tops.jsonl"));
+            let ref_path = dataset_path("raw", "ref_ticks.jsonl");
+            let book_path = dataset_path("raw", "book_tops.jsonl");
+            // Counting lines in multi-GB JSONL files must never allocate the whole file.
+            // We do a tail-based, incremental newline count in a blocking thread.
+            let (next_ref_tail, next_book_tail) = {
+                // We avoid moving the live state into the blocking closure so we can keep the
+                // current values on failure (panic/cancel).
+                let ref_state = ref_tail.clone();
+                let book_state = book_tail.clone();
+                match tokio::task::spawn_blocking(move || {
+                    (ref_state.tick(ref_path), book_state.tick(book_path))
+                })
+                .await
+                {
+                    Ok(v) => v,
+                    Err(_) => (ref_tail.clone(), book_tail.clone()),
+                }
+            };
+            ref_tail = next_ref_tail;
+            book_tail = next_book_tail;
+            let ref_lines = ref_tail.lines;
+            let book_lines = book_tail.lines;
             let ref_expected = live.ref_ticks_total as i64;
             let book_expected = live.book_ticks_total as i64;
-            let ref_gap_ratio = if ref_expected <= 0 {
-                0.0
-            } else {
-                ((ref_lines - ref_expected).abs() as f64) / (ref_expected as f64)
-            };
-            let book_gap_ratio = if book_expected <= 0 {
-                0.0
+            let baseline_reset = last_window_id == 0
+                || live.window_id != last_window_id
+                || ref_lines < last_ref_lines
+                || book_lines < last_book_lines
+                || ref_expected < last_ref_expected
+                || book_expected < last_book_expected;
+
+            let (ref_gap_ratio, book_gap_ratio) = if baseline_reset {
+                (0.0, 0.0)
             } else {
-                ((book_lines - book_expected).abs() as f64) / (book_expected as f64)
+                let ref_lines_delta = ref_lines - last_ref_lines;
+                let book_lines_delta = book_lines - last_book_lines;
+                let ref_expected_delta = ref_expected - last_ref_expected;
+                let book_expected_delta = book_expected - last_book_expected;
+                let ref_gap = if ref_expected_delta <= 0 {
+                    0.0
+                } else {
+                    ((ref_lines_delta - ref_expected_delta).abs() as f64)
+                        / (ref_expected_delta as f64)
+                };
+                let book_gap = if book_expected_delta <= 0 {
+                    0.0
+                } else {
+                    ((book_lines_delta - book_expected_delta).abs() as f64)
+                        / (book_expected_delta as f64)
+                };
+                (ref_gap, book_gap)
             };
-            let reconcile_fail = ref_gap_ratio > 0.05
-                || book_gap_ratio > 0.05
-                || live.data_valid_ratio < 0.999
-                || live.seq_gap_rate > 0.001
-                || live.ts_inversion_rate > 0.0005;
+
+            let reconcile_fail = !baseline_reset
+                && (ref_gap_ratio > 0.05
+                    || book_gap_ratio > 0.05
+                    || live.data_valid_ratio < 0.999
+                    || live.seq_gap_rate > 0.001
+                    || live.ts_inversion_rate > 0.0005);
 
             if reconcile_fail {
                 stats.set_observe_only(true);
@@ -86,9 +222,16 @@ pub(super) fn spawn_data_reconcile_task(
                     "ref_gap_ratio": ref_gap_ratio,
                     "book_gap_ratio": book_gap_ratio,
                     "reconcile_fail": reconcile_fail,
+                    "baseline_reset": baseline_reset,
                     "observe_only": stats.observe_only()
                 }),
             );
+
+            last_window_id = live.window_id;
+            last_ref_lines = ref_lines;
+            last_book_lines = book_lines;
+            last_ref_expected = ref_expected;
+            last_book_expected = book_expected;
         }
     });
 }
diff --git a/crates/app_runner/src/paper_runtime.rs b/crates/app_runner/src/paper_runtime.rs
new file mode 100644
index 0000000..366902d
--- /dev/null
+++ b/crates/app_runner/src/paper_runtime.rs
@@ -0,0 +1,997 @@
+use std::collections::{BTreeMap, HashMap, VecDeque};
+use std::path::PathBuf;
+use std::sync::Arc;
+use std::sync::OnceLock;
+
+use chrono::{TimeZone, Utc};
+use core_types::{
+    BookTop, Direction, ExecutionStyle, FillEvent, OrderAck, OrderSide, PaperAction, PaperDailySummary,
+    PaperFill, PaperIntent, PaperLiveReport, PaperTradeRecord, Stage,
+};
+use tokio::sync::RwLock;
+
+use crate::paper_sqlite::PaperSqliteWriter;
+use crate::report_io::{append_jsonl, dataset_path};
+use crate::seat_runtime::SeatRuntimeHandle;
+use crate::seat_types::SeatDecisionRecord;
+use crate::stats_utils::percentile;
+
+const HISTORY_CAP: usize = 20_000;
+
+static GLOBAL_PAPER_RUNTIME: OnceLock<Arc<PaperRuntimeHandle>> = OnceLock::new();
+
+#[derive(Debug, Clone)]
+pub(crate) struct PaperIntentCtx {
+    pub(crate) market_id: String,
+    pub(crate) symbol: String,
+    pub(crate) timeframe: String,
+    pub(crate) stage: Stage,
+    pub(crate) direction: Direction,
+    pub(crate) velocity_bps_per_sec: f64,
+    pub(crate) edge_bps: f64,
+    pub(crate) prob_fast: f64,
+    pub(crate) prob_settle: f64,
+    pub(crate) confidence: f64,
+    pub(crate) action: PaperAction,
+    pub(crate) intent: ExecutionStyle,
+    pub(crate) requested_size_usdc: f64,
+    pub(crate) requested_size_contracts: f64,
+    pub(crate) entry_price: f64,
+}
+
+#[derive(Debug, Clone)]
+struct PaperLot {
+    market_id: String,
+    symbol: String,
+    timeframe: String,
+    side: OrderSide,
+    stage: Stage,
+    direction: Direction,
+    velocity_bps_per_sec: f64,
+    edge_bps: f64,
+    prob_fast: f64,
+    prob_settle: f64,
+    confidence: f64,
+    intent: ExecutionStyle,
+    requested_size_usdc: f64,
+    entry_price: f64,
+    remaining_size: f64,
+    entry_fee_per_contract: f64,
+    opened_ts_ms: i64,
+    seat_layer: Option<String>,
+    tuned_params_before: Option<serde_json::Value>,
+    tuned_params_after: Option<serde_json::Value>,
+    rollback_triggered: Option<String>,
+    shadow_pnl_comparison: Option<f64>,
+}
+
+#[derive(Debug, Clone)]
+struct PaperDailyAgg {
+    starting_bankroll: f64,
+    ending_bankroll: f64,
+    trades: u64,
+    wins: u64,
+    fee_total_usdc: f64,
+    pnl_total_usdc: f64,
+    durations_ms: Vec<f64>,
+}
+
+#[derive(Default)]
+struct PaperRuntimeState {
+    bankroll: f64,
+    peak_bankroll: f64,
+    max_drawdown_pct: f64,
+    trades: u64,
+    wins: u64,
+    losses: u64,
+    fee_total_usdc: f64,
+    pnl_total_usdc: f64,
+    intents: HashMap<String, PaperIntent>,
+    open_lots: HashMap<String, VecDeque<PaperLot>>,
+    chainlink_aux_by_market: HashMap<String, f64>,
+    records: VecDeque<PaperTradeRecord>,
+    daily: BTreeMap<String, PaperDailyAgg>,
+}
+
+#[derive(Clone)]
+pub(crate) struct PaperRuntimeHandle {
+    enabled: bool,
+    run_id: String,
+    initial_capital: f64,
+    seat: Arc<SeatRuntimeHandle>,
+    sqlite: PaperSqliteWriter,
+    state: Arc<RwLock<PaperRuntimeState>>,
+}
+
+impl PaperRuntimeHandle {
+    pub(crate) fn new(
+        enabled: bool,
+        run_id: String,
+        initial_capital: f64,
+        sqlite_enabled: bool,
+        seat: Arc<SeatRuntimeHandle>,
+    ) -> Arc<Self> {
+        let sqlite_path = dataset_path("reports", "paper_summary.sqlite");
+        let sqlite = PaperSqliteWriter::spawn(sqlite_path, sqlite_enabled && enabled);
+        let mut state = PaperRuntimeState::default();
+        state.bankroll = initial_capital;
+        state.peak_bankroll = initial_capital;
+        Arc::new(Self {
+            enabled,
+            run_id,
+            initial_capital,
+            seat,
+            sqlite,
+            state: Arc::new(RwLock::new(state)),
+        })
+    }
+
+    pub(crate) async fn register_order_intent(&self, ack: &OrderAck, ctx: PaperIntentCtx) {
+        if !self.enabled {
+            return;
+        }
+        let seat_status = self.seat.status().await;
+        let last_decision = self.seat.history(1).into_iter().next();
+        let (tuned_before, tuned_after, rollback_triggered, shadow_pnl_comparison) =
+            extract_last_decision(last_decision.as_ref());
+
+        let intent = PaperIntent {
+            ts_ms: ack.ts_ms,
+            order_id: ack.order_id.clone(),
+            market_id: ctx.market_id,
+            symbol: ctx.symbol,
+            timeframe: ctx.timeframe,
+            stage: ctx.stage,
+            direction: ctx.direction,
+            velocity_bps_per_sec: ctx.velocity_bps_per_sec,
+            edge_bps: ctx.edge_bps,
+            prob_fast: ctx.prob_fast,
+            prob_settle: ctx.prob_settle,
+            confidence: ctx.confidence,
+            action: ctx.action,
+            intent: ctx.intent,
+            requested_size_usdc: ctx.requested_size_usdc,
+            requested_size_contracts: ctx.requested_size_contracts,
+            entry_price: ctx.entry_price,
+            seat_layer: Some(enum_text(&seat_status.current_layer)),
+            tuned_params_before: tuned_before,
+            tuned_params_after: tuned_after,
+            rollback_triggered,
+            shadow_pnl_comparison,
+        };
+        let mut s = self.state.write().await;
+        s.intents.insert(ack.order_id.clone(), intent);
+    }
+
+    pub(crate) async fn on_fill(&self, fill: &FillEvent) {
+        if !self.enabled {
+            return;
+        }
+        let mut s = self.state.write().await;
+        let ts_ms = fill.ts_ms.max(Utc::now().timestamp_millis());
+        let mut intent = s.intents.remove(fill.order_id.as_str()).unwrap_or_else(|| {
+            fallback_intent(fill, ts_ms, self.seat.history(1).into_iter().next().as_ref())
+        });
+        intent.requested_size_contracts = intent.requested_size_contracts.max(fill.size);
+        intent.requested_size_usdc = intent
+            .requested_size_usdc
+            .max(fill.price * intent.requested_size_contracts);
+        let mid = fill.mid_price.unwrap_or(fill.price).max(1e-9);
+        let slippage_bps = fill
+            .slippage_bps
+            .unwrap_or_else(|| ((fill.price - mid) / mid) * 10_000.0);
+        let _paper_fill = PaperFill {
+            ts_ms,
+            order_id: fill.order_id.clone(),
+            market_id: fill.market_id.clone(),
+            side: fill.side.clone(),
+            style: fill.style.clone(),
+            requested_size_usdc: intent.requested_size_usdc,
+            executed_size_usdc: fill.price * fill.size,
+            entry_price: intent.entry_price,
+            fill_price: fill.price,
+            mid_price: mid,
+            slippage_bps,
+            fee_usdc: fill.fee,
+        };
+
+        match fill.side {
+            OrderSide::BuyYes | OrderSide::BuyNo => {
+                self.open_lot_locked(&mut s, fill, intent, ts_ms);
+            }
+            OrderSide::SellYes | OrderSide::SellNo => {
+                self.close_lot_locked(&mut s, fill, intent, ts_ms, slippage_bps);
+            }
+        }
+        self.persist_reports_locked(&mut s);
+    }
+
+    pub(crate) async fn on_book(&self, book: &BookTop, chainlink_settlement_price: Option<f64>) {
+        if !self.enabled {
+            return;
+        }
+        let mut s = self.state.write().await;
+        let now_ms = book.ts_ms.max(Utc::now().timestamp_millis());
+        if let Some(price) = chainlink_settlement_price {
+            if price.is_finite() && price > 0.0 {
+                s.chainlink_aux_by_market.insert(book.market_id.clone(), price);
+            }
+        }
+        let mid_yes = (book.bid_yes + book.ask_yes) * 0.5;
+        let mid_no = (book.bid_no + book.ask_no) * 0.5;
+        self.force_settle_expired_locked(&mut s, &book.market_id, now_ms, mid_yes, mid_no);
+        self.persist_reports_locked(&mut s);
+    }
+
+    pub(crate) async fn reset(&self) {
+        let mut s = self.state.write().await;
+        *s = PaperRuntimeState {
+            bankroll: self.initial_capital,
+            peak_bankroll: self.initial_capital,
+            ..PaperRuntimeState::default()
+        };
+        self.sqlite.reset();
+        self.persist_reports_locked(&mut s);
+    }
+
+    pub(crate) async fn live_report(&self) -> PaperLiveReport {
+        let s = self.state.read().await;
+        build_live_report(&s, &self.run_id, self.initial_capital)
+    }
+
+    pub(crate) async fn history(&self, limit: usize) -> Vec<PaperTradeRecord> {
+        let s = self.state.read().await;
+        s.records.iter().rev().take(limit).cloned().collect()
+    }
+
+    pub(crate) async fn daily(&self) -> Vec<PaperDailySummary> {
+        let s = self.state.read().await;
+        build_daily_summaries(&s)
+    }
+
+    pub(crate) async fn summary_json(&self) -> serde_json::Value {
+        let s = self.state.read().await;
+        let live = build_live_report(&s, &self.run_id, self.initial_capital);
+        let analytics = build_analytics(&s.records);
+        serde_json::json!({
+            "ts_ms": Utc::now().timestamp_millis(),
+            "run_id": self.run_id,
+            "initial_capital": self.initial_capital,
+            "bankroll": live.bankroll,
+            "roi_pct": live.roi_pct,
+            "win_rate": live.win_rate,
+            "trades": live.trades,
+            "fee_total_usdc": live.fee_total_usdc,
+            "pnl_total_usdc": live.pnl_total_usdc,
+            "fee_ratio": live.fee_ratio,
+            "avg_trade_duration_ms": live.avg_trade_duration_ms,
+            "median_trade_duration_ms": live.median_trade_duration_ms,
+            "open_positions_count": live.open_positions_count,
+            "stage_distribution": analytics.stage_distribution,
+            "action_distribution": analytics.action_distribution,
+            "timeframe_distribution": analytics.timeframe_distribution,
+            "seat": {
+                "layer_distribution": analytics.seat_layer_distribution,
+                "rollback_count": analytics.seat_rollback_count,
+                "shadow_pnl_mean": analytics.shadow_pnl_mean,
+            },
+            "slippage": {
+                "avg_abs_slippage_bps": analytics.avg_abs_slippage_bps,
+                "avg_taker_abs_slippage_bps": analytics.avg_taker_abs_slippage_bps,
+                "worst_abs_slippage_bps": analytics.worst_abs_slippage_bps,
+            },
+            "reversal": {
+                "count": analytics.reversal_count,
+                "losing_count": analytics.reversal_losing_count,
+                "loss_rate": analytics.reversal_loss_rate,
+            }
+        })
+    }
+
+    fn open_lot_locked(
+        &self,
+        s: &mut PaperRuntimeState,
+        fill: &FillEvent,
+        mut intent: PaperIntent,
+        ts_ms: i64,
+    ) {
+        let key = lot_key(fill.market_id.as_str(), &fill.side);
+        let has_existing = s.open_lots.get(&key).map(|v| !v.is_empty()).unwrap_or(false);
+        if matches!(intent.action, PaperAction::Enter | PaperAction::Add) {
+            intent.action = if has_existing {
+                PaperAction::Add
+            } else {
+                PaperAction::Enter
+            };
+        }
+        let lot = PaperLot {
+            market_id: fill.market_id.clone(),
+            symbol: intent.symbol.clone(),
+            timeframe: intent.timeframe.clone(),
+            side: fill.side.clone(),
+            stage: intent.stage.clone(),
+            direction: intent.direction.clone(),
+            velocity_bps_per_sec: intent.velocity_bps_per_sec,
+            edge_bps: intent.edge_bps,
+            prob_fast: intent.prob_fast,
+            prob_settle: intent.prob_settle,
+            confidence: intent.confidence,
+            intent: fill.style.clone(),
+            requested_size_usdc: intent.requested_size_usdc,
+            entry_price: fill.price,
+            remaining_size: fill.size.max(0.0),
+            entry_fee_per_contract: if fill.size > 0.0 { fill.fee / fill.size } else { 0.0 },
+            opened_ts_ms: ts_ms,
+            seat_layer: intent.seat_layer,
+            tuned_params_before: intent.tuned_params_before,
+            tuned_params_after: intent.tuned_params_after,
+            rollback_triggered: intent.rollback_triggered,
+            shadow_pnl_comparison: intent.shadow_pnl_comparison,
+        };
+        s.fee_total_usdc += fill.fee;
+        s.open_lots.entry(key).or_default().push_back(lot);
+    }
+
+    fn close_lot_locked(
+        &self,
+        s: &mut PaperRuntimeState,
+        fill: &FillEvent,
+        intent: PaperIntent,
+        ts_ms: i64,
+        slippage_bps: f64,
+    ) {
+        let close_target_side = match fill.side {
+            OrderSide::SellYes => OrderSide::BuyYes,
+            OrderSide::SellNo => OrderSide::BuyNo,
+            _ => return,
+        };
+        let key = lot_key(fill.market_id.as_str(), &close_target_side);
+        let Some(mut lots) = s.open_lots.remove(&key) else {
+            return;
+        };
+
+        let mut remaining = fill.size.max(0.0);
+        if remaining <= 0.0 {
+            if !lots.is_empty() {
+                s.open_lots.insert(key, lots);
+            }
+            return;
+        }
+        let exit_fee_per_contract = if fill.size > 0.0 { fill.fee / fill.size } else { 0.0 };
+        while remaining > 1e-12 {
+            let Some(front) = lots.front_mut() else {
+                break;
+            };
+            let close_size = front.remaining_size.min(remaining);
+            if close_size <= 1e-12 {
+                break;
+            }
+            let entry_fee = front.entry_fee_per_contract * close_size;
+            let exit_fee = exit_fee_per_contract * close_size;
+            let pnl = (fill.price - front.entry_price) * close_size - entry_fee - exit_fee;
+            let bankroll_before = s.bankroll;
+            s.bankroll += pnl;
+            s.peak_bankroll = s.peak_bankroll.max(s.bankroll);
+            if s.peak_bankroll > 0.0 {
+                let dd = (s.peak_bankroll - s.bankroll) / s.peak_bankroll;
+                s.max_drawdown_pct = s.max_drawdown_pct.max(dd.max(0.0));
+            }
+            s.trades = s.trades.saturating_add(1);
+            if pnl >= 0.0 {
+                s.wins = s.wins.saturating_add(1);
+            } else {
+                s.losses = s.losses.saturating_add(1);
+            }
+            s.fee_total_usdc += exit_fee;
+            s.pnl_total_usdc += pnl;
+            let close_action = match intent.action {
+                PaperAction::ReversalExit | PaperAction::LateHeavy | PaperAction::DoubleSide => {
+                    intent.action.clone()
+                }
+                _ => {
+                    if matches!(front.stage, Stage::Late) {
+                        PaperAction::LateHeavy
+                    } else {
+                        PaperAction::ReversalExit
+                    }
+                }
+            };
+            let chainlink_settlement_price = s
+                .chainlink_aux_by_market
+                .get(&front.market_id)
+                .copied()
+                .filter(|v| v.is_finite() && *v > 0.0);
+            let record = PaperTradeRecord {
+                ts_ms,
+                paper_mode: "shadow".to_string(),
+                market_id: front.market_id.clone(),
+                symbol: front.symbol.clone(),
+                timeframe: front.timeframe.clone(),
+                stage: front.stage.clone(),
+                direction: front.direction.clone(),
+                velocity_bps_per_sec: front.velocity_bps_per_sec,
+                edge_bps: front.edge_bps,
+                prob_fast: front.prob_fast,
+                prob_settle: front.prob_settle,
+                confidence: front.confidence,
+                action: close_action,
+                intent: fill.style.clone(),
+                requested_size_usdc: front.requested_size_usdc,
+                executed_size_usdc: fill.price * close_size,
+                entry_price: front.entry_price,
+                fill_price: fill.price,
+                slippage_bps,
+                fee_usdc: entry_fee + exit_fee,
+                realized_pnl_usdc: pnl,
+                bankroll_before,
+                bankroll_after: s.bankroll,
+                settlement_price: fill.price,
+                chainlink_settlement_price,
+                settlement_source: "exit_fill".to_string(),
+                forced_settlement: false,
+                trade_duration_ms: ts_ms.saturating_sub(front.opened_ts_ms),
+                seat_layer: front.seat_layer.clone(),
+                tuned_params_before: front.tuned_params_before.clone(),
+                tuned_params_after: front.tuned_params_after.clone(),
+                rollback_triggered: front.rollback_triggered.clone(),
+                shadow_pnl_comparison: front.shadow_pnl_comparison,
+            };
+            self.push_record_locked(s, record);
+            front.remaining_size -= close_size;
+            if front.remaining_size <= 1e-12 {
+                lots.pop_front();
+            }
+            remaining -= close_size;
+        }
+        if !lots.is_empty() {
+            s.open_lots.insert(key, lots);
+        }
+    }
+
+    fn force_settle_expired_locked(
+        &self,
+        s: &mut PaperRuntimeState,
+        market_id: &str,
+        now_ms: i64,
+        mid_yes: f64,
+        mid_no: f64,
+    ) {
+        let mut keys = Vec::new();
+        keys.push(lot_key(market_id, &OrderSide::BuyYes));
+        keys.push(lot_key(market_id, &OrderSide::BuyNo));
+        for key in keys {
+            let Some(lots) = s.open_lots.get_mut(&key) else {
+                continue;
+            };
+            let chainlink_settlement_price = s
+                .chainlink_aux_by_market
+                .get(market_id)
+                .copied()
+                .filter(|v| v.is_finite() && *v > 0.0);
+            let mut settled = Vec::new();
+            while let Some(front) = lots.front() {
+                if !is_expired(front.opened_ts_ms, now_ms, front.timeframe.as_str()) {
+                    break;
+                }
+                settled.push(front.clone());
+                lots.pop_front();
+            }
+            for lot in settled {
+                let close_price = match lot.side {
+                    OrderSide::BuyYes | OrderSide::SellYes => mid_yes.max(0.0),
+                    OrderSide::BuyNo | OrderSide::SellNo => mid_no.max(0.0),
+                };
+                let entry_fee = lot.entry_fee_per_contract * lot.remaining_size;
+                let pnl = (close_price - lot.entry_price) * lot.remaining_size - entry_fee;
+                let bankroll_before = s.bankroll;
+                s.bankroll += pnl;
+                s.peak_bankroll = s.peak_bankroll.max(s.bankroll);
+                if s.peak_bankroll > 0.0 {
+                    let dd = (s.peak_bankroll - s.bankroll) / s.peak_bankroll;
+                    s.max_drawdown_pct = s.max_drawdown_pct.max(dd.max(0.0));
+                }
+                s.trades = s.trades.saturating_add(1);
+                if pnl >= 0.0 {
+                    s.wins = s.wins.saturating_add(1);
+                } else {
+                    s.losses = s.losses.saturating_add(1);
+                }
+                s.pnl_total_usdc += pnl;
+                let record = PaperTradeRecord {
+                    ts_ms: now_ms,
+                    paper_mode: "shadow".to_string(),
+                    market_id: lot.market_id.clone(),
+                    symbol: lot.symbol.clone(),
+                    timeframe: lot.timeframe.clone(),
+                    stage: lot.stage.clone(),
+                    direction: lot.direction.clone(),
+                    velocity_bps_per_sec: lot.velocity_bps_per_sec,
+                    edge_bps: lot.edge_bps,
+                    prob_fast: lot.prob_fast,
+                    prob_settle: lot.prob_settle,
+                    confidence: lot.confidence,
+                    action: PaperAction::LateHeavy,
+                    intent: lot.intent.clone(),
+                    requested_size_usdc: lot.requested_size_usdc,
+                    executed_size_usdc: close_price * lot.remaining_size,
+                    entry_price: lot.entry_price,
+                    fill_price: close_price,
+                    slippage_bps: 0.0,
+                    fee_usdc: entry_fee,
+                    realized_pnl_usdc: pnl,
+                    bankroll_before,
+                    bankroll_after: s.bankroll,
+                    settlement_price: close_price,
+                    chainlink_settlement_price,
+                    settlement_source: "pm_mid".to_string(),
+                    forced_settlement: true,
+                    trade_duration_ms: now_ms.saturating_sub(lot.opened_ts_ms),
+                    seat_layer: lot.seat_layer.clone(),
+                    tuned_params_before: lot.tuned_params_before.clone(),
+                    tuned_params_after: lot.tuned_params_after.clone(),
+                    rollback_triggered: lot.rollback_triggered.clone(),
+                    shadow_pnl_comparison: lot.shadow_pnl_comparison,
+                };
+                self.push_record_locked(s, record);
+            }
+        }
+    }
+
+    fn push_record_locked(&self, s: &mut PaperRuntimeState, record: PaperTradeRecord) {
+        update_daily(s, &record);
+        append_jsonl(
+            &dataset_path("normalized", "paper_records.jsonl"),
+            &serde_json::json!(record),
+        );
+        self.sqlite.push_trade(&record);
+        s.records.push_back(record);
+        if s.records.len() > HISTORY_CAP {
+            let _ = s.records.pop_front();
+        }
+    }
+
+    fn persist_reports_locked(&self, s: &mut PaperRuntimeState) {
+        let live = build_live_report(s, &self.run_id, self.initial_capital);
+        let analytics = build_analytics(&s.records);
+        let summary = serde_json::json!({
+            "run_id": self.run_id,
+            "ts_ms": live.ts_ms,
+            "initial_capital": self.initial_capital,
+            "bankroll": live.bankroll,
+            "roi_pct": live.roi_pct,
+            "trades": live.trades,
+            "wins": live.wins,
+            "losses": live.losses,
+            "win_rate": live.win_rate,
+            "max_drawdown_pct": live.max_drawdown_pct,
+            "fee_total_usdc": live.fee_total_usdc,
+            "pnl_total_usdc": live.pnl_total_usdc,
+            "fee_ratio": live.fee_ratio,
+            "avg_trade_duration_ms": live.avg_trade_duration_ms,
+            "median_trade_duration_ms": live.median_trade_duration_ms,
+            "open_positions_count": live.open_positions_count,
+            "stage_distribution": analytics.stage_distribution,
+            "action_distribution": analytics.action_distribution,
+            "timeframe_distribution": analytics.timeframe_distribution,
+            "seat": {
+                "layer_distribution": analytics.seat_layer_distribution,
+                "rollback_count": analytics.seat_rollback_count,
+                "shadow_pnl_mean": analytics.shadow_pnl_mean,
+            },
+            "slippage": {
+                "avg_abs_slippage_bps": analytics.avg_abs_slippage_bps,
+                "avg_taker_abs_slippage_bps": analytics.avg_taker_abs_slippage_bps,
+                "worst_abs_slippage_bps": analytics.worst_abs_slippage_bps,
+            },
+            "reversal": {
+                "count": analytics.reversal_count,
+                "losing_count": analytics.reversal_losing_count,
+                "loss_rate": analytics.reversal_loss_rate,
+            }
+        });
+        let diagnosis = serde_json::json!({
+            "ts_ms": live.ts_ms,
+            "alerts": build_diagnosis_alerts(&live, &analytics),
+            "root_causes": build_root_causes(&live, &analytics),
+            "slippage": {
+                "avg_abs_slippage_bps": analytics.avg_abs_slippage_bps,
+                "avg_taker_abs_slippage_bps": analytics.avg_taker_abs_slippage_bps,
+                "worst_abs_slippage_bps": analytics.worst_abs_slippage_bps,
+            },
+            "reversal": {
+                "count": analytics.reversal_count,
+                "losing_count": analytics.reversal_losing_count,
+                "loss_rate": analytics.reversal_loss_rate,
+            },
+            "seat": {
+                "layer_distribution": analytics.seat_layer_distribution,
+                "rollback_count": analytics.seat_rollback_count,
+                "shadow_pnl_mean": analytics.shadow_pnl_mean,
+            },
+            "stage_distribution": analytics.stage_distribution,
+            "action_distribution": analytics.action_distribution,
+        });
+        let daily = build_daily_summaries(s);
+        write_json_file(dataset_path("reports", "paper_live_latest.json"), &live);
+        write_json_file(dataset_path("reports", "paper_summary_latest.json"), &summary);
+        write_json_file(dataset_path("reports", "paper_diagnosis_latest.json"), &diagnosis);
+        write_daily_csv(dataset_path("reports", "daily_compound_summary.csv"), &daily);
+        for day in &daily {
+            self.sqlite.push_daily(day);
+        }
+        self.sqlite.push_summary(&live);
+    }
+}
+
+pub(crate) fn set_global_paper_runtime(handle: Arc<PaperRuntimeHandle>) {
+    let _ = GLOBAL_PAPER_RUNTIME.set(handle);
+}
+
+pub(crate) fn global_paper_runtime() -> Option<Arc<PaperRuntimeHandle>> {
+    GLOBAL_PAPER_RUNTIME.get().cloned()
+}
+
+fn fallback_intent(fill: &FillEvent, ts_ms: i64, decision: Option<&SeatDecisionRecord>) -> PaperIntent {
+    let (tuned_before, tuned_after, rollback_triggered, shadow_pnl_comparison) =
+        extract_last_decision(decision);
+    PaperIntent {
+        ts_ms,
+        order_id: fill.order_id.clone(),
+        market_id: fill.market_id.clone(),
+        symbol: fill.market_id.clone(),
+        timeframe: "unknown".to_string(),
+        stage: Stage::Early,
+        direction: match fill.side {
+            OrderSide::BuyYes | OrderSide::SellNo => Direction::Up,
+            OrderSide::BuyNo | OrderSide::SellYes => Direction::Down,
+        },
+        velocity_bps_per_sec: 0.0,
+        edge_bps: 0.0,
+        prob_fast: 0.5,
+        prob_settle: 0.5,
+        confidence: 0.0,
+        action: PaperAction::Enter,
+        intent: fill.style.clone(),
+        requested_size_usdc: fill.price * fill.size,
+        requested_size_contracts: fill.size,
+        entry_price: fill.price,
+        seat_layer: None,
+        tuned_params_before: tuned_before,
+        tuned_params_after: tuned_after,
+        rollback_triggered,
+        shadow_pnl_comparison,
+    }
+}
+
+fn extract_last_decision(
+    decision: Option<&SeatDecisionRecord>,
+) -> (
+    Option<serde_json::Value>,
+    Option<serde_json::Value>,
+    Option<String>,
+    Option<f64>,
+) {
+    let Some(d) = decision else {
+        return (None, None, None, None);
+    };
+    let before = serde_json::to_value(&d.previous).ok();
+    let after = serde_json::to_value(&d.candidate).ok();
+    let rollback_triggered = if d.rollback {
+        Some(d.decision.clone())
+    } else {
+        None
+    };
+    let shadow_pnl = d
+        .notes
+        .iter()
+        .find_map(|v| v.strip_prefix("shadow_ev_usdc_p50="))
+        .and_then(|v| v.parse::<f64>().ok());
+    (before, after, rollback_triggered, shadow_pnl)
+}
+
+fn update_daily(s: &mut PaperRuntimeState, record: &PaperTradeRecord) {
+    let day = Utc
+        .timestamp_millis_opt(record.ts_ms)
+        .single()
+        .unwrap_or_else(Utc::now)
+        .format("%Y-%m-%d")
+        .to_string();
+    let entry = s.daily.entry(day).or_insert_with(|| PaperDailyAgg {
+        starting_bankroll: record.bankroll_before,
+        ending_bankroll: record.bankroll_after,
+        trades: 0,
+        wins: 0,
+        fee_total_usdc: 0.0,
+        pnl_total_usdc: 0.0,
+        durations_ms: Vec::new(),
+    });
+    entry.trades = entry.trades.saturating_add(1);
+    if record.realized_pnl_usdc >= 0.0 {
+        entry.wins = entry.wins.saturating_add(1);
+    }
+    entry.ending_bankroll = record.bankroll_after;
+    entry.fee_total_usdc += record.fee_usdc;
+    entry.pnl_total_usdc += record.realized_pnl_usdc;
+    entry
+        .durations_ms
+        .push(record.trade_duration_ms.max(0) as f64);
+}
+
+fn build_live_report(s: &PaperRuntimeState, run_id: &str, initial_capital: f64) -> PaperLiveReport {
+    let durations = s
+        .records
+        .iter()
+        .map(|r| r.trade_duration_ms.max(0) as f64)
+        .collect::<Vec<_>>();
+    let avg_trade_duration_ms = if durations.is_empty() {
+        0.0
+    } else {
+        durations.iter().sum::<f64>() / durations.len() as f64
+    };
+    let median_trade_duration_ms = percentile(&durations, 0.50).unwrap_or(0.0);
+    let win_rate = if s.trades == 0 {
+        0.0
+    } else {
+        s.wins as f64 / s.trades as f64
+    };
+    let roi_pct = if initial_capital.abs() < 1e-9 {
+        0.0
+    } else {
+        (s.bankroll - initial_capital) / initial_capital * 100.0
+    };
+    let fee_ratio = if s.pnl_total_usdc.abs() < 1e-9 {
+        0.0
+    } else {
+        (s.fee_total_usdc / s.pnl_total_usdc.abs()).abs()
+    };
+    let open_positions_count = s.open_lots.values().map(|v| v.len()).sum::<usize>();
+    PaperLiveReport {
+        ts_ms: Utc::now().timestamp_millis(),
+        run_id: run_id.to_string(),
+        initial_capital,
+        bankroll: s.bankroll,
+        trades: s.trades,
+        wins: s.wins,
+        losses: s.losses,
+        win_rate,
+        roi_pct,
+        max_drawdown_pct: s.max_drawdown_pct * 100.0,
+        fee_total_usdc: s.fee_total_usdc,
+        pnl_total_usdc: s.pnl_total_usdc,
+        fee_ratio,
+        avg_trade_duration_ms,
+        median_trade_duration_ms,
+        trade_count_source: "shadow_fill".to_string(),
+        open_positions_count,
+    }
+}
+
+fn build_daily_summaries(s: &PaperRuntimeState) -> Vec<PaperDailySummary> {
+    s.daily
+        .iter()
+        .map(|(day, agg)| {
+            let win_rate = if agg.trades == 0 {
+                0.0
+            } else {
+                agg.wins as f64 / agg.trades as f64
+            };
+            let daily_roi_pct = if agg.starting_bankroll.abs() < 1e-9 {
+                0.0
+            } else {
+                (agg.ending_bankroll - agg.starting_bankroll) / agg.starting_bankroll * 100.0
+            };
+            let avg_trade_duration_ms = if agg.durations_ms.is_empty() {
+                0.0
+            } else {
+                agg.durations_ms.iter().sum::<f64>() / agg.durations_ms.len() as f64
+            };
+            let median_trade_duration_ms = percentile(&agg.durations_ms, 0.50).unwrap_or(0.0);
+            PaperDailySummary {
+                utc_day: day.clone(),
+                starting_bankroll: agg.starting_bankroll,
+                ending_bankroll: agg.ending_bankroll,
+                daily_roi_pct,
+                trades: agg.trades,
+                win_rate,
+                fee_total_usdc: agg.fee_total_usdc,
+                pnl_total_usdc: agg.pnl_total_usdc,
+                avg_trade_duration_ms,
+                median_trade_duration_ms,
+            }
+        })
+        .collect()
+}
+
+#[derive(Default)]
+struct PaperAnalytics {
+    stage_distribution: BTreeMap<String, u64>,
+    action_distribution: BTreeMap<String, u64>,
+    timeframe_distribution: BTreeMap<String, u64>,
+    seat_layer_distribution: BTreeMap<String, u64>,
+    seat_rollback_count: u64,
+    shadow_pnl_mean: f64,
+    avg_abs_slippage_bps: f64,
+    avg_taker_abs_slippage_bps: f64,
+    worst_abs_slippage_bps: f64,
+    reversal_count: u64,
+    reversal_losing_count: u64,
+    reversal_loss_rate: f64,
+}
+
+fn build_analytics(records: &VecDeque<PaperTradeRecord>) -> PaperAnalytics {
+    let mut out = PaperAnalytics::default();
+    let mut abs_slippage_sum = 0.0;
+    let mut abs_slippage_cnt = 0_u64;
+    let mut taker_abs_slippage_sum = 0.0;
+    let mut taker_abs_slippage_cnt = 0_u64;
+    let mut shadow_pnl_sum = 0.0;
+    let mut shadow_pnl_cnt = 0_u64;
+
+    for r in records {
+        *out.stage_distribution.entry(enum_text(&r.stage)).or_default() += 1;
+        *out.action_distribution.entry(enum_text(&r.action)).or_default() += 1;
+        *out.timeframe_distribution.entry(r.timeframe.clone()).or_default() += 1;
+        if let Some(layer) = &r.seat_layer {
+            *out.seat_layer_distribution.entry(layer.clone()).or_default() += 1;
+        }
+        if r.rollback_triggered.is_some() {
+            out.seat_rollback_count = out.seat_rollback_count.saturating_add(1);
+        }
+        if let Some(v) = r.shadow_pnl_comparison {
+            if v.is_finite() {
+                shadow_pnl_sum += v;
+                shadow_pnl_cnt = shadow_pnl_cnt.saturating_add(1);
+            }
+        }
+
+        let abs_slippage = r.slippage_bps.abs();
+        if abs_slippage.is_finite() {
+            abs_slippage_sum += abs_slippage;
+            abs_slippage_cnt = abs_slippage_cnt.saturating_add(1);
+            out.worst_abs_slippage_bps = out.worst_abs_slippage_bps.max(abs_slippage);
+            if !matches!(r.intent, ExecutionStyle::Maker) {
+                taker_abs_slippage_sum += abs_slippage;
+                taker_abs_slippage_cnt = taker_abs_slippage_cnt.saturating_add(1);
+            }
+        }
+        if matches!(r.action, PaperAction::ReversalExit) {
+            out.reversal_count = out.reversal_count.saturating_add(1);
+            if r.realized_pnl_usdc < 0.0 {
+                out.reversal_losing_count = out.reversal_losing_count.saturating_add(1);
+            }
+        }
+    }
+
+    out.shadow_pnl_mean = if shadow_pnl_cnt == 0 {
+        0.0
+    } else {
+        shadow_pnl_sum / shadow_pnl_cnt as f64
+    };
+    out.avg_abs_slippage_bps = if abs_slippage_cnt == 0 {
+        0.0
+    } else {
+        abs_slippage_sum / abs_slippage_cnt as f64
+    };
+    out.avg_taker_abs_slippage_bps = if taker_abs_slippage_cnt == 0 {
+        0.0
+    } else {
+        taker_abs_slippage_sum / taker_abs_slippage_cnt as f64
+    };
+    out.reversal_loss_rate = if out.reversal_count == 0 {
+        0.0
+    } else {
+        out.reversal_losing_count as f64 / out.reversal_count as f64
+    };
+    out
+}
+
+fn build_diagnosis_alerts(live: &PaperLiveReport, analytics: &PaperAnalytics) -> Vec<String> {
+    let mut alerts = Vec::new();
+    if live.trades == 0 {
+        alerts.push("no_trades_recorded".to_string());
+    }
+    if live.win_rate < 0.45 && live.trades >= 20 {
+        alerts.push("low_win_rate".to_string());
+    }
+    if live.fee_ratio > 0.5 && live.trades > 0 {
+        alerts.push("fee_ratio_high".to_string());
+    }
+    if live.max_drawdown_pct > 20.0 {
+        alerts.push("drawdown_high".to_string());
+    }
+    if analytics.avg_taker_abs_slippage_bps > 15.0 && live.trades >= 10 {
+        alerts.push("taker_slippage_high".to_string());
+    }
+    if analytics.reversal_loss_rate > 0.60 && analytics.reversal_count >= 10 {
+        alerts.push("reversal_exit_underperforming".to_string());
+    }
+    if analytics.seat_rollback_count >= 2 {
+        alerts.push("seat_rollback_frequent".to_string());
+    }
+    alerts
+}
+
+fn build_root_causes(live: &PaperLiveReport, analytics: &PaperAnalytics) -> Vec<String> {
+    let mut causes = Vec::new();
+    if live.trades == 0 {
+        causes.push("entry_conditions_too_strict_or_feed_inactive".to_string());
+    }
+    if live.fee_ratio > 0.6 {
+        causes.push("fee_dominates_edge_tune_min_edge_or_taker_usage".to_string());
+    }
+    if analytics.avg_taker_abs_slippage_bps > 15.0 {
+        causes.push("taker_slippage_excessive_consider_maker_bias_or_spread_filter".to_string());
+    }
+    if analytics.reversal_loss_rate > 0.60 && analytics.reversal_count >= 10 {
+        causes.push("reversal_exit_rule_quality_low_check_velocity_and_edge_thresholds".to_string());
+    }
+    if live.max_drawdown_pct > 20.0 {
+        causes.push("risk_controls_too_loose_reduce_position_fraction_or_drawdown_limit".to_string());
+    }
+    if causes.is_empty() {
+        causes.push("no_critical_issue_detected".to_string());
+    }
+    causes
+}
+
+fn lot_key(market_id: &str, side: &OrderSide) -> String {
+    format!("{market_id}|{}", enum_text(side))
+}
+
+fn frame_ms(timeframe: &str) -> i64 {
+    match timeframe {
+        "5m" | "5min" => 5 * 60 * 1_000,
+        "15m" | "15min" => 15 * 60 * 1_000,
+        "1h" => 60 * 60 * 1_000,
+        "1d" => 24 * 60 * 60 * 1_000,
+        _ => i64::MAX,
+    }
+}
+
+fn is_expired(opened_ts_ms: i64, now_ms: i64, timeframe: &str) -> bool {
+    let fm = frame_ms(timeframe);
+    if fm == i64::MAX || opened_ts_ms <= 0 || now_ms <= 0 {
+        return false;
+    }
+    opened_ts_ms.div_euclid(fm) < now_ms.div_euclid(fm)
+}
+
+fn enum_text<T: serde::Serialize>(value: &T) -> String {
+    serde_json::to_value(value)
+        .ok()
+        .and_then(|v| v.as_str().map(ToOwned::to_owned))
+        .unwrap_or_else(|| "unknown".to_string())
+}
+
+fn write_json_file(path: PathBuf, value: &impl serde::Serialize) {
+    if let Some(parent) = path.parent() {
+        let _ = std::fs::create_dir_all(parent);
+    }
+    if let Ok(raw) = serde_json::to_vec_pretty(value) {
+        let _ = std::fs::write(path, raw);
+    }
+}
+
+fn write_daily_csv(path: PathBuf, days: &[PaperDailySummary]) {
+    if let Some(parent) = path.parent() {
+        let _ = std::fs::create_dir_all(parent);
+    }
+    let mut out = String::new();
+    out.push_str("utc_day,starting_bankroll,ending_bankroll,daily_roi_pct,trades,win_rate,fee_total_usdc,pnl_total_usdc,avg_trade_duration_ms,median_trade_duration_ms\n");
+    for d in days {
+        out.push_str(&format!(
+            "{},{:.6},{:.6},{:.6},{},{:.6},{:.6},{:.6},{:.3},{:.3}\n",
+            d.utc_day,
+            d.starting_bankroll,
+            d.ending_bankroll,
+            d.daily_roi_pct,
+            d.trades,
+            d.win_rate,
+            d.fee_total_usdc,
+            d.pnl_total_usdc,
+            d.avg_trade_duration_ms,
+            d.median_trade_duration_ms
+        ));
+    }
+    let _ = std::fs::write(path, out);
+}
diff --git a/crates/app_runner/src/paper_sqlite.rs b/crates/app_runner/src/paper_sqlite.rs
new file mode 100644
index 0000000..639b416
--- /dev/null
+++ b/crates/app_runner/src/paper_sqlite.rs
@@ -0,0 +1,316 @@
+use std::fs;
+use std::path::PathBuf;
+use std::sync::mpsc;
+use std::thread;
+
+use core_types::{PaperDailySummary, PaperLiveReport, PaperTradeRecord};
+use rusqlite::{params, Connection};
+
+#[derive(Debug)]
+enum SqliteMsg {
+    Trade(PaperTradeRecord),
+    Daily(PaperDailySummary),
+    Summary(PaperLiveReport),
+    Reset,
+}
+
+#[derive(Clone, Default)]
+pub(crate) struct PaperSqliteWriter {
+    tx: Option<mpsc::Sender<SqliteMsg>>,
+}
+
+impl PaperSqliteWriter {
+    pub(crate) fn spawn(path: PathBuf, enabled: bool) -> Self {
+        if !enabled {
+            return Self { tx: None };
+        }
+        let (tx, rx) = mpsc::channel::<SqliteMsg>();
+        thread::spawn(move || {
+            if let Err(err) = run_writer(path, rx) {
+                tracing::warn!(error = %err, "paper sqlite writer exited");
+            }
+        });
+        Self { tx: Some(tx) }
+    }
+
+    pub(crate) fn push_trade(&self, record: &PaperTradeRecord) {
+        if let Some(tx) = &self.tx {
+            let _ = tx.send(SqliteMsg::Trade(record.clone()));
+        }
+    }
+
+    pub(crate) fn push_daily(&self, daily: &PaperDailySummary) {
+        if let Some(tx) = &self.tx {
+            let _ = tx.send(SqliteMsg::Daily(daily.clone()));
+        }
+    }
+
+    pub(crate) fn push_summary(&self, report: &PaperLiveReport) {
+        if let Some(tx) = &self.tx {
+            let _ = tx.send(SqliteMsg::Summary(report.clone()));
+        }
+    }
+
+    pub(crate) fn reset(&self) {
+        if let Some(tx) = &self.tx {
+            let _ = tx.send(SqliteMsg::Reset);
+        }
+    }
+}
+
+fn run_writer(path: PathBuf, rx: mpsc::Receiver<SqliteMsg>) -> anyhow::Result<()> {
+    if let Some(parent) = path.parent() {
+        fs::create_dir_all(parent)?;
+    }
+    let conn = Connection::open(path)?;
+    init_schema(&conn)?;
+
+    while let Ok(msg) = rx.recv() {
+        match msg {
+            SqliteMsg::Trade(r) => insert_trade(&conn, &r)?,
+            SqliteMsg::Daily(d) => upsert_daily(&conn, &d)?,
+            SqliteMsg::Summary(s) => upsert_summary(&conn, &s)?,
+            SqliteMsg::Reset => reset_all(&conn)?,
+        }
+    }
+    Ok(())
+}
+
+fn init_schema(conn: &Connection) -> anyhow::Result<()> {
+    conn.execute_batch(
+        r#"
+        CREATE TABLE IF NOT EXISTS paper_records (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            ts_ms INTEGER NOT NULL,
+            paper_mode TEXT NOT NULL,
+            market_id TEXT NOT NULL,
+            symbol TEXT NOT NULL,
+            timeframe TEXT NOT NULL,
+            stage TEXT NOT NULL,
+            direction TEXT NOT NULL,
+            velocity_bps_per_sec REAL NOT NULL,
+            edge_bps REAL NOT NULL,
+            prob_fast REAL NOT NULL,
+            prob_settle REAL NOT NULL,
+            confidence REAL NOT NULL,
+            action TEXT NOT NULL,
+            intent TEXT NOT NULL,
+            requested_size_usdc REAL NOT NULL,
+            executed_size_usdc REAL NOT NULL,
+            entry_price REAL NOT NULL,
+            fill_price REAL NOT NULL,
+            slippage_bps REAL NOT NULL,
+            fee_usdc REAL NOT NULL,
+            realized_pnl_usdc REAL NOT NULL,
+            bankroll_before REAL NOT NULL,
+            bankroll_after REAL NOT NULL,
+            settlement_price REAL NOT NULL,
+            chainlink_settlement_price REAL NULL,
+            settlement_source TEXT NOT NULL,
+            forced_settlement INTEGER NOT NULL,
+            trade_duration_ms INTEGER NOT NULL,
+            seat_layer TEXT NULL,
+            tuned_params_before TEXT NULL,
+            tuned_params_after TEXT NULL,
+            rollback_triggered TEXT NULL,
+            shadow_pnl_comparison REAL NULL
+        );
+        CREATE INDEX IF NOT EXISTS idx_paper_records_ts ON paper_records(ts_ms);
+        CREATE INDEX IF NOT EXISTS idx_paper_records_market ON paper_records(market_id);
+
+        CREATE TABLE IF NOT EXISTS paper_daily_summary (
+            utc_day TEXT PRIMARY KEY,
+            starting_bankroll REAL NOT NULL,
+            ending_bankroll REAL NOT NULL,
+            daily_roi_pct REAL NOT NULL,
+            trades INTEGER NOT NULL,
+            win_rate REAL NOT NULL,
+            fee_total_usdc REAL NOT NULL,
+            pnl_total_usdc REAL NOT NULL,
+            avg_trade_duration_ms REAL NOT NULL,
+            median_trade_duration_ms REAL NOT NULL
+        );
+
+        CREATE TABLE IF NOT EXISTS paper_run_summary (
+            run_id TEXT PRIMARY KEY,
+            ts_ms INTEGER NOT NULL,
+            initial_capital REAL NOT NULL,
+            bankroll REAL NOT NULL,
+            trades INTEGER NOT NULL,
+            wins INTEGER NOT NULL,
+            losses INTEGER NOT NULL,
+            win_rate REAL NOT NULL,
+            roi_pct REAL NOT NULL,
+            max_drawdown_pct REAL NOT NULL,
+            fee_total_usdc REAL NOT NULL,
+            pnl_total_usdc REAL NOT NULL,
+            fee_ratio REAL NOT NULL,
+            avg_trade_duration_ms REAL NOT NULL,
+            median_trade_duration_ms REAL NOT NULL,
+            trade_count_source TEXT NOT NULL,
+            open_positions_count INTEGER NOT NULL
+        );
+        "#,
+    )?;
+    let _ = conn.execute(
+        "ALTER TABLE paper_records ADD COLUMN chainlink_settlement_price REAL NULL",
+        [],
+    );
+    Ok(())
+}
+
+fn insert_trade(conn: &Connection, r: &PaperTradeRecord) -> anyhow::Result<()> {
+    conn.execute(
+        r#"
+        INSERT INTO paper_records (
+            ts_ms, paper_mode, market_id, symbol, timeframe, stage, direction,
+            velocity_bps_per_sec, edge_bps, prob_fast, prob_settle, confidence, action, intent,
+            requested_size_usdc, executed_size_usdc, entry_price, fill_price, slippage_bps,
+            fee_usdc, realized_pnl_usdc, bankroll_before, bankroll_after, settlement_price,
+            chainlink_settlement_price, settlement_source, forced_settlement, trade_duration_ms, seat_layer,
+            tuned_params_before, tuned_params_after, rollback_triggered, shadow_pnl_comparison
+        ) VALUES (
+            ?, ?, ?, ?, ?, ?, ?,
+            ?, ?, ?, ?, ?, ?, ?,
+            ?, ?, ?, ?, ?,
+            ?, ?, ?, ?, ?,
+            ?, ?, ?, ?, ?,
+            ?, ?, ?, ?
+        )
+        "#,
+        params![
+            r.ts_ms,
+            r.paper_mode,
+            r.market_id,
+            r.symbol,
+            r.timeframe,
+            enum_text(&r.stage),
+            enum_text(&r.direction),
+            r.velocity_bps_per_sec,
+            r.edge_bps,
+            r.prob_fast,
+            r.prob_settle,
+            r.confidence,
+            enum_text(&r.action),
+            enum_text(&r.intent),
+            r.requested_size_usdc,
+            r.executed_size_usdc,
+            r.entry_price,
+            r.fill_price,
+            r.slippage_bps,
+            r.fee_usdc,
+            r.realized_pnl_usdc,
+            r.bankroll_before,
+            r.bankroll_after,
+            r.settlement_price,
+            r.chainlink_settlement_price,
+            r.settlement_source,
+            if r.forced_settlement { 1_i64 } else { 0_i64 },
+            r.trade_duration_ms,
+            r.seat_layer,
+            r.tuned_params_before.as_ref().map(|v| v.to_string()),
+            r.tuned_params_after.as_ref().map(|v| v.to_string()),
+            r.rollback_triggered,
+            r.shadow_pnl_comparison,
+        ],
+    )?;
+    Ok(())
+}
+
+fn upsert_daily(conn: &Connection, d: &PaperDailySummary) -> anyhow::Result<()> {
+    conn.execute(
+        r#"
+        INSERT INTO paper_daily_summary (
+            utc_day, starting_bankroll, ending_bankroll, daily_roi_pct,
+            trades, win_rate, fee_total_usdc, pnl_total_usdc,
+            avg_trade_duration_ms, median_trade_duration_ms
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+        ON CONFLICT(utc_day) DO UPDATE SET
+            starting_bankroll=excluded.starting_bankroll,
+            ending_bankroll=excluded.ending_bankroll,
+            daily_roi_pct=excluded.daily_roi_pct,
+            trades=excluded.trades,
+            win_rate=excluded.win_rate,
+            fee_total_usdc=excluded.fee_total_usdc,
+            pnl_total_usdc=excluded.pnl_total_usdc,
+            avg_trade_duration_ms=excluded.avg_trade_duration_ms,
+            median_trade_duration_ms=excluded.median_trade_duration_ms
+        "#,
+        params![
+            d.utc_day,
+            d.starting_bankroll,
+            d.ending_bankroll,
+            d.daily_roi_pct,
+            d.trades as i64,
+            d.win_rate,
+            d.fee_total_usdc,
+            d.pnl_total_usdc,
+            d.avg_trade_duration_ms,
+            d.median_trade_duration_ms
+        ],
+    )?;
+    Ok(())
+}
+
+fn upsert_summary(conn: &Connection, s: &PaperLiveReport) -> anyhow::Result<()> {
+    conn.execute(
+        r#"
+        INSERT INTO paper_run_summary (
+            run_id, ts_ms, initial_capital, bankroll, trades, wins, losses, win_rate, roi_pct,
+            max_drawdown_pct, fee_total_usdc, pnl_total_usdc, fee_ratio,
+            avg_trade_duration_ms, median_trade_duration_ms, trade_count_source, open_positions_count
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+        ON CONFLICT(run_id) DO UPDATE SET
+            ts_ms=excluded.ts_ms,
+            initial_capital=excluded.initial_capital,
+            bankroll=excluded.bankroll,
+            trades=excluded.trades,
+            wins=excluded.wins,
+            losses=excluded.losses,
+            win_rate=excluded.win_rate,
+            roi_pct=excluded.roi_pct,
+            max_drawdown_pct=excluded.max_drawdown_pct,
+            fee_total_usdc=excluded.fee_total_usdc,
+            pnl_total_usdc=excluded.pnl_total_usdc,
+            fee_ratio=excluded.fee_ratio,
+            avg_trade_duration_ms=excluded.avg_trade_duration_ms,
+            median_trade_duration_ms=excluded.median_trade_duration_ms,
+            trade_count_source=excluded.trade_count_source,
+            open_positions_count=excluded.open_positions_count
+        "#,
+        params![
+            s.run_id,
+            s.ts_ms,
+            s.initial_capital,
+            s.bankroll,
+            s.trades as i64,
+            s.wins as i64,
+            s.losses as i64,
+            s.win_rate,
+            s.roi_pct,
+            s.max_drawdown_pct,
+            s.fee_total_usdc,
+            s.pnl_total_usdc,
+            s.fee_ratio,
+            s.avg_trade_duration_ms,
+            s.median_trade_duration_ms,
+            s.trade_count_source,
+            s.open_positions_count as i64,
+        ],
+    )?;
+    Ok(())
+}
+
+fn reset_all(conn: &Connection) -> anyhow::Result<()> {
+    conn.execute("DELETE FROM paper_records", [])?;
+    conn.execute("DELETE FROM paper_daily_summary", [])?;
+    conn.execute("DELETE FROM paper_run_summary", [])?;
+    Ok(())
+}
+
+fn enum_text<T: serde::Serialize>(value: &T) -> String {
+    serde_json::to_value(value)
+        .ok()
+        .and_then(|v| v.as_str().map(ToOwned::to_owned))
+        .unwrap_or_else(|| "unknown".to_string())
+}
diff --git a/crates/app_runner/src/report_io.rs b/crates/app_runner/src/report_io.rs
new file mode 100644
index 0000000..42f1450
--- /dev/null
+++ b/crates/app_runner/src/report_io.rs
@@ -0,0 +1,775 @@
+use std::collections::HashMap;
+use std::fs::{self, OpenOptions};
+use std::io::Write;
+use std::path::{Path, PathBuf};
+use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
+use std::sync::{Arc, OnceLock};
+use std::time::Duration;
+
+use chrono::Utc;
+use core_types::{ShadowOutcome, ShadowShot};
+use sha2::{Digest, Sha256};
+use tokio::sync::{mpsc, RwLock};
+
+use crate::state::{
+    EnginePnlReport, MarketScoreRow, PerfProfile, ShadowFinalReport, ShadowLiveReport,
+    ToxicityLiveReport,
+};
+use crate::stats_utils::percentile;
+use crate::spawn_detached;
+
+pub(super) fn ensure_dataset_dirs() {
+    for bucket in ["raw", "normalized", "reports"] {
+        let path = dataset_dir(bucket);
+        let _ = fs::create_dir_all(path);
+    }
+}
+
+pub(super) fn dataset_date() -> String {
+    Utc::now().format("%Y-%m-%d").to_string()
+}
+
+pub(super) fn dataset_dir(kind: &str) -> PathBuf {
+    let root = std::env::var("POLYEDGE_DATASET_ROOT")
+        .ok()
+        .filter(|v| !v.trim().is_empty())
+        .map(PathBuf::from)
+        .unwrap_or_else(|| PathBuf::from("datasets"));
+    root.join(kind).join(dataset_date())
+}
+
+pub(super) fn dataset_path(kind: &str, filename: &str) -> PathBuf {
+    dataset_dir(kind).join(filename)
+}
+
+pub(super) fn sha256_hex(input: &str) -> String {
+    let mut hasher = Sha256::new();
+    hasher.update(input.as_bytes());
+    format!("{:x}", hasher.finalize())
+}
+
+#[derive(Debug)]
+pub(super) struct JsonlWriteReq {
+    path: PathBuf,
+    line: String,
+}
+
+pub(super) static JSONL_WRITER: OnceLock<mpsc::Sender<JsonlWriteReq>> = OnceLock::new();
+pub(super) static JSONL_QUEUE_DEPTH: AtomicU64 = AtomicU64::new(0);
+pub(super) static JSONL_QUEUE_CAP: AtomicU64 = AtomicU64::new(0);
+pub(super) static JSONL_DROP_ON_FULL: AtomicBool = AtomicBool::new(true);
+pub(super) static NORMALIZED_INGEST_SEQ: AtomicU64 = AtomicU64::new(0);
+
+pub(super) fn next_normalized_ingest_seq() -> u64 {
+    NORMALIZED_INGEST_SEQ.fetch_add(1, Ordering::Relaxed) + 1
+}
+
+pub(super) async fn init_jsonl_writer(perf_profile: Arc<RwLock<PerfProfile>>) {
+    if JSONL_WRITER.get().is_some() {
+        return;
+    }
+    let cfg = perf_profile.read().await.clone();
+    let (tx, mut rx) = mpsc::channel::<JsonlWriteReq>(cfg.io_queue_capacity.max(256));
+    JSONL_QUEUE_CAP.store(cfg.io_queue_capacity.max(256) as u64, Ordering::Relaxed);
+    JSONL_DROP_ON_FULL.store(cfg.io_drop_on_full, Ordering::Relaxed);
+    if JSONL_WRITER.set(tx.clone()).is_err() {
+        return;
+    }
+    spawn_detached("jsonl_writer", true, async move {
+        let mut batch = Vec::<JsonlWriteReq>::new();
+        let mut ticker = tokio::time::interval(Duration::from_millis(200));
+        loop {
+            tokio::select! {
+                maybe_req = rx.recv() => {
+                    match maybe_req {
+                        Some(req) => {
+                            batch.push(req);
+                            let flush_batch = perf_profile.read().await.io_flush_batch.max(1);
+                            if batch.len() >= flush_batch {
+                                let to_flush = std::mem::take(&mut batch);
+                                let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
+                            }
+                        }
+                        None => {
+                            if !batch.is_empty() {
+                                let to_flush = std::mem::take(&mut batch);
+                                let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
+                            }
+                            break;
+                        }
+                    }
+                }
+                _ = ticker.tick() => {
+                    if !batch.is_empty() {
+                        let to_flush = std::mem::take(&mut batch);
+                        let _ = tokio::task::spawn_blocking(move || flush_jsonl_batch_sync(to_flush)).await;
+                    }
+                }
+            }
+            let cap = JSONL_QUEUE_CAP.load(Ordering::Relaxed) as usize;
+            JSONL_QUEUE_DEPTH.store(cap.saturating_sub(tx.capacity()) as u64, Ordering::Relaxed);
+        }
+    });
+}
+
+pub(super) fn flush_jsonl_batch_sync(batch: Vec<JsonlWriteReq>) {
+    let mut grouped = HashMap::<PathBuf, Vec<String>>::new();
+    for req in batch {
+        grouped.entry(req.path).or_default().push(req.line);
+    }
+    for (path, lines) in grouped {
+        if let Some(parent) = path.parent() {
+            let _ = fs::create_dir_all(parent);
+        }
+        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&path) {
+            for line in lines {
+                let _ = writeln!(file, "{line}");
+            }
+        }
+    }
+}
+
+pub(super) fn current_jsonl_queue_depth() -> u64 {
+    JSONL_QUEUE_DEPTH.load(Ordering::Relaxed)
+}
+
+pub(super) fn append_jsonl_sync(path: &Path, line: &str) {
+    if let Some(parent) = path.parent() {
+        let _ = fs::create_dir_all(parent);
+    }
+    if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(path) {
+        let _ = writeln!(file, "{line}");
+    }
+}
+
+pub(super) fn append_jsonl_line(path: &Path, line: String) {
+    if let Some(tx) = JSONL_WRITER.get() {
+        let req = JsonlWriteReq {
+            path: path.to_path_buf(),
+            line,
+        };
+        match tx.try_send(req) {
+            Ok(_) => {
+                let cap = JSONL_QUEUE_CAP.load(Ordering::Relaxed) as usize;
+                JSONL_QUEUE_DEPTH
+                    .store(cap.saturating_sub(tx.capacity()) as u64, Ordering::Relaxed);
+                return;
+            }
+            Err(tokio::sync::mpsc::error::TrySendError::Full(req)) => {
+                metrics::counter!("io.jsonl.queue_full").increment(1);
+                if JSONL_DROP_ON_FULL.load(Ordering::Relaxed) {
+                    metrics::counter!("io.jsonl.dropped").increment(1);
+                    return;
+                }
+                append_jsonl_sync(&req.path, &req.line);
+                return;
+            }
+            Err(tokio::sync::mpsc::error::TrySendError::Closed(req)) => {
+                metrics::counter!("io.jsonl.queue_closed").increment(1);
+                if JSONL_DROP_ON_FULL.load(Ordering::Relaxed) {
+                    metrics::counter!("io.jsonl.dropped").increment(1);
+                    return;
+                }
+                append_jsonl_sync(&req.path, &req.line);
+                return;
+            }
+        }
+    }
+    append_jsonl_sync(path, &line);
+}
+
+pub(super) fn append_jsonl(path: &Path, value: &serde_json::Value) {
+    append_jsonl_line(path, value.to_string());
+}
+
+pub(super) static LAST_LIVE_REPORT_PERSIST_MS: AtomicI64 = AtomicI64::new(0);
+
+pub(super) fn persist_live_report_files(live: &ShadowLiveReport) {
+    // Throttle file persistence. /report/shadow/live can be polled at high frequency (storm tests)
+    // and pretty-json serialization + fs::write per request is unnecessary and can destabilize the
+    // process under load.
+    let now_ms = Utc::now().timestamp_millis();
+    let last_ms = LAST_LIVE_REPORT_PERSIST_MS.load(Ordering::Relaxed);
+    if now_ms.saturating_sub(last_ms) < 1_000 {
+        return;
+    }
+    if LAST_LIVE_REPORT_PERSIST_MS
+        .compare_exchange(last_ms, now_ms, Ordering::Relaxed, Ordering::Relaxed)
+        .is_err()
+    {
+        return;
+    }
+
+    let reports_dir = dataset_dir("reports");
+    let _ = fs::create_dir_all(&reports_dir);
+
+    let live_json_path = reports_dir.join("shadow_live_latest.json");
+    if let Ok(raw) = serde_json::to_string_pretty(live) {
+        let _ = fs::write(live_json_path, raw);
+    }
+}
+
+pub(super) fn persist_engine_pnl_report(report: &EnginePnlReport) {
+    let reports_dir = dataset_dir("reports");
+    let _ = fs::create_dir_all(&reports_dir);
+
+    let json_path = reports_dir.join("engine_pnl_breakdown_latest.json");
+    if let Ok(raw) = serde_json::to_string_pretty(report) {
+        let _ = fs::write(json_path, raw);
+    }
+
+    let csv_path = reports_dir.join("engine_pnl_breakdown.csv");
+    let mut rows = String::new();
+    rows.push_str("window_id,engine,samples,total_usdc,p50_usdc,p10_usdc,positive_ratio\n");
+    for row in &report.rows {
+        rows.push_str(&format!(
+            "{},{},{},{:.6},{:.6},{:.6},{:.6}\n",
+            report.window_id,
+            row.engine,
+            row.samples,
+            row.total_usdc,
+            row.p50_usdc,
+            row.p10_usdc,
+            row.positive_ratio
+        ));
+    }
+    let _ = fs::write(csv_path, rows);
+}
+
+pub(super) fn persist_final_report_files(report: &ShadowFinalReport) {
+    let reports_dir = dataset_dir("reports");
+    let _ = fs::create_dir_all(&reports_dir);
+
+    let md_path = reports_dir.join("report_shadow_12h.md");
+    let gate_label = if report.gate.pass { "PASS" } else { "FAIL" };
+    let mut md = String::new();
+    md.push_str("# Shadow 12h Report\n\n");
+    md.push_str(&format!("- gate: {gate_label}\n"));
+    md.push_str(&format!(
+        "- fillability@10ms: {:.4}\n",
+        report.gate.fillability_10ms
+    ));
+    md.push_str(&format!(
+        "- net_edge_p50_bps: {:.4}\n",
+        report.gate.net_edge_p50_bps
+    ));
+    md.push_str(&format!(
+        "- net_edge_p10_bps: {:.4}\n",
+        report.gate.net_edge_p10_bps
+    ));
+    md.push_str(&format!(
+        "- net_markout_10s_usdc_p50: {:.6}\n",
+        report.gate.net_markout_10s_usdc_p50
+    ));
+    md.push_str(&format!(
+        "- roi_notional_10s_bps_p50: {:.6}\n",
+        report.gate.roi_notional_10s_bps_p50
+    ));
+    md.push_str(&format!(
+        "- ev_net_usdc_p50: {:.6}\n",
+        report.gate.ev_net_usdc_p50
+    ));
+    md.push_str(&format!(
+        "- ev_net_usdc_p10: {:.6}\n",
+        report.gate.ev_net_usdc_p10
+    ));
+    md.push_str(&format!(
+        "- ev_positive_ratio: {:.4}\n",
+        report.gate.ev_positive_ratio
+    ));
+    md.push_str(&format!(
+        "- executed_over_eligible: {:.4}\n",
+        report.gate.executed_over_eligible
+    ));
+    md.push_str(&format!(
+        "- eligible_count: {}\n",
+        report.gate.eligible_count
+    ));
+    md.push_str(&format!(
+        "- executed_count: {}\n",
+        report.gate.executed_count
+    ));
+    md.push_str(&format!(
+        "- pnl_10s_p50_bps_raw: {:.4}\n",
+        report.gate.pnl_10s_p50_bps_raw
+    ));
+    md.push_str(&format!(
+        "- pnl_10s_p50_bps_robust: {:.4}\n",
+        report.gate.pnl_10s_p50_bps_robust
+    ));
+    md.push_str(&format!(
+        "- pnl_10s_sample_count: {}\n",
+        report.gate.pnl_10s_sample_count
+    ));
+    md.push_str(&format!(
+        "- pnl_10s_outlier_ratio: {:.4}\n",
+        report.gate.pnl_10s_outlier_ratio
+    ));
+    md.push_str(&format!(
+        "- quote_block_ratio: {:.4}\n",
+        report.gate.quote_block_ratio
+    ));
+    md.push_str(&format!(
+        "- policy_block_ratio: {:.4}\n",
+        report.gate.policy_block_ratio
+    ));
+    md.push_str(&format!(
+        "- gate_block_ratio: {:.4}\n",
+        report.gate.gate_block_ratio
+    ));
+    md.push_str(&format!(
+        "- strategy_uptime_pct: {:.2}\n",
+        report.gate.strategy_uptime_pct
+    ));
+    md.push_str(&format!(
+        "- data_valid_ratio: {:.5}\n",
+        report.gate.data_valid_ratio
+    ));
+    md.push_str(&format!(
+        "- seq_gap_rate: {:.5}\n",
+        report.gate.seq_gap_rate
+    ));
+    md.push_str(&format!(
+        "- ts_inversion_rate: {:.5}\n",
+        report.gate.ts_inversion_rate
+    ));
+    md.push_str(&format!(
+        "- stale_tick_drop_ratio: {:.5}\n",
+        report.gate.stale_tick_drop_ratio
+    ));
+    md.push_str(&format!(
+        "- tick_to_ack_p99_ms: {:.4}\n\n",
+        report.gate.tick_to_ack_p99_ms
+    ));
+    md.push_str(&format!(
+        "- tick_to_decision_p99_ms: {:.4}\n",
+        report.live.tick_to_decision_p99_ms
+    ));
+    md.push_str(&format!(
+        "- ack_only_p99_ms: {:.4}\n",
+        report.live.ack_only_p99_ms
+    ));
+    md.push_str(&format!(
+        "- alpha_window_p99_ms: {:.4}\n",
+        report.live.alpha_window_p99_ms
+    ));
+    md.push_str(&format!(
+        "- alpha_window_hit_ratio: {:.4}\n",
+        report.live.alpha_window_hit_ratio
+    ));
+    md.push_str(&format!(
+        "- decision_queue_wait_p99_ms: {:.4}\n",
+        report.gate.decision_queue_wait_p99_ms
+    ));
+    md.push_str(&format!(
+        "- decision_compute_p99_ms: {:.4}\n",
+        report.gate.decision_compute_p99_ms
+    ));
+    md.push_str(&format!(
+        "- source_latency_p99_ms: {:.4}\n",
+        report.gate.source_latency_p99_ms
+    ));
+    md.push_str(&format!(
+        "- local_backlog_p99_ms: {:.4}\n",
+        report.gate.local_backlog_p99_ms
+    ));
+    md.push_str(&format!(
+        "- queue_depth_p99: {:.4}\n",
+        report.live.queue_depth_p99
+    ));
+    md.push_str(&format!(
+        "- event_backlog_p99: {:.4}\n\n",
+        report.live.event_backlog_p99
+    ));
+    md.push_str(&format!(
+        "- quote_attempted: {}\n- quote_blocked: {}\n- policy_blocked: {}\n- ref_ticks_total: {}\n- book_ticks_total: {}\n- ref_freshness_ms: {}\n- book_freshness_ms: {}\n\n",
+        report.live.quote_attempted,
+        report.live.quote_blocked,
+        report.live.policy_blocked,
+        report.live.ref_ticks_total,
+        report.live.book_ticks_total,
+        report.live.ref_freshness_ms,
+        report.live.book_freshness_ms
+    ));
+    if report.gate.failed_reasons.is_empty() {
+        md.push_str("## Failed Reasons\n- none\n");
+    } else {
+        md.push_str("## Failed Reasons\n");
+        for reason in &report.gate.failed_reasons {
+            md.push_str(&format!("- {reason}\n"));
+        }
+    }
+    if report.live.blocked_reason_counts.is_empty() {
+        md.push_str("\n## Blocked Reasons\n- none\n");
+    } else {
+        md.push_str("\n## Blocked Reasons\n");
+        let mut rows = report.live.blocked_reason_counts.iter().collect::<Vec<_>>();
+        rows.sort_by(|a, b| b.1.cmp(a.1));
+        for (reason, count) in rows {
+            md.push_str(&format!("- {}: {}\n", reason, count));
+        }
+    }
+    if report.live.policy_block_reason_distribution.is_empty() {
+        md.push_str("\n## Policy Block Reason Distribution\n- none\n");
+    } else {
+        md.push_str("\n## Policy Block Reason Distribution\n");
+        let mut rows = report
+            .live
+            .policy_block_reason_distribution
+            .iter()
+            .collect::<Vec<_>>();
+        rows.sort_by(|a, b| b.1.cmp(a.1));
+        for (reason, count) in rows {
+            md.push_str(&format!("- {}: {}\n", reason, count));
+        }
+    }
+    if report.live.gate_block_reason_distribution.is_empty() {
+        md.push_str("\n## Gate Block Reason Distribution\n- none\n");
+    } else {
+        md.push_str("\n## Gate Block Reason Distribution\n");
+        let mut rows = report
+            .live
+            .gate_block_reason_distribution
+            .iter()
+            .collect::<Vec<_>>();
+        rows.sort_by(|a, b| b.1.cmp(a.1));
+        for (reason, count) in rows {
+            md.push_str(&format!("- {}: {}\n", reason, count));
+        }
+    }
+    let _ = fs::write(md_path, md);
+
+    let latency_csv = reports_dir.join("latency_breakdown_12h.csv");
+    let mut latency_rows = String::new();
+    latency_rows.push_str("stage,p50,p90,p99,unit\n");
+    latency_rows.push_str(&format!(
+        "feed_in,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.feed_in_p50_ms,
+        report.live.latency.feed_in_p90_ms,
+        report.live.latency.feed_in_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "signal,{:.6},{:.6},{:.6},us\n",
+        report.live.latency.signal_p50_us,
+        report.live.latency.signal_p90_us,
+        report.live.latency.signal_p99_us
+    ));
+    latency_rows.push_str(&format!(
+        "quote,{:.6},{:.6},{:.6},us\n",
+        report.live.latency.quote_p50_us,
+        report.live.latency.quote_p90_us,
+        report.live.latency.quote_p99_us
+    ));
+    latency_rows.push_str(&format!(
+        "risk,{:.6},{:.6},{:.6},us\n",
+        report.live.latency.risk_p50_us,
+        report.live.latency.risk_p90_us,
+        report.live.latency.risk_p99_us
+    ));
+    latency_rows.push_str(&format!(
+        "decision_queue_wait,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.decision_queue_wait_p50_ms,
+        report.live.latency.decision_queue_wait_p90_ms,
+        report.live.latency.decision_queue_wait_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "decision_compute,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.decision_compute_p50_ms,
+        report.live.latency.decision_compute_p90_ms,
+        report.live.latency.decision_compute_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "tick_to_decision,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.tick_to_decision_p50_ms,
+        report.live.latency.tick_to_decision_p90_ms,
+        report.live.latency.tick_to_decision_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "ack_only,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.ack_only_p50_ms,
+        report.live.latency.ack_only_p90_ms,
+        report.live.latency.ack_only_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "tick_to_ack,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.tick_to_ack_p50_ms,
+        report.live.latency.tick_to_ack_p90_ms,
+        report.live.latency.tick_to_ack_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "alpha_window,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.alpha_window_p50_ms,
+        report.live.latency.alpha_window_p90_ms,
+        report.live.latency.alpha_window_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "parse,{:.6},{:.6},{:.6},us\n",
+        0.0, 0.0, report.live.latency.parse_p99_us
+    ));
+    latency_rows.push_str(&format!(
+        "io_queue,{:.6},{:.6},{:.6},count\n",
+        0.0, 0.0, report.live.latency.io_queue_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "bus_lag,{:.6},{:.6},{:.6},count\n",
+        0.0, 0.0, report.live.latency.bus_lag_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "shadow_fill,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.shadow_fill_p50_ms,
+        report.live.latency.shadow_fill_p90_ms,
+        report.live.latency.shadow_fill_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "source_latency,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.source_latency_p50_ms,
+        report.live.latency.source_latency_p90_ms,
+        report.live.latency.source_latency_p99_ms
+    ));
+    latency_rows.push_str(&format!(
+        "local_backlog,{:.6},{:.6},{:.6},ms\n",
+        report.live.latency.local_backlog_p50_ms,
+        report.live.latency.local_backlog_p90_ms,
+        report.live.latency.local_backlog_p99_ms
+    ));
+    let _ = fs::write(latency_csv, latency_rows);
+
+    let score_path = reports_dir.join("market_scorecard.csv");
+    let mut score_rows = String::new();
+    score_rows.push_str("market_id,symbol,shots,outcomes,fillability_10ms,net_edge_p50_bps,net_edge_p10_bps,pnl_10s_p50_bps,net_markout_10s_usdc_p50,roi_notional_10s_bps_p50\n");
+    for row in &report.live.market_scorecard {
+        score_rows.push_str(&format!(
+            "{},{},{},{},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6}\n",
+            row.market_id,
+            row.symbol,
+            row.shots,
+            row.outcomes,
+            row.fillability_10ms,
+            row.net_edge_p50_bps,
+            row.net_edge_p10_bps,
+            row.pnl_10s_p50_bps,
+            row.net_markout_10s_usdc_p50,
+            row.roi_notional_10s_bps_p50
+        ));
+    }
+    let _ = fs::write(score_path, score_rows);
+
+    let fixlist_path = reports_dir.join("next_fixlist.md");
+    let mut fixlist = String::new();
+    fixlist.push_str("# Next Fixlist\n\n");
+    if report.gate.failed_reasons.is_empty() {
+        fixlist.push_str("- Gate passed. Keep conservative limits and continue monitoring.\n");
+    } else {
+        for reason in &report.gate.failed_reasons {
+            fixlist.push_str(&format!("- {reason}\n"));
+        }
+    }
+    let _ = fs::write(fixlist_path, fixlist);
+
+    let truth_manifest_path = reports_dir.join("truth_manifest.json");
+    let truth_manifest = serde_json::json!({
+        "generated_at_utc": Utc::now().to_rfc3339(),
+        "metrics_contract_version": "2026-02-14.v1",
+        "window": {
+            "window_id": report.live.window_id,
+            "window_shots": report.live.window_shots,
+            "window_outcomes": report.live.window_outcomes,
+            "gate_ready": report.live.gate_ready,
+            "gate_ready_strict": report.live.gate_ready_strict,
+            "gate_ready_effective": report.live.gate_ready_effective,
+            "last_30s_taker_fallback_count": report.live.last_30s_taker_fallback_count,
+        },
+        "data_chain": {
+            "raw_fields": ["sha256", "source_seq", "ingest_seq", "event_ts_exchange_ms", "recv_ts_local_ns"],
+            "normalized_fields": ["source_seq", "ingest_seq", "market_id", "symbol", "delay_ms", "fillable", "net_markout_10s_usdc"],
+            "invalid_excluded_from_gate": true
+        },
+        "formulas": {
+            "quote_block_ratio": "quote_blocked / (quote_attempted + quote_blocked)",
+            "policy_block_ratio": "policy_blocked / (quote_attempted + policy_blocked)",
+            "policy_blocked_scope": "risk:* and risk_capped_zero only",
+            "executed_over_eligible": "executed_count / eligible_count",
+            "ev_net_usdc_p50": "p50(net_markout_10s_usdc)",
+            "ev_positive_ratio": "count(net_markout_10s_usdc > 0) / count(valid outcomes)"
+        },
+        "hard_gates": {
+            "data_valid_ratio_min": 0.999,
+            "seq_gap_rate_max": 0.001,
+            "ts_inversion_rate_max": 0.0005,
+            "tick_to_ack_p99_ms_max": 450.0,
+            "decision_compute_p99_ms_max": 2.0,
+            "feed_in_p99_ms_max": 800.0,
+            "executed_over_eligible_min": 0.60,
+            "quote_block_ratio_max": 0.10,
+            "policy_block_ratio_max": 0.10,
+            "ev_net_usdc_p50_min": 0.0,
+            "roi_notional_10s_bps_p50_min": 0.0
+        }
+    });
+    if let Ok(raw) = serde_json::to_string_pretty(&truth_manifest) {
+        let _ = fs::write(truth_manifest_path, raw);
+    }
+}
+
+pub(super) fn persist_toxicity_report_files(report: &ToxicityLiveReport) {
+    let reports_dir = dataset_dir("reports");
+    let _ = fs::create_dir_all(&reports_dir);
+
+    let live_json_path = reports_dir.join("toxicity_live_latest.json");
+    if let Ok(raw) = serde_json::to_string_pretty(report) {
+        let _ = fs::write(live_json_path, raw);
+    }
+
+    let csv_path = reports_dir.join("toxicity_scorecard.csv");
+    let mut rows = String::new();
+    rows.push_str("market_rank,active_for_quoting,market_id,symbol,tox_score,regime,market_score,markout_10s_bps,no_quote_rate,symbol_missing_rate,pending_exposure\n");
+    for row in &report.rows {
+        rows.push_str(&format!(
+            "{},{},{},{},{:.6},{:?},{:.6},{:.6},{:.6},{:.6},{:.6}\n",
+            row.market_rank,
+            row.active_for_quoting,
+            row.market_id,
+            row.symbol,
+            row.tox_score,
+            row.regime,
+            row.market_score,
+            row.markout_10s_bps,
+            row.no_quote_rate,
+            row.symbol_missing_rate,
+            row.pending_exposure
+        ));
+    }
+    let _ = fs::write(csv_path, rows);
+}
+
+pub(super) fn fillability_ratio(outcomes: &[ShadowOutcome], delay_ms: u64) -> f64 {
+    let mut total = 0_u64;
+    let mut filled = 0_u64;
+    for o in outcomes {
+        if o.delay_ms != delay_ms {
+            continue;
+        }
+        total = total.saturating_add(1);
+        if o.fillable {
+            filled = filled.saturating_add(1);
+        }
+    }
+    if total == 0 {
+        0.0
+    } else {
+        filled as f64 / total as f64
+    }
+}
+
+pub(super) fn survival_ratio(outcomes: &[ShadowOutcome], delay_ms: u64) -> f64 {
+    let mut total = 0_u64;
+    let mut survived = 0_u64;
+    for o in outcomes {
+        if o.delay_ms != delay_ms {
+            continue;
+        }
+        total = total.saturating_add(1);
+        if o.survived {
+            survived = survived.saturating_add(1);
+        }
+    }
+    if total == 0 {
+        0.0
+    } else {
+        survived as f64 / total as f64
+    }
+}
+
+pub(super) fn build_market_scorecard(
+    shots: &[ShadowShot],
+    outcomes: &[ShadowOutcome],
+) -> Vec<MarketScoreRow> {
+    const PRIMARY_DELAY_MS: u64 = 10;
+    const MAX_ROWS: usize = 200;
+
+    #[derive(Default)]
+    struct Agg {
+        market_id: String,
+        symbol: String,
+        shots_primary: usize,
+        outcomes_primary: usize,
+        filled_10ms: u64,
+        total_10ms: u64,
+        net_edges: Vec<f64>,
+        pnl_10s: Vec<f64>,
+        net_markout_10s_usdc: Vec<f64>,
+        roi_notional_10s_bps: Vec<f64>,
+    }
+
+    // Single-pass aggregation to avoid O(N^2) cloning/filtering. This keeps /report/shadow/live
+    // stable under stress polling.
+    let mut by_key: HashMap<(String, String), Agg> = HashMap::new();
+
+    for s in shots {
+        if s.delay_ms != PRIMARY_DELAY_MS {
+            continue;
+        }
+        let key = (s.market_id.clone(), s.symbol.clone());
+        let entry = by_key.entry(key).or_insert_with(|| Agg {
+            market_id: s.market_id.clone(),
+            symbol: s.symbol.clone(),
+            ..Agg::default()
+        });
+        entry.shots_primary = entry.shots_primary.saturating_add(1);
+        entry.net_edges.push(s.edge_net_bps);
+    }
+
+    for o in outcomes {
+        if o.delay_ms != PRIMARY_DELAY_MS {
+            continue;
+        }
+        let key = (o.market_id.clone(), o.symbol.clone());
+        let entry = by_key.entry(key).or_insert_with(|| Agg {
+            market_id: o.market_id.clone(),
+            symbol: o.symbol.clone(),
+            ..Agg::default()
+        });
+        entry.outcomes_primary = entry.outcomes_primary.saturating_add(1);
+        entry.total_10ms = entry.total_10ms.saturating_add(1);
+        if o.fillable {
+            entry.filled_10ms = entry.filled_10ms.saturating_add(1);
+        }
+        if let Some(v) = o.net_markout_10s_bps.or(o.pnl_10s_bps) {
+            entry.pnl_10s.push(v);
+        }
+        if let Some(v) = o.net_markout_10s_usdc {
+            entry.net_markout_10s_usdc.push(v);
+        }
+        if let Some(v) = o.roi_notional_10s_bps {
+            entry.roi_notional_10s_bps.push(v);
+        }
+    }
+
+    let mut rows = Vec::with_capacity(by_key.len());
+    for (_, agg) in by_key {
+        let fillability_10ms = if agg.total_10ms == 0 {
+            0.0
+        } else {
+            agg.filled_10ms as f64 / agg.total_10ms as f64
+        };
+        rows.push(MarketScoreRow {
+            market_id: agg.market_id,
+            symbol: agg.symbol,
+            shots: agg.shots_primary,
+            outcomes: agg.outcomes_primary,
+            fillability_10ms,
+            net_edge_p50_bps: percentile(&agg.net_edges, 0.50).unwrap_or(0.0),
+            net_edge_p10_bps: percentile(&agg.net_edges, 0.10).unwrap_or(0.0),
+            pnl_10s_p50_bps: percentile(&agg.pnl_10s, 0.50).unwrap_or(0.0),
+            net_markout_10s_usdc_p50: percentile(&agg.net_markout_10s_usdc, 0.50).unwrap_or(0.0),
+            roi_notional_10s_bps_p50: percentile(&agg.roi_notional_10s_bps, 0.50).unwrap_or(0.0),
+        });
+    }
+
+    rows.sort_by(|a, b| {
+        b.net_markout_10s_usdc_p50
+            .total_cmp(&a.net_markout_10s_usdc_p50)
+    });
+    rows.truncate(MAX_ROWS);
+    rows
+}
diff --git a/crates/app_runner/src/seat_persist.rs b/crates/app_runner/src/seat_persist.rs
new file mode 100644
index 0000000..3842b7a
--- /dev/null
+++ b/crates/app_runner/src/seat_persist.rs
@@ -0,0 +1,335 @@
+use std::fs::{self, File, OpenOptions};
+use std::io::{BufRead, BufReader, Write};
+use std::path::{Path, PathBuf};
+
+use anyhow::{Context, Result};
+use chrono::{Datelike, TimeZone, Utc};
+use flate2::write::GzEncoder;
+use flate2::Compression;
+use serde_json::json;
+
+use crate::seat_types::{SeatDecisionRecord, SeatRuntimeState};
+
+pub(crate) fn seat_dir() -> PathBuf {
+    let root = std::env::var("POLYEDGE_DATASET_ROOT")
+        .ok()
+        .filter(|v| !v.trim().is_empty())
+        .map(PathBuf::from)
+        .unwrap_or_else(|| PathBuf::from("datasets"));
+    root.join("reports").join("seat")
+}
+
+pub(crate) fn seat_state_path() -> PathBuf {
+    seat_dir().join("seat_state.json")
+}
+
+pub(crate) fn seat_decisions_path() -> PathBuf {
+    seat_dir().join("seat_decisions.jsonl")
+}
+
+pub(crate) fn seat_reports_dir() -> PathBuf {
+    seat_dir().join("reports")
+}
+
+pub(crate) fn ensure_seat_dir() -> Result<()> {
+    fs::create_dir_all(seat_dir()).context("create seat report dir")
+}
+
+pub(crate) fn write_state_atomic(state: &SeatRuntimeState) -> Result<()> {
+    ensure_seat_dir()?;
+    let target = seat_state_path();
+    let tmp = target.with_extension("json.tmp");
+    let payload = serde_json::to_vec_pretty(state).context("serialize seat state")?;
+
+    {
+        let mut file = File::create(&tmp).context("create seat state tmp")?;
+        file.write_all(&payload).context("write seat state tmp")?;
+        file.sync_all().context("sync seat state tmp")?;
+    }
+
+    if let Err(err) = fs::rename(&tmp, &target) {
+        if target.exists() {
+            let _ = fs::remove_file(&target);
+            fs::rename(&tmp, &target).context("replace seat state file")?;
+        } else {
+            return Err(err).context("rename seat state tmp");
+        }
+    }
+    Ok(())
+}
+
+pub(crate) fn append_decision(record: &SeatDecisionRecord) -> Result<()> {
+    ensure_seat_dir()?;
+    let path = seat_decisions_path();
+    let mut file = OpenOptions::new()
+        .create(true)
+        .append(true)
+        .open(path)
+        .context("open seat decisions jsonl")?;
+    let line = serde_json::to_string(record).context("serialize seat decision")?;
+    writeln!(file, "{line}").context("append seat decision line")?;
+    Ok(())
+}
+
+pub(crate) fn load_state() -> Option<SeatRuntimeState> {
+    let path = seat_state_path();
+    let raw = fs::read_to_string(path).ok()?;
+    serde_json::from_str::<SeatRuntimeState>(&raw).ok()
+}
+
+fn last_decision_record(path: &Path) -> Option<SeatDecisionRecord> {
+    let file = File::open(path).ok()?;
+    let reader = BufReader::new(file);
+    let lines = reader.lines().map_while(Result::ok).collect::<Vec<_>>();
+    lines
+        .into_iter()
+        .rev()
+        .find_map(|line| serde_json::from_str::<SeatDecisionRecord>(&line).ok())
+}
+
+pub(crate) fn recover_state() -> SeatRuntimeState {
+    if let Some(state) = load_state() {
+        return state;
+    }
+    let path = seat_decisions_path();
+    let Some(last) = last_decision_record(&path) else {
+        return SeatRuntimeState::default();
+    };
+    let mut state = SeatRuntimeState::default();
+    state.current_layer = last.layer;
+    state.last_params = last.candidate;
+    state.last_objective = Some(last.baseline);
+    state.last_decision_ts_ms = last.ts_ms;
+    state.trade_count_source = last.trade_count_source;
+    state
+}
+
+pub(crate) fn load_history(limit: usize) -> Vec<SeatDecisionRecord> {
+    let path = seat_decisions_path();
+    let Ok(file) = File::open(path) else {
+        return Vec::new();
+    };
+    let reader = BufReader::new(file);
+    let mut out = Vec::new();
+    for line in reader.lines().map_while(Result::ok) {
+        if let Ok(record) = serde_json::from_str::<SeatDecisionRecord>(&line) {
+            out.push(record);
+        }
+    }
+    if out.len() > limit {
+        out[out.len() - limit..].to_vec()
+    } else {
+        out
+    }
+}
+
+fn month_bucket(ts_ms: i64) -> String {
+    let dt = Utc
+        .timestamp_millis_opt(ts_ms)
+        .single()
+        .unwrap_or_else(Utc::now);
+    format!("{:04}-{:02}", dt.year(), dt.month())
+}
+
+pub(crate) fn archive_old_decisions(retention_days: u32) -> Result<()> {
+    ensure_seat_dir()?;
+    let path = seat_decisions_path();
+    if !path.exists() {
+        return Ok(());
+    }
+    let cutoff_ms = Utc::now()
+        .timestamp_millis()
+        .saturating_sub((retention_days as i64) * 24 * 3_600 * 1_000);
+
+    let file = File::open(&path).context("open seat decision file for archive")?;
+    let reader = BufReader::new(file);
+    let mut keep_lines = Vec::<String>::new();
+    let mut archive_buckets = std::collections::BTreeMap::<String, Vec<String>>::new();
+
+    for line in reader.lines().map_while(Result::ok) {
+        let Ok(record) = serde_json::from_str::<SeatDecisionRecord>(&line) else {
+            continue;
+        };
+        if record.ts_ms < cutoff_ms {
+            archive_buckets
+                .entry(month_bucket(record.ts_ms))
+                .or_default()
+                .push(line);
+        } else {
+            keep_lines.push(line);
+        }
+    }
+
+    for (month, lines) in archive_buckets {
+        let gz_path = seat_dir().join(format!("seat_decisions_{month}.jsonl.gz"));
+        let gz_file = OpenOptions::new()
+            .create(true)
+            .append(true)
+            .open(gz_path)
+            .context("open monthly archive")?;
+        let mut encoder = GzEncoder::new(gz_file, Compression::default());
+        for line in lines {
+            writeln!(encoder, "{line}").context("append line to monthly archive")?;
+        }
+        encoder.finish().context("finalize monthly archive")?;
+    }
+
+    let tmp = path.with_extension("jsonl.tmp");
+    {
+        let mut out = File::create(&tmp).context("create trimmed decision temp file")?;
+        for line in keep_lines {
+            writeln!(out, "{line}").context("write trimmed decision line")?;
+        }
+        out.sync_all().context("sync trimmed decision file")?;
+    }
+    if let Err(err) = fs::rename(&tmp, &path) {
+        if path.exists() {
+            let _ = fs::remove_file(&path);
+            fs::rename(&tmp, &path).context("replace trimmed decision file")?;
+        } else {
+            return Err(err).context("rename trimmed decision file");
+        }
+    }
+    Ok(())
+}
+
+fn decision_file_slug(raw: &str) -> String {
+    let mut out = String::with_capacity(raw.len());
+    for ch in raw.chars() {
+        if ch.is_ascii_alphanumeric() || ch == '_' || ch == '-' {
+            out.push(ch);
+        } else {
+            out.push('_');
+        }
+    }
+    while out.contains("__") {
+        out = out.replace("__", "_");
+    }
+    out.trim_matches('_').to_string()
+}
+
+fn numeric_delta(prev: Option<f64>, next: Option<f64>) -> Option<f64> {
+    match (prev, next) {
+        (Some(a), Some(b)) if a.is_finite() && b.is_finite() => Some(b - a),
+        _ => None,
+    }
+}
+
+pub(crate) fn write_tune_report(record: &SeatDecisionRecord, state: &SeatRuntimeState) -> Result<()> {
+    ensure_seat_dir()?;
+    fs::create_dir_all(seat_reports_dir()).context("create seat reports dir")?;
+
+    let curve_start = record.ts_ms.saturating_sub(24 * 3_600 * 1_000);
+    let objective_curve = state
+        .objective_history
+        .iter()
+        .filter(|point| point.ts_ms >= curve_start)
+        .map(|point| json!({"ts_ms": point.ts_ms, "objective": point.objective}))
+        .collect::<Vec<_>>();
+    let volatility_curve = state
+        .volatility_history
+        .iter()
+        .filter(|point| point.ts_ms >= curve_start)
+        .map(|point| json!({"ts_ms": point.ts_ms, "volatility_proxy": point.objective}))
+        .collect::<Vec<_>>();
+
+    let param_delta = json!({
+        "position_fraction": numeric_delta(record.previous.position_fraction, record.candidate.position_fraction),
+        "early_size_scale": numeric_delta(record.previous.early_size_scale, record.candidate.early_size_scale),
+        "maturity_size_scale": numeric_delta(record.previous.maturity_size_scale, record.candidate.maturity_size_scale),
+        "late_size_scale": numeric_delta(record.previous.late_size_scale, record.candidate.late_size_scale),
+        "min_edge_net_bps": numeric_delta(record.previous.min_edge_net_bps, record.candidate.min_edge_net_bps),
+        "convergence_exit_ratio": numeric_delta(record.previous.convergence_exit_ratio, record.candidate.convergence_exit_ratio),
+        "min_velocity_bps_per_sec": numeric_delta(record.previous.min_velocity_bps_per_sec, record.candidate.min_velocity_bps_per_sec),
+        "capital_fraction_kelly": numeric_delta(record.previous.capital_fraction_kelly, record.candidate.capital_fraction_kelly),
+        "t100ms_reversal_bps": numeric_delta(record.previous.t100ms_reversal_bps, record.candidate.t100ms_reversal_bps),
+        "t300ms_reversal_bps": numeric_delta(record.previous.t300ms_reversal_bps, record.candidate.t300ms_reversal_bps),
+        "max_single_trade_loss_usdc": numeric_delta(record.previous.max_single_trade_loss_usdc, record.candidate.max_single_trade_loss_usdc),
+        "risk_max_drawdown_pct": numeric_delta(record.previous.risk_max_drawdown_pct, record.candidate.risk_max_drawdown_pct),
+        "risk_max_market_notional": numeric_delta(record.previous.risk_max_market_notional, record.candidate.risk_max_market_notional),
+        "maker_min_edge_bps": numeric_delta(record.previous.maker_min_edge_bps, record.candidate.maker_min_edge_bps),
+        "basis_k_revert": numeric_delta(record.previous.basis_k_revert, record.candidate.basis_k_revert),
+        "basis_z_cap": numeric_delta(record.previous.basis_z_cap, record.candidate.basis_z_cap),
+    });
+
+    let style_match_score = record
+        .notes
+        .iter()
+        .find_map(|note| note.strip_prefix("style_match_score="))
+        .and_then(|v| v.parse::<f64>().ok())
+        .or_else(|| {
+            record
+                .notes
+                .iter()
+                .find_map(|note| note.strip_prefix("style_objective="))
+                .and_then(|v| v.parse::<f64>().ok())
+        })
+        .unwrap_or(0.0);
+    let shadow_pnl_proxy = record
+        .notes
+        .iter()
+        .find_map(|note| note.strip_prefix("shadow_ev_usdc_p50="))
+        .and_then(|v| v.parse::<f64>().ok());
+
+    let payload = json!({
+        "ts_ms": record.ts_ms,
+        "layer": record.layer.as_str(),
+        "decision": record.decision,
+        "rollback": record.rollback,
+        "trade_count_source": record.trade_count_source,
+        "params_previous": record.previous,
+        "params_candidate": record.candidate,
+        "params_delta": param_delta,
+        "baseline": record.baseline,
+        "risk_metrics": {
+            "max_drawdown_pct_baseline": record.baseline.max_drawdown_pct,
+            "max_drawdown_pct_latest": state.last_objective.as_ref().map(|v| v.max_drawdown_pct),
+            "source_health_min_baseline": record.baseline.source_health_min,
+            "source_health_min_latest": state.last_objective.as_ref().map(|v| v.source_health_min),
+        },
+        "shadow_metrics": {
+            "shadow_ev_usdc_p50": shadow_pnl_proxy,
+            "active_shadow_until_ms": record.lock_state.active_shadow_until_ms,
+        },
+        "style_metrics": {
+            "style_match_score": style_match_score,
+            "style_memory_size": state.style_memory.len(),
+        },
+        "curves": {
+            "objective_24h": objective_curve,
+            "volatility_24h": volatility_curve,
+        },
+        "notes": record.notes,
+    });
+
+    let slug = decision_file_slug(&record.decision);
+    let json_path = seat_reports_dir().join(format!("seat_tune_{}_{}.json", record.ts_ms, slug));
+    let md_path = seat_reports_dir().join(format!("seat_tune_{}_{}.md", record.ts_ms, slug));
+    fs::write(
+        &json_path,
+        serde_json::to_vec_pretty(&payload).context("serialize seat tune report")?,
+    )
+    .context("write seat tune json report")?;
+
+    let mut md = String::new();
+    md.push_str("# SEAT Tune Report\n\n");
+    md.push_str(&format!("- ts_ms: {}\n", record.ts_ms));
+    md.push_str(&format!("- layer: {}\n", record.layer.as_str()));
+    md.push_str(&format!("- decision: {}\n", record.decision));
+    md.push_str(&format!("- rollback: {}\n", record.rollback));
+    md.push_str(&format!("- trade_count_source: {}\n", record.trade_count_source));
+    md.push_str(&format!(
+        "- baseline_ev_usdc_p50: {:.6}\n",
+        record.baseline.ev_usdc_p50
+    ));
+    md.push_str(&format!(
+        "- baseline_max_drawdown_pct: {:.6}\n",
+        record.baseline.max_drawdown_pct
+    ));
+    md.push_str(&format!("- style_match_score: {:.6}\n", style_match_score));
+    if let Some(shadow_ev) = shadow_pnl_proxy {
+        md.push_str(&format!("- shadow_ev_usdc_p50: {:.6}\n", shadow_ev));
+    }
+    fs::write(md_path, md).context("write seat tune markdown report")?;
+    Ok(())
+}
diff --git a/crates/app_runner/src/seat_runtime.rs b/crates/app_runner/src/seat_runtime.rs
new file mode 100644
index 0000000..19c8671
--- /dev/null
+++ b/crates/app_runner/src/seat_runtime.rs
@@ -0,0 +1,1613 @@
+use std::process::Stdio;
+use std::sync::atomic::{AtomicU64, Ordering};
+use std::sync::Arc;
+use std::time::Duration;
+
+use anyhow::{anyhow, Context, Result};
+use chrono::Utc;
+use reqwest::Client;
+use serde::Deserialize;
+use tokio::process::{Child, Command};
+use tokio::sync::{Mutex, RwLock};
+
+use crate::seat_persist::{
+    append_decision, archive_old_decisions, load_history, recover_state, write_state_atomic,
+    write_tune_report,
+};
+use crate::seat_types::{
+    SeatConfig, SeatDecisionRecord, SeatForceLayerReq, SeatLayer, SeatLockState,
+    SeatManualOverrideReq, SeatMonitorState, SeatObjectivePoint, SeatObjectiveSnapshot,
+    SeatOptimizerProposal, SeatParameterSet, SeatRuntimeState, SeatSmoothingState, SeatStatusReport,
+    SeatStyleMemoryEntry, SeatStyleVector,
+};
+use crate::spawn_detached;
+
+fn now_ms() -> i64 {
+    Utc::now().timestamp_millis()
+}
+
+fn env_flag_enabled(name: &str) -> bool {
+    std::env::var(name)
+        .ok()
+        .map(|v| {
+            let normalized = v.trim().to_ascii_lowercase();
+            matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
+        })
+        .unwrap_or(false)
+}
+
+#[derive(Debug, Deserialize)]
+struct SourceHealthLite {
+    #[serde(default)]
+    score: f64,
+}
+
+#[derive(Debug, Deserialize)]
+struct ShadowLiveLite {
+    #[serde(default)]
+    executed_count: u64,
+    #[serde(default)]
+    ev_net_usdc_p50: f64,
+    #[serde(default)]
+    roi_notional_10s_bps_p50: f64,
+    #[serde(default)]
+    ev_positive_ratio: f64,
+    #[serde(default)]
+    pnl_10s_p50_bps_raw: f64,
+    #[serde(default)]
+    source_health: Vec<SourceHealthLite>,
+}
+
+#[derive(Debug, Deserialize, Default)]
+struct PnlLite {
+    #[serde(default)]
+    max_drawdown_pct: f64,
+}
+
+#[derive(Debug)]
+struct ChallengerProcess {
+    layer: SeatLayer,
+    started_ms: i64,
+    end_ms: i64,
+    required_cycles: u32,
+    control_base_url: String,
+    candidate: SeatParameterSet,
+    old_params: SeatParameterSet,
+    baseline: SeatObjectiveSnapshot,
+    proposal_notes: Vec<String>,
+    child: Child,
+}
+
+#[derive(Clone)]
+pub(crate) struct SeatRuntimeHandle {
+    cfg: SeatConfig,
+    http: Client,
+    state: Arc<RwLock<SeatRuntimeState>>,
+    live_fill_counter: Arc<AtomicU64>,
+    challenger: Arc<Mutex<Option<ChallengerProcess>>>,
+}
+
+impl SeatRuntimeHandle {
+    pub(crate) fn spawn(mut cfg: SeatConfig) -> Arc<Self> {
+        if let Ok(value) = std::env::var("POLYEDGE_SEAT_ENABLED") {
+            cfg.enabled = env_flag_enabled("POLYEDGE_SEAT_ENABLED") || value.eq_ignore_ascii_case("true");
+        }
+        if cfg.control_base_url.trim().is_empty() {
+            let port = std::env::var("POLYEDGE_CONTROL_PORT")
+                .ok()
+                .and_then(|v| v.parse::<u16>().ok())
+                .unwrap_or(8080);
+            cfg.control_base_url = format!("http://127.0.0.1:{port}");
+        }
+        let handle = Arc::new(Self {
+            cfg,
+            http: Client::builder()
+                .timeout(Duration::from_secs(20))
+                .build()
+                .unwrap_or_else(|_| Client::new()),
+            state: Arc::new(RwLock::new(recover_state())),
+            live_fill_counter: Arc::new(AtomicU64::new(0)),
+            challenger: Arc::new(Mutex::new(None)),
+        });
+        if handle.cfg.enabled {
+            let runner = handle.clone();
+            spawn_detached("seat_runtime", true, async move {
+                runner.run().await;
+            });
+        }
+        handle
+    }
+
+    pub(crate) fn live_fill_counter(&self) -> Arc<AtomicU64> {
+        self.live_fill_counter.clone()
+    }
+
+    pub(crate) async fn pause(&self, reason: String) -> SeatStatusReport {
+        let mut state = self.state.write().await;
+        state.paused = true;
+        state.pause_reason = Some(reason);
+        state.last_decision_ts_ms = now_ms();
+        let _ = write_state_atomic(&state);
+        drop(state);
+        self.status().await
+    }
+
+    pub(crate) async fn resume(&self) -> SeatStatusReport {
+        let mut state = self.state.write().await;
+        state.paused = false;
+        state.pause_reason = None;
+        state.last_decision_ts_ms = now_ms();
+        let _ = write_state_atomic(&state);
+        drop(state);
+        self.status().await
+    }
+
+    pub(crate) async fn force_layer(&self, req: SeatForceLayerReq) -> SeatStatusReport {
+        let mut state = self.state.write().await;
+        state.forced_layer = req.layer;
+        state.last_decision_ts_ms = now_ms();
+        let _ = write_state_atomic(&state);
+        drop(state);
+        self.status().await
+    }
+
+    pub(crate) async fn manual_override(&self, req: SeatManualOverrideReq) -> Result<SeatStatusReport> {
+        if req.params.is_empty() {
+            return Err(anyhow!("manual override params is empty"));
+        }
+        self.apply_params(&req.params, &self.cfg.control_base_url).await?;
+        let mut state = self.state.write().await;
+        state.manual_override = Some(req.params);
+        state.last_decision_ts_ms = now_ms();
+        write_state_atomic(&state)?;
+        drop(state);
+        Ok(self.status().await)
+    }
+
+    pub(crate) async fn clear_manual_override(&self) -> SeatStatusReport {
+        let mut state = self.state.write().await;
+        state.manual_override = None;
+        state.last_decision_ts_ms = now_ms();
+        let _ = write_state_atomic(&state);
+        drop(state);
+        self.status().await
+    }
+
+    pub(crate) async fn status(&self) -> SeatStatusReport {
+        let state = self.state.read().await;
+        SeatStatusReport {
+            ts_ms: now_ms(),
+            enabled: self.cfg.enabled,
+            paused: state.paused,
+            pause_reason: state.pause_reason.clone(),
+            current_layer: state.current_layer,
+            forced_layer: state.forced_layer,
+            global_pause_until_ms: state.global_pause_until_ms,
+            layer0_lock_until_ms: state.layer0_lock_until_ms,
+            active_shadow_until_ms: state.active_shadow_until_ms,
+            trade_count: state.live_fill_total.max(state.proxy_trade_total),
+            trade_count_source: state.trade_count_source.clone(),
+            started_ms: state.started_ms,
+            last_decision_ts_ms: state.last_decision_ts_ms,
+            degrade_streak: state.degrade_streak,
+            rollback_streak: state.rollback_streak,
+            smoothing_active: state.smoothing.is_some(),
+            monitor_active: state.monitor.is_some(),
+            manual_override_active: state.manual_override.is_some(),
+            last_objective: state.last_objective.clone(),
+        }
+    }
+
+    pub(crate) fn history(&self, limit: usize) -> Vec<SeatDecisionRecord> {
+        load_history(limit)
+    }
+
+    async fn run(self: Arc<Self>) {
+        let mut ticker = tokio::time::interval(Duration::from_secs(self.cfg.runtime_tick_sec.max(5)));
+        loop {
+            ticker.tick().await;
+            if let Err(err) = self.tick_once().await {
+                tracing::warn!(error = %err, "seat runtime tick failed");
+            }
+        }
+    }
+
+    async fn tick_once(&self) -> Result<()> {
+        let now = now_ms();
+        let Some((live, pnl)) = self.fetch_runtime_metrics().await? else {
+            return Ok(());
+        };
+        let objective = self.build_objective(&live, &pnl);
+        {
+            let mut state = self.state.write().await;
+            self.refresh_trade_counter(&mut state, &live);
+            self.push_history(&mut state, now, &objective);
+            state.last_objective = Some(objective.clone());
+            if now.saturating_sub(state.last_archive_ts_ms) > 86_400_000 {
+                archive_old_decisions(self.cfg.history_retention_days)?;
+                state.last_archive_ts_ms = now;
+            }
+        }
+
+        self.poll_challenger(now).await?;
+        self.process_smoothing(now).await?;
+        self.process_monitor(now, &objective).await?;
+        self.process_post_switch_degrade(now).await?;
+
+        if self.black_swan_triggered(&objective).await? {
+            self.force_layer0_lock("black_swan").await?;
+            return Ok(());
+        }
+
+        let due = {
+            let mut state = self.state.write().await;
+            let layer_pause_until = state
+                .layer_pause_until_ms
+                .get(state.current_layer.as_str())
+                .copied()
+                .unwrap_or(0);
+            if state.paused
+                || now < state.global_pause_until_ms
+                || now < state.active_shadow_until_ms
+                || now < layer_pause_until
+                || state.smoothing.is_some()
+                || state.monitor.is_some()
+            {
+                write_state_atomic(&state)?;
+                return Ok(());
+            }
+            if now.saturating_sub(state.last_activation_check_ms) >= (self.cfg.activation_check_sec as i64) * 1_000 {
+                state.last_activation_check_ms = now;
+                let target = self.target_layer(&state, now);
+                if target != state.current_layer {
+                    state.current_layer = target;
+                    let last_params = state.last_params.clone();
+                    self.record_decision_locked(
+                        &mut state,
+                        target,
+                        last_params,
+                        objective.clone(),
+                        "layer_switch".to_string(),
+                        false,
+                        Vec::new(),
+                    )?;
+                }
+            }
+            self.is_tune_due(&state, now)
+        };
+        if due {
+            let layer = self.state.read().await.current_layer;
+            self.run_tune_cycle(layer, objective, now).await?;
+        }
+        let state = self.state.read().await;
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    fn target_layer(&self, state: &SeatRuntimeState, now: i64) -> SeatLayer {
+        if now < state.layer0_lock_until_ms {
+            return SeatLayer::Layer0;
+        }
+        if let Some(forced) = state.forced_layer {
+            return forced;
+        }
+        let trade_count = state.live_fill_total.max(state.proxy_trade_total);
+        let uptime_sec = ((now.saturating_sub(state.started_ms)) / 1_000).max(0) as u64;
+        if trade_count < self.cfg.layer1_min_trades || uptime_sec < 48 * 3_600 {
+            SeatLayer::Layer0
+        } else if trade_count >= self.cfg.layer3_min_trades
+            || (uptime_sec >= self.cfg.layer3_min_uptime_sec && trade_count >= self.cfg.layer2_min_trades)
+        {
+            SeatLayer::Layer3
+        } else if trade_count >= self.cfg.layer2_min_trades && uptime_sec >= self.cfg.layer2_min_uptime_sec {
+            SeatLayer::Layer2
+        } else {
+            SeatLayer::Layer1
+        }
+    }
+
+    fn is_tune_due(&self, state: &SeatRuntimeState, now: i64) -> bool {
+        let key = state.current_layer.as_str().to_string();
+        let Some(last_ms) = state.last_tune_ms_by_layer.get(&key).copied() else {
+            return true;
+        };
+        let interval = match state.current_layer {
+            SeatLayer::Layer0 | SeatLayer::Layer1 => self.cfg.layer1_interval_sec,
+            SeatLayer::Layer2 => self.cfg.layer2_interval_sec,
+            SeatLayer::Layer3 => self.cfg.layer3_interval_sec,
+        };
+        now.saturating_sub(last_ms) >= (interval as i64) * 1_000
+    }
+
+    fn effective_shadow_sec(&self, layer: SeatLayer) -> u64 {
+        match layer {
+            SeatLayer::Layer2 => self.cfg.layer2_shadow_sec,
+            SeatLayer::Layer3 => self.cfg.layer3_shadow_sec.max(20 * 5 * 60),
+            SeatLayer::Layer0 | SeatLayer::Layer1 => 0,
+        }
+    }
+
+    fn required_shadow_cycles(&self, layer: SeatLayer, shadow_sec: u64) -> u32 {
+        match layer {
+            SeatLayer::Layer3 => (shadow_sec / (5 * 60)).max(20) as u32,
+            SeatLayer::Layer2 => (shadow_sec / (5 * 60)).max(1) as u32,
+            SeatLayer::Layer0 | SeatLayer::Layer1 => 0,
+        }
+    }
+
+    fn build_objective(&self, live: &ShadowLiveLite, pnl: &PnlLite) -> SeatObjectiveSnapshot {
+        let source_health_min = if live.source_health.is_empty() {
+            1.0
+        } else {
+            live.source_health.iter().map(|row| row.score).fold(1.0_f64, f64::min)
+        };
+        let objective = live.ev_net_usdc_p50
+            + live.roi_notional_10s_bps_p50 * 0.01
+            + live.ev_positive_ratio * 0.5
+            - pnl.max_drawdown_pct.max(0.0) * self.cfg.objective_drawdown_penalty;
+        SeatObjectiveSnapshot {
+            ev_usdc_p50: live.ev_net_usdc_p50,
+            max_drawdown_pct: pnl.max_drawdown_pct.max(0.0),
+            roi_notional_10s_bps_p50: live.roi_notional_10s_bps_p50,
+            win_rate: live.ev_positive_ratio,
+            source_health_min,
+            volatility_proxy: live.pnl_10s_p50_bps_raw.abs(),
+            objective,
+        }
+    }
+
+    fn refresh_trade_counter(&self, state: &mut SeatRuntimeState, live: &ShadowLiveLite) {
+        let live_seen = self.live_fill_counter.load(Ordering::Relaxed);
+        let live_delta = if live_seen >= state.live_fill_seen { live_seen - state.live_fill_seen } else { live_seen };
+        state.live_fill_total = state.live_fill_total.saturating_add(live_delta);
+        state.live_fill_seen = live_seen;
+
+        let proxy_delta = if live.executed_count >= state.proxy_trade_seen {
+            live.executed_count - state.proxy_trade_seen
+        } else {
+            live.executed_count
+        };
+        state.proxy_trade_total = state.proxy_trade_total.saturating_add(proxy_delta);
+        state.proxy_trade_seen = live.executed_count;
+        let live_expected = !env_flag_enabled("POLYEDGE_FORCE_PAPER") && env_flag_enabled("POLYEDGE_LIVE_ARMED");
+        state.trade_count_source = if live_expected && state.live_fill_total > 0 {
+            "live_fill".to_string()
+        } else {
+            "proxy".to_string()
+        };
+    }
+
+    fn push_history(&self, state: &mut SeatRuntimeState, ts_ms: i64, objective: &SeatObjectiveSnapshot) {
+        state.objective_history.push(SeatObjectivePoint { ts_ms, objective: objective.objective });
+        state.volatility_history.push(SeatObjectivePoint { ts_ms, objective: objective.volatility_proxy });
+        let keep_after = ts_ms.saturating_sub(8 * 24 * 3_600 * 1_000);
+        state.objective_history.retain(|p| p.ts_ms >= keep_after);
+        state.volatility_history.retain(|p| p.ts_ms >= keep_after);
+    }
+
+    async fn fetch_runtime_metrics(&self) -> Result<Option<(ShadowLiveLite, PnlLite)>> {
+        let live_resp = match self.http.get(format!("{}/report/shadow/live", self.cfg.control_base_url)).send().await {
+            Ok(v) => v,
+            Err(_) => return Ok(None),
+        };
+        if !live_resp.status().is_success() {
+            return Ok(None);
+        }
+        let live = live_resp.json::<ShadowLiveLite>().await.context("parse shadow live")?;
+        let pnl_resp = self
+            .http
+            .get(format!("{}/state/pnl", self.cfg.control_base_url))
+            .send()
+            .await
+            .context("get state pnl")?;
+        if !pnl_resp.status().is_success() {
+            return Ok(None);
+        }
+        let pnl = pnl_resp.json::<PnlLite>().await.context("parse state pnl")?;
+        Ok(Some((live, pnl)))
+    }
+
+    async fn black_swan_triggered(&self, objective: &SeatObjectiveSnapshot) -> Result<bool> {
+        let state = self.state.read().await;
+        let mut vols = state
+            .volatility_history
+            .iter()
+            .map(|p| p.objective)
+            .filter(|v| v.is_finite())
+            .collect::<Vec<_>>();
+        if vols.len() < 32 {
+            return Ok(objective.source_health_min < self.cfg.source_health_floor);
+        }
+        vols.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
+        let idx = ((vols.len() as f64) * 0.95).floor() as usize;
+        let p95 = vols
+            .get(idx.min(vols.len().saturating_sub(1)))
+            .copied()
+            .unwrap_or(0.0);
+        Ok(objective.volatility_proxy > p95 || objective.source_health_min < self.cfg.source_health_floor)
+    }
+
+    async fn force_layer0_lock(&self, reason: &str) -> Result<()> {
+        let now = now_ms();
+        let mut state = self.state.write().await;
+        state.current_layer = SeatLayer::Layer0;
+        state.layer0_lock_until_ms = now + (self.cfg.black_swan_lock_sec as i64) * 1_000;
+        state.active_shadow_until_ms = 0;
+        state.smoothing = None;
+        state.monitor = None;
+        let last_params = state.last_params.clone();
+        let last_objective = state.last_objective.clone().unwrap_or_default();
+        self.record_decision_locked(
+            &mut state,
+            SeatLayer::Layer0,
+            last_params,
+            last_objective,
+            format!("force_layer0:{reason}"),
+            false,
+            vec![reason.to_string()],
+        )?;
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    async fn run_tune_cycle(&self, layer: SeatLayer, baseline: SeatObjectiveSnapshot, now: i64) -> Result<()> {
+        let current = match self.capture_current_params().await {
+            Ok(v) => v,
+            Err(_) => self.state.read().await.last_params.clone(),
+        };
+        let (mut candidate, proposal_notes) = match layer {
+            SeatLayer::Layer0 => (self.layer0_candidate(&current, &baseline), Vec::new()),
+            SeatLayer::Layer1 | SeatLayer::Layer2 | SeatLayer::Layer3 => {
+                let proposal = self.optimizer_candidate(layer, &current, &baseline).await?;
+                let mut notes = proposal.notes.clone();
+                notes.push(format!(
+                    "mc_ev_delta_p50={:.6}",
+                    proposal.validation.mc_ev_delta_p50
+                ));
+                notes.push(format!(
+                    "mc_drawdown_p95={:.6}",
+                    proposal.validation.mc_drawdown_p95
+                ));
+                notes.push(format!(
+                    "style_match_score={:.6}",
+                    proposal.meta.style_match_score
+                ));
+                notes.push(format!("style_match_count={}", proposal.meta.style_match_count));
+                notes.push(format!("top_k_size={}", proposal.meta.top_k_size));
+                notes.push(format!(
+                    "walk_forward_windows={}",
+                    proposal.validation.walk_forward_windows
+                ));
+                notes.push(format!(
+                    "walk_forward_score={:.6}",
+                    proposal.validation.walk_forward_score
+                ));
+                notes.push(format!(
+                    "objective_uplift_estimate={:.6}",
+                    proposal.meta.objective_uplift_estimate
+                ));
+                notes.push(format!("rl_signal={:.6}", proposal.meta.rl_signal));
+                (proposal.candidate, notes)
+            }
+        };
+        {
+            let state = self.state.read().await;
+            if let Some(override_params) = &state.manual_override {
+                candidate = override_params.merge_over(&candidate);
+            }
+        }
+        candidate = candidate
+            .clamp_relative(&current, layer.step_limit_pct())
+            .merge_over(&current);
+
+        if layer == SeatLayer::Layer2 || layer == SeatLayer::Layer3 {
+            let shadow_sec = self.effective_shadow_sec(layer);
+            let started = self
+                .start_challenger(
+                    layer,
+                    current.clone(),
+                    candidate.clone(),
+                    baseline.clone(),
+                    shadow_sec,
+                    now,
+                    proposal_notes.clone(),
+                )
+                .await?;
+            if !started {
+                let mut state = self.state.write().await;
+                self.record_decision_locked(
+                    &mut state,
+                    layer,
+                    current,
+                    baseline,
+                    "shadow_skip_active".to_string(),
+                    false,
+                    vec!["active_shadow_window_in_progress".to_string()],
+                )?;
+                write_state_atomic(&state)?;
+                return Ok(());
+            }
+        } else {
+            self.begin_smoothing(layer, current, candidate, baseline, now, proposal_notes)
+                .await?;
+        }
+
+        let mut state = self.state.write().await;
+        state
+            .last_tune_ms_by_layer
+            .insert(layer.as_str().to_string(), now);
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    fn layer0_candidate(&self, current: &SeatParameterSet, baseline: &SeatObjectiveSnapshot) -> SeatParameterSet {
+        let mut out = current.clone();
+        let tighten = baseline.ev_usdc_p50 < 0.0 || baseline.max_drawdown_pct > 0.05;
+        if let Some(v) = current.position_fraction {
+            out.position_fraction = Some(if tighten { v * 0.97 } else { v * 1.01 });
+        }
+        if let Some(v) = current.early_size_scale {
+            out.early_size_scale = Some(if tighten { v * 0.98 } else { v * 1.02 });
+        }
+        if let Some(v) = current.maturity_size_scale {
+            out.maturity_size_scale = Some(if tighten { v * 0.99 } else { v * 1.01 });
+        }
+        if let Some(v) = current.late_size_scale {
+            out.late_size_scale = Some(if tighten { v * 0.98 } else { v * 1.02 });
+        }
+        if let Some(v) = current.min_edge_net_bps {
+            out.min_edge_net_bps = Some(if tighten { v * 1.03 } else { v * 0.99 });
+        }
+        if let Some(v) = current.convergence_exit_ratio {
+            out.convergence_exit_ratio = Some(if tighten {
+                (v * 0.99).max(0.10)
+            } else {
+                (v * 1.005).min(0.99)
+            });
+        }
+        if let Some(v) = current.min_velocity_bps_per_sec {
+            out.min_velocity_bps_per_sec = Some(if tighten { v * 1.03 } else { v * 0.99 });
+        }
+        out.clamp_relative(current, SeatLayer::Layer0.step_limit_pct())
+    }
+
+    async fn optimizer_candidate(
+        &self,
+        layer: SeatLayer,
+        current: &SeatParameterSet,
+        baseline: &SeatObjectiveSnapshot,
+    ) -> Result<SeatOptimizerProposal> {
+        let endpoint = match layer {
+            SeatLayer::Layer1 => "l1",
+            SeatLayer::Layer2 => "l2",
+            SeatLayer::Layer3 => {
+                let state = self.state.read().await;
+                if state.style_memory.len() < 8 {
+                    "l2"
+                } else {
+                    "l3"
+                }
+            }
+            SeatLayer::Layer0 => "l1",
+        };
+        let current_style = SeatStyleVector {
+            volatility_proxy: baseline.volatility_proxy,
+            source_health_min: baseline.source_health_min,
+            roi_notional_10s_bps_p50: baseline.roi_notional_10s_bps_p50,
+            win_rate: baseline.win_rate,
+        };
+        let (style_memory, objective_history, volatility_history) = {
+            let state = self.state.read().await;
+            (
+                state.style_memory.clone(),
+                state
+                    .objective_history
+                    .iter()
+                    .rev()
+                    .take(1_440)
+                    .cloned()
+                    .collect::<Vec<_>>()
+                    .into_iter()
+                    .rev()
+                    .collect::<Vec<_>>(),
+                state
+                    .volatility_history
+                    .iter()
+                    .rev()
+                    .take(1_440)
+                    .cloned()
+                    .collect::<Vec<_>>()
+                    .into_iter()
+                    .rev()
+                    .collect::<Vec<_>>(),
+            )
+        };
+        let payload = serde_json::json!({
+            "layer": layer.as_str(),
+            "current_params": current,
+            "baseline": baseline,
+            "style_memory": style_memory,
+            "current_style": current_style,
+            "objective_history": objective_history,
+            "volatility_history": volatility_history,
+        });
+        let resp = self
+            .http
+            .post(format!("{}/v1/seat/{endpoint}/optimize", self.cfg.optimizer_url))
+            .json(&payload)
+            .send()
+            .await
+            .with_context(|| format!("seat optimizer {endpoint}"))?;
+        if !resp.status().is_success() {
+            return Err(anyhow!("seat optimizer status={}", resp.status()));
+        }
+        let proposal = resp
+            .json::<SeatOptimizerProposal>()
+            .await
+            .context("parse optimizer proposal")?;
+        let required_mc = match layer {
+            SeatLayer::Layer1 => 100,
+            SeatLayer::Layer2 => 500,
+            SeatLayer::Layer3 => 1_000,
+            SeatLayer::Layer0 => 100,
+        };
+        if proposal.validation.mc_runs < required_mc || !proposal.validation.mc_pass {
+            return Err(anyhow!(
+                "optimizer validation failed mc_runs={} mc_pass={}",
+                proposal.validation.mc_runs,
+                proposal.validation.mc_pass
+            ));
+        }
+        if layer != SeatLayer::Layer1 && !proposal.validation.walk_forward_pass {
+            return Err(anyhow!("optimizer walk-forward validation failed"));
+        }
+        if layer != SeatLayer::Layer1 && !proposal.validation.shadow_pass {
+            return Err(anyhow!("optimizer shadow validation failed"));
+        }
+        Ok(proposal)
+    }
+
+    async fn begin_smoothing(
+        &self,
+        layer: SeatLayer,
+        old_params: SeatParameterSet,
+        candidate: SeatParameterSet,
+        baseline: SeatObjectiveSnapshot,
+        now: i64,
+        mut notes: Vec<String>,
+    ) -> Result<()> {
+        let mut state = self.state.write().await;
+        let pre_switch = self.mean_objective_24h_locked(&state, now).unwrap_or(baseline.objective);
+        state.pre_switch_objective_24h = Some(pre_switch);
+        state.smoothing = Some(SeatSmoothingState {
+            layer,
+            old_params: old_params.clone(),
+            target_params: candidate.clone(),
+            current_params: old_params,
+            baseline: baseline.clone(),
+            started_ms: now,
+            end_ms: now + (self.cfg.smoothing_sec as i64) * 1_000,
+            next_step_ms: now,
+        });
+        notes.push(format!("pre_switch_objective_24h={pre_switch:.6}"));
+        self.record_decision_locked(
+            &mut state,
+            layer,
+            candidate,
+            baseline,
+            "smoothing_started".to_string(),
+            false,
+            notes,
+        )?;
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    async fn process_smoothing(&self, now: i64) -> Result<()> {
+        let mut start_monitor = None::<(
+            SeatLayer,
+            SeatParameterSet,
+            SeatParameterSet,
+            SeatObjectiveSnapshot,
+            f64,
+        )>;
+        {
+            let mut state = self.state.write().await;
+            let Some(mut smooth) = state.smoothing.clone() else {
+                return Ok(());
+            };
+            if now < smooth.next_step_ms {
+                return Ok(());
+            }
+            if now >= smooth.end_ms {
+                self.apply_params(&smooth.target_params, &self.cfg.control_base_url)
+                    .await?;
+                start_monitor = Some((
+                    smooth.layer,
+                    smooth.old_params.clone(),
+                    smooth.target_params.clone(),
+                    smooth.baseline.clone(),
+                    state.pre_switch_objective_24h.unwrap_or(0.0),
+                ));
+                state.smoothing = None;
+            } else {
+                smooth.current_params.exp_blend_towards(&smooth.target_params, 0.7);
+                self.apply_params(&smooth.current_params, &self.cfg.control_base_url)
+                    .await?;
+                smooth.next_step_ms = smooth.next_step_ms.saturating_add(5 * 60 * 1_000);
+                state.smoothing = Some(smooth);
+            }
+            write_state_atomic(&state)?;
+        }
+        if let Some((layer, old_params, new_params, baseline, pre_switch)) = start_monitor {
+            let mut state = self.state.write().await;
+            state.monitor = Some(SeatMonitorState {
+                layer,
+                old_params,
+                new_params,
+                baseline,
+                pre_switch_objective_24h: pre_switch,
+                started_ms: now,
+                end_ms: now + (self.cfg.monitor_sec as i64) * 1_000,
+            });
+            write_state_atomic(&state)?;
+        }
+        Ok(())
+    }
+
+    async fn process_monitor(&self, now: i64, objective: &SeatObjectiveSnapshot) -> Result<()> {
+        let monitor = self.state.read().await.monitor.clone();
+        let Some(monitor) = monitor else {
+            return Ok(());
+        };
+        if now < monitor.end_ms {
+            let local_rollback = objective.ev_usdc_p50 < monitor.baseline.ev_usdc_p50
+                || objective.max_drawdown_pct > monitor.baseline.max_drawdown_pct;
+            let remote_rollback = match self
+                .http
+                .post(format!("{}/v1/seat/monitor_60m", self.cfg.optimizer_url))
+                .json(&serde_json::json!({
+                    "layer": monitor.layer.as_str(),
+                    "ev_new": objective.ev_usdc_p50,
+                    "ev_old": monitor.baseline.ev_usdc_p50,
+                    "dd_new": objective.max_drawdown_pct,
+                    "dd_old": monitor.baseline.max_drawdown_pct,
+                }))
+                .send()
+                .await
+            {
+                Ok(resp) => match resp.json::<serde_json::Value>().await {
+                    Ok(body) => body
+                        .get("rollback")
+                        .and_then(|x| x.as_bool())
+                        .unwrap_or(local_rollback),
+                    Err(_) => local_rollback,
+                },
+                Err(_) => local_rollback,
+            };
+            if local_rollback || remote_rollback {
+                self.rollback_with_pause(
+                    monitor.layer,
+                    monitor.old_params,
+                    monitor.baseline,
+                    "monitor_regression",
+                    now,
+                )
+                .await?;
+            }
+            return Ok(());
+        }
+
+        let entry = {
+            let mut state = self.state.write().await;
+            state.monitor = None;
+            state.rollback_streak = 0;
+            state.post_switch_eval_due_ms = now + 24 * 3_600 * 1_000;
+            state.post_switch_start_ms = now;
+            state.post_switch_baseline_24h = Some(monitor.pre_switch_objective_24h);
+            state.post_switch_layer = Some(monitor.layer);
+            let entry = self.update_style_memory_locked(&mut state, objective, &monitor.new_params, now);
+            self.record_decision_locked(
+                &mut state,
+                monitor.layer,
+                monitor.new_params,
+                objective.clone(),
+                "monitor_pass".to_string(),
+                false,
+                vec![
+                    format!("style_objective={:.6}", entry.objective),
+                    format!("style_id={}", entry.style_id),
+                ],
+            )?;
+            write_state_atomic(&state)?;
+            entry
+        };
+        let _ = self
+            .push_style_memory_update(monitor.layer, &entry, objective)
+            .await;
+        Ok(())
+    }
+
+    async fn process_post_switch_degrade(&self, now: i64) -> Result<()> {
+        let maybe = {
+            let state = self.state.read().await;
+            if state.post_switch_eval_due_ms == 0 || now < state.post_switch_eval_due_ms {
+                None
+            } else {
+                Some((
+                    state.post_switch_layer.unwrap_or(SeatLayer::Layer0),
+                    state.post_switch_start_ms,
+                    state.post_switch_baseline_24h.unwrap_or(0.0),
+                ))
+            }
+        };
+        let Some((layer, start_ms, baseline)) = maybe else {
+            return Ok(());
+        };
+        let post_mean = {
+            let state = self.state.read().await;
+            let values = state
+                .objective_history
+                .iter()
+                .filter(|p| p.ts_ms >= start_ms)
+                .map(|p| p.objective)
+                .collect::<Vec<_>>();
+            if values.is_empty() {
+                baseline
+            } else {
+                values.iter().sum::<f64>() / values.len() as f64
+            }
+        };
+        let mut state = self.state.write().await;
+        state.post_switch_eval_due_ms = 0;
+        state.post_switch_baseline_24h = None;
+        state.post_switch_layer = None;
+        if post_mean < baseline {
+            self.downgrade_locked(&mut state, layer, format!("{post_mean:.6}<{baseline:.6}"))?;
+        } else {
+            state.degrade_streak = 0;
+        }
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    async fn rollback_with_pause(
+        &self,
+        layer: SeatLayer,
+        old_params: SeatParameterSet,
+        baseline: SeatObjectiveSnapshot,
+        reason: &str,
+        now: i64,
+    ) -> Result<()> {
+        self.apply_params(&old_params, &self.cfg.control_base_url).await?;
+        let mut state = self.state.write().await;
+        state.smoothing = None;
+        state.monitor = None;
+        state
+            .layer_pause_until_ms
+            .insert(layer.as_str().to_string(), now + (self.cfg.rollback_pause_sec as i64) * 1_000);
+        state.rollback_streak = state.rollback_streak.saturating_add(1);
+        if state.rollback_streak >= 2 {
+            state.global_pause_until_ms = now + (self.cfg.global_pause_sec as i64) * 1_000;
+            state.layer0_lock_until_ms = now + (self.cfg.layer0_lock_sec as i64) * 1_000;
+            state.current_layer = SeatLayer::Layer0;
+        }
+        self.record_decision_locked(
+            &mut state,
+            layer,
+            old_params,
+            baseline,
+            format!("rollback:{reason}"),
+            true,
+            vec![reason.to_string()],
+        )?;
+        write_state_atomic(&state)?;
+        Ok(())
+    }
+
+    fn downgrade_locked(&self, state: &mut SeatRuntimeState, from_layer: SeatLayer, reason: String) -> Result<()> {
+        let next = match from_layer {
+            SeatLayer::Layer3 => SeatLayer::Layer2,
+            SeatLayer::Layer2 => SeatLayer::Layer1,
+            SeatLayer::Layer1 | SeatLayer::Layer0 => SeatLayer::Layer0,
+        };
+        state.current_layer = next;
+        state
+            .layer_pause_until_ms
+            .insert(from_layer.as_str().to_string(), now_ms() + (self.cfg.rollback_pause_sec as i64) * 1_000);
+        state.degrade_streak = state.degrade_streak.saturating_add(1);
+        if state.degrade_streak >= 2 {
+            state.current_layer = SeatLayer::Layer0;
+            state.layer0_lock_until_ms = now_ms() + (self.cfg.layer0_lock_sec as i64) * 1_000;
+            state.degrade_streak = 0;
+        }
+        let last_params = state.last_params.clone();
+        let last_objective = state.last_objective.clone().unwrap_or_default();
+        self.record_decision_locked(
+            state,
+            state.current_layer,
+            last_params,
+            last_objective,
+            format!("downgrade:{reason}"),
+            false,
+            vec![reason],
+        )?;
+        Ok(())
+    }
+
+    fn mean_objective_24h_locked(&self, state: &SeatRuntimeState, now: i64) -> Option<f64> {
+        let start = now.saturating_sub(24 * 3_600 * 1_000);
+        let values = state
+            .objective_history
+            .iter()
+            .filter(|p| p.ts_ms >= start && p.ts_ms <= now)
+            .map(|p| p.objective)
+            .collect::<Vec<_>>();
+        if values.is_empty() {
+            None
+        } else {
+            Some(values.iter().sum::<f64>() / values.len() as f64)
+        }
+    }
+
+    fn update_style_memory_locked(
+        &self,
+        state: &mut SeatRuntimeState,
+        objective: &SeatObjectiveSnapshot,
+        params: &SeatParameterSet,
+        now: i64,
+    ) -> SeatStyleMemoryEntry {
+        let vector = SeatStyleVector {
+            volatility_proxy: objective.volatility_proxy,
+            source_health_min: objective.source_health_min,
+            roi_notional_10s_bps_p50: objective.roi_notional_10s_bps_p50,
+            win_rate: objective.win_rate,
+        };
+        let style_id = self.style_id(&vector);
+        if let Some(entry) = state.style_memory.iter_mut().find(|entry| entry.style_id == style_id) {
+            entry.vector = vector;
+            entry.params = params.clone();
+            entry.objective = objective.objective;
+            entry.updated_ms = now;
+            return entry.clone();
+        }
+        if state.style_memory.len() < 8 {
+            let entry = SeatStyleMemoryEntry {
+                style_id,
+                vector,
+                params: params.clone(),
+                objective: objective.objective,
+                updated_ms: now,
+            };
+            state.style_memory.push(entry.clone());
+            return entry;
+        }
+        if let Some((idx, _)) = state
+            .style_memory
+            .iter()
+            .enumerate()
+            .min_by(|(_, a), (_, b)| a.objective.partial_cmp(&b.objective).unwrap_or(std::cmp::Ordering::Equal))
+        {
+            let entry = SeatStyleMemoryEntry {
+                style_id,
+                vector,
+                params: params.clone(),
+                objective: objective.objective,
+                updated_ms: now,
+            };
+            state.style_memory[idx] = entry.clone();
+            return entry;
+        }
+        SeatStyleMemoryEntry {
+            style_id,
+            vector,
+            params: params.clone(),
+            objective: objective.objective,
+            updated_ms: now,
+        }
+    }
+
+    fn style_id(&self, vector: &SeatStyleVector) -> String {
+        let vol = if vector.volatility_proxy > 8.0 { "hv" } else { "lv" };
+        let health = if vector.source_health_min > 0.6 { "hh" } else { "lh" };
+        let drift = if vector.roi_notional_10s_bps_p50 > 0.0 { "pr" } else { "ng" };
+        format!("{vol}_{health}_{drift}")
+    }
+
+    async fn push_style_memory_update(
+        &self,
+        layer: SeatLayer,
+        entry: &SeatStyleMemoryEntry,
+        objective: &SeatObjectiveSnapshot,
+    ) -> Result<()> {
+        let resp = self
+            .http
+            .post(format!("{}/v1/seat/style_memory/update", self.cfg.optimizer_url))
+            .json(&serde_json::json!({
+                "layer": layer.as_str(),
+                "entry": entry,
+                "reward": objective.objective,
+                "objective": objective,
+            }))
+            .send()
+            .await?;
+        if !resp.status().is_success() {
+            return Err(anyhow!("style memory update failed status={}", resp.status()));
+        }
+        Ok(())
+    }
+
+    fn record_decision_locked(
+        &self,
+        state: &mut SeatRuntimeState,
+        layer: SeatLayer,
+        candidate: SeatParameterSet,
+        baseline: SeatObjectiveSnapshot,
+        decision: String,
+        rollback: bool,
+        notes: Vec<String>,
+    ) -> Result<()> {
+        let previous = state.last_params.clone();
+        state.last_decision_ts_ms = now_ms();
+        state.decision_seq = state.decision_seq.saturating_add(1);
+        state.last_params = candidate.clone();
+        let record = SeatDecisionRecord {
+            ts_ms: state.last_decision_ts_ms,
+            layer,
+            previous,
+            candidate,
+            baseline,
+            decision,
+            rollback,
+            lock_state: SeatLockState {
+                paused: state.paused,
+                global_pause_until_ms: state.global_pause_until_ms,
+                layer0_lock_until_ms: state.layer0_lock_until_ms,
+                active_shadow_until_ms: state.active_shadow_until_ms,
+            },
+            trade_count_source: state.trade_count_source.clone(),
+            notes,
+        };
+        append_decision(&record)?;
+        write_tune_report(&record, state)?;
+        Ok(())
+    }
+
+    async fn apply_params(&self, params: &SeatParameterSet, base_url: &str) -> Result<()> {
+        if params.is_empty() {
+            return Ok(());
+        }
+        if params.position_fraction.is_some()
+            || params.early_size_scale.is_some()
+            || params.maturity_size_scale.is_some()
+            || params.late_size_scale.is_some()
+            || params.min_edge_net_bps.is_some()
+            || params.min_velocity_bps_per_sec.is_some()
+        {
+            let mut body = serde_json::Map::new();
+            if params.position_fraction.is_some() {
+                body.insert(
+                    "compounder".to_string(),
+                    serde_json::json!({"position_fraction": params.position_fraction}),
+                );
+            }
+            if params.early_size_scale.is_some()
+                || params.maturity_size_scale.is_some()
+                || params.late_size_scale.is_some()
+            {
+                body.insert(
+                    "v52_time_phase".to_string(),
+                    serde_json::json!({
+                        "early_size_scale": params.early_size_scale,
+                        "maturity_size_scale": params.maturity_size_scale,
+                        "late_size_scale": params.late_size_scale
+                    }),
+                );
+            }
+            if params.min_edge_net_bps.is_some() {
+                body.insert(
+                    "taker_sniper".to_string(),
+                    serde_json::json!({"min_edge_net_bps": params.min_edge_net_bps}),
+                );
+            }
+            if params.min_velocity_bps_per_sec.is_some() {
+                body.insert(
+                    "direction_detector".to_string(),
+                    serde_json::json!({"min_velocity_bps_per_sec": params.min_velocity_bps_per_sec}),
+                );
+            }
+            self.http
+                .post(format!("{base_url}/control/reload_predator_c"))
+                .json(&serde_json::Value::Object(body))
+                .send()
+                .await?
+                .error_for_status()?;
+        }
+        if params.convergence_exit_ratio.is_some()
+            || params.t100ms_reversal_bps.is_some()
+            || params.t300ms_reversal_bps.is_some()
+            || params.max_single_trade_loss_usdc.is_some()
+        {
+            self.http
+                .post(format!("{base_url}/control/reload_exit"))
+                .json(&serde_json::json!({
+                    "convergence_exit_ratio": params.convergence_exit_ratio,
+                    "t100ms_reversal_bps": params.t100ms_reversal_bps,
+                    "t300ms_reversal_bps": params.t300ms_reversal_bps,
+                    "max_single_trade_loss_usdc": params.max_single_trade_loss_usdc
+                }))
+                .send()
+                .await?
+                .error_for_status()?;
+        }
+        if params.capital_fraction_kelly.is_some() {
+            self.http
+                .post(format!("{base_url}/control/reload_allocator"))
+                .json(&serde_json::json!({
+                    "capital_fraction_kelly": params.capital_fraction_kelly
+                }))
+                .send()
+                .await?
+                .error_for_status()?;
+        }
+        if params.risk_max_drawdown_pct.is_some() || params.risk_max_market_notional.is_some() {
+            self.http
+                .post(format!("{base_url}/control/reload_risk"))
+                .json(&serde_json::json!({
+                    "daily_drawdown_cap_pct": params.risk_max_drawdown_pct,
+                    "max_market_notional": params.risk_max_market_notional
+                }))
+                .send()
+                .await?
+                .error_for_status()?;
+        }
+        if params.maker_min_edge_bps.is_some() || params.basis_k_revert.is_some() || params.basis_z_cap.is_some() {
+            self.http
+                .post(format!("{base_url}/control/reload_strategy"))
+                .json(&serde_json::json!({
+                    "min_edge_bps": params.maker_min_edge_bps,
+                    "basis_k_revert": params.basis_k_revert,
+                    "basis_z_cap": params.basis_z_cap
+                }))
+                .send()
+                .await?
+                .error_for_status()?;
+        }
+        Ok(())
+    }
+
+    async fn capture_current_params(&self) -> Result<SeatParameterSet> {
+        #[derive(Debug, Deserialize)]
+        struct PredatorResp {
+            predator_c: serde_json::Value,
+        }
+        #[derive(Debug, Deserialize)]
+        struct ExitResp {
+            exit: serde_json::Value,
+        }
+        #[derive(Debug, Deserialize)]
+        struct AllocatorResp {
+            allocator: serde_json::Value,
+        }
+        #[derive(Debug, Deserialize)]
+        struct RiskResp {
+            risk: serde_json::Value,
+        }
+        #[derive(Debug, Deserialize)]
+        struct StrategyResp {
+            maker: serde_json::Value,
+            fair_value: serde_json::Value,
+            v52: serde_json::Value,
+        }
+
+        let predator = self
+            .http
+            .post(format!("{}/control/reload_predator_c", self.cfg.control_base_url))
+            .json(&serde_json::json!({}))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<PredatorResp>()
+            .await?;
+        let exit = self
+            .http
+            .post(format!("{}/control/reload_exit", self.cfg.control_base_url))
+            .json(&serde_json::json!({}))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<ExitResp>()
+            .await?;
+        let allocator = self
+            .http
+            .post(format!("{}/control/reload_allocator", self.cfg.control_base_url))
+            .json(&serde_json::json!({}))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<AllocatorResp>()
+            .await?;
+        let risk = self
+            .http
+            .post(format!("{}/control/reload_risk", self.cfg.control_base_url))
+            .json(&serde_json::json!({}))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<RiskResp>()
+            .await?;
+        let strategy = self
+            .http
+            .post(format!("{}/control/reload_strategy", self.cfg.control_base_url))
+            .json(&serde_json::json!({}))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<StrategyResp>()
+            .await?;
+
+        Ok(SeatParameterSet {
+            position_fraction: predator
+                .predator_c
+                .get("compounder")
+                .and_then(|v| v.get("position_fraction"))
+                .and_then(|v| v.as_f64()),
+            early_size_scale: strategy
+                .v52
+                .get("time_phase")
+                .and_then(|v| v.get("early_size_scale"))
+                .and_then(|v| v.as_f64()),
+            maturity_size_scale: strategy
+                .v52
+                .get("time_phase")
+                .and_then(|v| v.get("maturity_size_scale"))
+                .and_then(|v| v.as_f64()),
+            late_size_scale: strategy
+                .v52
+                .get("time_phase")
+                .and_then(|v| v.get("late_size_scale"))
+                .and_then(|v| v.as_f64()),
+            min_edge_net_bps: predator
+                .predator_c
+                .get("taker_sniper")
+                .and_then(|v| v.get("min_edge_net_bps"))
+                .and_then(|v| v.as_f64()),
+            convergence_exit_ratio: exit
+                .exit
+                .get("convergence_exit_ratio")
+                .and_then(|v| v.as_f64()),
+            min_velocity_bps_per_sec: predator
+                .predator_c
+                .get("direction_detector")
+                .and_then(|v| v.get("min_velocity_bps_per_sec"))
+                .and_then(|v| v.as_f64()),
+            capital_fraction_kelly: allocator
+                .allocator
+                .get("capital_fraction_kelly")
+                .and_then(|v| v.as_f64()),
+            t100ms_reversal_bps: exit
+                .exit
+                .get("t100ms_reversal_bps")
+                .and_then(|v| v.as_f64()),
+            t300ms_reversal_bps: exit
+                .exit
+                .get("t300ms_reversal_bps")
+                .and_then(|v| v.as_f64()),
+            max_single_trade_loss_usdc: exit
+                .exit
+                .get("max_single_trade_loss_usdc")
+                .and_then(|v| v.as_f64()),
+            risk_max_drawdown_pct: risk
+                .risk
+                .get("max_drawdown_pct")
+                .and_then(|v| v.as_f64()),
+            risk_max_market_notional: risk
+                .risk
+                .get("max_market_notional")
+                .and_then(|v| v.as_f64()),
+            maker_min_edge_bps: strategy
+                .maker
+                .get("min_edge_bps")
+                .and_then(|v| v.as_f64()),
+            basis_k_revert: strategy
+                .fair_value
+                .get("k_revert")
+                .and_then(|v| v.as_f64()),
+            basis_z_cap: strategy.fair_value.get("z_cap").and_then(|v| v.as_f64()),
+        })
+    }
+
+    async fn start_challenger(
+        &self,
+        layer: SeatLayer,
+        old_params: SeatParameterSet,
+        candidate: SeatParameterSet,
+        baseline: SeatObjectiveSnapshot,
+        shadow_sec: u64,
+        now: i64,
+        mut notes: Vec<String>,
+    ) -> Result<bool> {
+        let mut guard = self.challenger.lock().await;
+        if guard.is_some() {
+            return Ok(false);
+        }
+        let required_cycles = self.required_shadow_cycles(layer, shadow_sec);
+        let port = self.find_available_port()?;
+        let root = self.build_challenger_dataset_root(now, layer);
+        let mut cmd = Command::new(std::env::current_exe().context("resolve current exe")?);
+        cmd.env("POLYEDGE_FORCE_PAPER", "true")
+            .env("POLYEDGE_SEAT_ENABLED", "false")
+            .env("POLYEDGE_LIVE_ARMED", "false")
+            .env("POLYEDGE_CONTROL_PORT", port.to_string())
+            .env("POLYEDGE_DATASET_ROOT", &root)
+            .stdin(Stdio::null())
+            .stdout(Stdio::null())
+            .stderr(Stdio::null());
+        let child = cmd.spawn().context("spawn challenger app_runner")?;
+        let base_url = format!("http://127.0.0.1:{port}");
+        self.wait_control_ready(&base_url).await?;
+        self.apply_params(&candidate, &base_url).await?;
+        let proposal_notes = notes.clone();
+        *guard = Some(ChallengerProcess {
+            layer,
+            started_ms: now,
+            end_ms: now + (shadow_sec as i64) * 1_000,
+            required_cycles,
+            control_base_url: base_url,
+            candidate: candidate.clone(),
+            old_params,
+            baseline: baseline.clone(),
+            proposal_notes,
+            child,
+        });
+        drop(guard);
+        let mut state = self.state.write().await;
+        state.active_shadow_until_ms = now + (shadow_sec as i64) * 1_000;
+        notes.push(format!("duration_sec={shadow_sec}"));
+        notes.push(format!("required_cycles={required_cycles}"));
+        self.record_decision_locked(
+            &mut state,
+            layer,
+            candidate,
+            baseline,
+            "shadow_started".to_string(),
+            false,
+            notes,
+        )?;
+        write_state_atomic(&state)?;
+        Ok(true)
+    }
+
+    async fn poll_challenger(&self, now: i64) -> Result<()> {
+        let mut guard = self.challenger.lock().await;
+        let Some(mut challenger) = guard.take() else {
+            return Ok(());
+        };
+        if now < challenger.end_ms {
+            *guard = Some(challenger);
+            return Ok(());
+        }
+        let compare = self.fetch_shadow_and_pnl_from_base(&challenger.control_base_url).await;
+        let observed_cycles = ((now.saturating_sub(challenger.started_ms)) / (5 * 60 * 1_000)) as u32;
+        let (pass, shadow_notes) = match compare {
+            Ok((live, pnl)) => {
+                let obj = self.build_objective(&live, &pnl);
+                let local_pass = obj.ev_usdc_p50 >= challenger.baseline.ev_usdc_p50 * 1.05
+                    && obj.max_drawdown_pct <= challenger.baseline.max_drawdown_pct * 1.12
+                    && observed_cycles >= challenger.required_cycles;
+                let remote_pass = match self
+                    .http
+                    .post(format!("{}/v1/seat/shadow_compare", self.cfg.optimizer_url))
+                    .json(&serde_json::json!({
+                        "layer": challenger.layer.as_str(),
+                        "ev_new": obj.ev_usdc_p50,
+                        "ev_old": challenger.baseline.ev_usdc_p50,
+                        "dd_new": obj.max_drawdown_pct,
+                        "dd_old": challenger.baseline.max_drawdown_pct,
+                        "cycles_observed": observed_cycles,
+                        "cycles_required": challenger.required_cycles,
+                    }))
+                    .send()
+                    .await
+                {
+                    Ok(resp) => match resp.json::<serde_json::Value>().await {
+                        Ok(body) => body
+                            .get("pass")
+                            .and_then(|x| x.as_bool())
+                            .unwrap_or(local_pass),
+                        Err(_) => local_pass,
+                    },
+                    Err(_) => local_pass,
+                };
+                (
+                    local_pass && remote_pass,
+                    vec![
+                        format!("shadow_ev_usdc_p50={:.6}", obj.ev_usdc_p50),
+                        format!(
+                            "shadow_max_drawdown_pct={:.6}",
+                            obj.max_drawdown_pct
+                        ),
+                    ],
+                )
+            }
+            Err(_) => (false, vec!["shadow_metrics_unavailable=true".to_string()]),
+        };
+        let _ = challenger.child.kill().await;
+        let _ = challenger.child.wait().await;
+        {
+            let mut state = self.state.write().await;
+            state.active_shadow_until_ms = 0;
+            write_state_atomic(&state)?;
+        }
+        if pass {
+            self.begin_smoothing(
+                challenger.layer,
+                challenger.old_params,
+                challenger.candidate,
+                challenger.baseline,
+                now,
+                {
+                    let mut notes = challenger.proposal_notes;
+                    notes.extend(shadow_notes);
+                    notes.extend([
+                    format!("shadow_cycles_observed={observed_cycles}"),
+                    format!("shadow_cycles_required={}", challenger.required_cycles),
+                    ]);
+                    notes
+                },
+            )
+            .await?;
+        } else {
+            let mut state = self.state.write().await;
+            let last_params = state.last_params.clone();
+            self.record_decision_locked(
+                &mut state,
+                challenger.layer,
+                last_params,
+                challenger.baseline,
+                "shadow_reject".to_string(),
+                false,
+                {
+                    let mut notes = vec!["shadow_compare_failed".to_string()];
+                    notes.extend(shadow_notes);
+                    notes.extend([
+                    format!("shadow_cycles_observed={observed_cycles}"),
+                    format!("shadow_cycles_required={}", challenger.required_cycles),
+                    ]);
+                    notes
+                },
+            )?;
+            write_state_atomic(&state)?;
+        }
+        Ok(())
+    }
+
+    async fn fetch_shadow_and_pnl_from_base(&self, base_url: &str) -> Result<(ShadowLiveLite, PnlLite)> {
+        let live = self
+            .http
+            .get(format!("{base_url}/report/shadow/live"))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<ShadowLiveLite>()
+            .await?;
+        let pnl = self
+            .http
+            .get(format!("{base_url}/state/pnl"))
+            .send()
+            .await?
+            .error_for_status()?
+            .json::<PnlLite>()
+            .await?;
+        Ok((live, pnl))
+    }
+
+    fn find_available_port(&self) -> Result<u16> {
+        let listener = std::net::TcpListener::bind("127.0.0.1:0").context("bind ephemeral port")?;
+        let port = listener.local_addr().context("ephemeral addr")?.port();
+        drop(listener);
+        Ok(port)
+    }
+
+    fn build_challenger_dataset_root(&self, now: i64, layer: SeatLayer) -> String {
+        let root = std::env::var("POLYEDGE_DATASET_ROOT")
+            .ok()
+            .filter(|v| !v.trim().is_empty())
+            .unwrap_or_else(|| "datasets".to_string());
+        let path = std::path::PathBuf::from(root)
+            .join("seat_challenger")
+            .join(format!("{}_{}", now, layer.as_str()));
+        let _ = std::fs::create_dir_all(&path);
+        path.to_string_lossy().to_string()
+    }
+
+    async fn wait_control_ready(&self, base_url: &str) -> Result<()> {
+        let health = format!("{base_url}/health");
+        let start = now_ms();
+        while now_ms().saturating_sub(start) < 30_000 {
+            let ok = self
+                .http
+                .get(&health)
+                .send()
+                .await
+                .map(|resp| resp.status().is_success())
+                .unwrap_or(false);
+            if ok {
+                return Ok(());
+            }
+            tokio::time::sleep(Duration::from_millis(500)).await;
+        }
+        Err(anyhow!("challenger control API not ready"))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn test_handle() -> SeatRuntimeHandle {
+        SeatRuntimeHandle {
+            cfg: SeatConfig::default(),
+            http: Client::new(),
+            state: Arc::new(RwLock::new(SeatRuntimeState::default())),
+            live_fill_counter: Arc::new(AtomicU64::new(0)),
+            challenger: Arc::new(Mutex::new(None)),
+        }
+    }
+
+    #[test]
+    fn layer_boundaries_respect_trade_and_uptime() {
+        let handle = test_handle();
+        let mut state = SeatRuntimeState::default();
+        let t0 = state.started_ms + 50 * 3_600 * 1_000;
+        state.live_fill_total = 200;
+        assert_eq!(handle.target_layer(&state, t0), SeatLayer::Layer0);
+        state.live_fill_total = 320;
+        assert_eq!(handle.target_layer(&state, t0), SeatLayer::Layer1);
+        let t1 = state.started_ms + 73 * 3_600 * 1_000;
+        state.live_fill_total = 900;
+        assert_eq!(handle.target_layer(&state, t1), SeatLayer::Layer2);
+        state.live_fill_total = 2_100;
+        assert_eq!(handle.target_layer(&state, t1), SeatLayer::Layer3);
+    }
+
+    #[test]
+    fn smoothing_and_monitor_window_form_ninety_minutes() {
+        let smooth = SeatSmoothingState {
+            layer: SeatLayer::Layer1,
+            old_params: SeatParameterSet::default(),
+            target_params: SeatParameterSet::default(),
+            current_params: SeatParameterSet::default(),
+            baseline: SeatObjectiveSnapshot::default(),
+            started_ms: 0,
+            end_ms: 1_800_000,
+            next_step_ms: 0,
+        };
+        let monitor = SeatMonitorState {
+            layer: SeatLayer::Layer1,
+            old_params: SeatParameterSet::default(),
+            new_params: SeatParameterSet::default(),
+            baseline: SeatObjectiveSnapshot::default(),
+            pre_switch_objective_24h: 0.0,
+            started_ms: smooth.end_ms,
+            end_ms: smooth.end_ms + 3_600_000,
+        };
+        assert_eq!(monitor.end_ms, 5_400_000);
+    }
+
+    #[test]
+    fn downgrade_streak_forces_layer0_lock() {
+        let handle = test_handle();
+        let mut state = SeatRuntimeState::default();
+        state.current_layer = SeatLayer::Layer3;
+        handle
+            .downgrade_locked(&mut state, SeatLayer::Layer3, "first".to_string())
+            .expect("first downgrade");
+        assert_eq!(state.current_layer, SeatLayer::Layer2);
+        handle
+            .downgrade_locked(&mut state, SeatLayer::Layer2, "second".to_string())
+            .expect("second downgrade");
+        assert_eq!(state.current_layer, SeatLayer::Layer0);
+        assert!(state.layer0_lock_until_ms > 0);
+    }
+}
diff --git a/crates/app_runner/src/seat_types.rs b/crates/app_runner/src/seat_types.rs
new file mode 100644
index 0000000..bc89a49
--- /dev/null
+++ b/crates/app_runner/src/seat_types.rs
@@ -0,0 +1,546 @@
+use std::collections::BTreeMap;
+
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[serde(rename_all = "snake_case")]
+pub(crate) enum SeatLayer {
+    Layer0,
+    Layer1,
+    Layer2,
+    Layer3,
+}
+
+impl SeatLayer {
+    pub(crate) fn as_str(self) -> &'static str {
+        match self {
+            Self::Layer0 => "layer0",
+            Self::Layer1 => "layer1",
+            Self::Layer2 => "layer2",
+            Self::Layer3 => "layer3",
+        }
+    }
+
+    pub(crate) fn step_limit_pct(self) -> f64 {
+        match self {
+            Self::Layer0 => 0.03,
+            Self::Layer1 => 0.05,
+            Self::Layer2 | Self::Layer3 => 0.12,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatConfig {
+    pub(crate) enabled: bool,
+    pub(crate) control_base_url: String,
+    pub(crate) optimizer_url: String,
+    pub(crate) runtime_tick_sec: u64,
+    pub(crate) activation_check_sec: u64,
+    pub(crate) layer1_interval_sec: u64,
+    pub(crate) layer2_interval_sec: u64,
+    pub(crate) layer3_interval_sec: u64,
+    pub(crate) layer2_shadow_sec: u64,
+    pub(crate) layer3_shadow_sec: u64,
+    pub(crate) smoothing_sec: u64,
+    pub(crate) monitor_sec: u64,
+    pub(crate) rollback_pause_sec: u64,
+    pub(crate) global_pause_sec: u64,
+    pub(crate) layer0_lock_sec: u64,
+    pub(crate) layer1_min_trades: u64,
+    pub(crate) layer2_min_trades: u64,
+    pub(crate) layer2_min_uptime_sec: u64,
+    pub(crate) layer3_min_trades: u64,
+    pub(crate) layer3_min_uptime_sec: u64,
+    pub(crate) black_swan_lock_sec: u64,
+    pub(crate) source_health_floor: f64,
+    pub(crate) history_retention_days: u32,
+    pub(crate) objective_drawdown_penalty: f64,
+}
+
+impl Default for SeatConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            control_base_url: "http://127.0.0.1:8080".to_string(),
+            optimizer_url: std::env::var("POLYEDGE_SEAT_OPTIMIZER_URL")
+                .unwrap_or_else(|_| "http://127.0.0.1:8091".to_string()),
+            runtime_tick_sec: 60,
+            activation_check_sec: 3_600,
+            layer1_interval_sec: 3_600,
+            layer2_interval_sec: 21_600,
+            layer3_interval_sec: 86_400,
+            layer2_shadow_sec: 2_700,
+            layer3_shadow_sec: 6_000,
+            smoothing_sec: 1_800,
+            monitor_sec: 3_600,
+            rollback_pause_sec: 86_400,
+            global_pause_sec: 172_800,
+            layer0_lock_sec: 172_800,
+            layer1_min_trades: 300,
+            layer2_min_trades: 800,
+            layer2_min_uptime_sec: 72 * 3_600,
+            layer3_min_trades: 2_000,
+            layer3_min_uptime_sec: 14 * 24 * 3_600,
+            black_swan_lock_sec: 172_800,
+            source_health_floor: 0.30,
+            history_retention_days: 180,
+            objective_drawdown_penalty: 5.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]
+pub(crate) struct SeatParameterSet {
+    pub(crate) position_fraction: Option<f64>,
+    pub(crate) early_size_scale: Option<f64>,
+    pub(crate) maturity_size_scale: Option<f64>,
+    pub(crate) late_size_scale: Option<f64>,
+    pub(crate) min_edge_net_bps: Option<f64>,
+    pub(crate) convergence_exit_ratio: Option<f64>,
+    pub(crate) min_velocity_bps_per_sec: Option<f64>,
+    pub(crate) capital_fraction_kelly: Option<f64>,
+    pub(crate) t100ms_reversal_bps: Option<f64>,
+    pub(crate) t300ms_reversal_bps: Option<f64>,
+    pub(crate) max_single_trade_loss_usdc: Option<f64>,
+    pub(crate) risk_max_drawdown_pct: Option<f64>,
+    pub(crate) risk_max_market_notional: Option<f64>,
+    pub(crate) maker_min_edge_bps: Option<f64>,
+    pub(crate) basis_k_revert: Option<f64>,
+    pub(crate) basis_z_cap: Option<f64>,
+}
+
+impl SeatParameterSet {
+    pub(crate) fn is_empty(&self) -> bool {
+        self == &Self::default()
+    }
+
+    pub(crate) fn merge_over(&self, base: &Self) -> Self {
+        let mut out = base.clone();
+        macro_rules! merge_field {
+            ($name:ident) => {
+                if self.$name.is_some() {
+                    out.$name = self.$name;
+                }
+            };
+        }
+        merge_field!(position_fraction);
+        merge_field!(early_size_scale);
+        merge_field!(maturity_size_scale);
+        merge_field!(late_size_scale);
+        merge_field!(min_edge_net_bps);
+        merge_field!(convergence_exit_ratio);
+        merge_field!(min_velocity_bps_per_sec);
+        merge_field!(capital_fraction_kelly);
+        merge_field!(t100ms_reversal_bps);
+        merge_field!(t300ms_reversal_bps);
+        merge_field!(max_single_trade_loss_usdc);
+        merge_field!(risk_max_drawdown_pct);
+        merge_field!(risk_max_market_notional);
+        merge_field!(maker_min_edge_bps);
+        merge_field!(basis_k_revert);
+        merge_field!(basis_z_cap);
+        out
+    }
+
+    pub(crate) fn clamp_relative(&self, current: &Self, max_step_pct: f64) -> Self {
+        fn clamp_opt(candidate: Option<f64>, current: Option<f64>, pct: f64) -> Option<f64> {
+            match (candidate, current) {
+                (Some(next), Some(cur)) if cur.is_finite() && next.is_finite() => {
+                    let step = cur.abs() * pct.max(0.0);
+                    if step > 0.0 {
+                        Some(next.clamp(cur - step, cur + step))
+                    } else {
+                        Some(next)
+                    }
+                }
+                (Some(next), _) => Some(next),
+                (None, cur) => cur,
+            }
+        }
+        Self {
+            position_fraction: clamp_opt(
+                self.position_fraction,
+                current.position_fraction,
+                max_step_pct,
+            ),
+            early_size_scale: clamp_opt(
+                self.early_size_scale,
+                current.early_size_scale,
+                max_step_pct,
+            ),
+            maturity_size_scale: clamp_opt(
+                self.maturity_size_scale,
+                current.maturity_size_scale,
+                max_step_pct,
+            ),
+            late_size_scale: clamp_opt(
+                self.late_size_scale,
+                current.late_size_scale,
+                max_step_pct,
+            ),
+            min_edge_net_bps: clamp_opt(
+                self.min_edge_net_bps,
+                current.min_edge_net_bps,
+                max_step_pct,
+            ),
+            convergence_exit_ratio: clamp_opt(
+                self.convergence_exit_ratio,
+                current.convergence_exit_ratio,
+                max_step_pct,
+            ),
+            min_velocity_bps_per_sec: clamp_opt(
+                self.min_velocity_bps_per_sec,
+                current.min_velocity_bps_per_sec,
+                max_step_pct,
+            ),
+            capital_fraction_kelly: clamp_opt(
+                self.capital_fraction_kelly,
+                current.capital_fraction_kelly,
+                max_step_pct,
+            ),
+            t100ms_reversal_bps: clamp_opt(
+                self.t100ms_reversal_bps,
+                current.t100ms_reversal_bps,
+                max_step_pct,
+            ),
+            t300ms_reversal_bps: clamp_opt(
+                self.t300ms_reversal_bps,
+                current.t300ms_reversal_bps,
+                max_step_pct,
+            ),
+            max_single_trade_loss_usdc: clamp_opt(
+                self.max_single_trade_loss_usdc,
+                current.max_single_trade_loss_usdc,
+                max_step_pct,
+            ),
+            risk_max_drawdown_pct: clamp_opt(
+                self.risk_max_drawdown_pct,
+                current.risk_max_drawdown_pct,
+                max_step_pct,
+            ),
+            risk_max_market_notional: clamp_opt(
+                self.risk_max_market_notional,
+                current.risk_max_market_notional,
+                max_step_pct,
+            ),
+            maker_min_edge_bps: clamp_opt(
+                self.maker_min_edge_bps,
+                current.maker_min_edge_bps,
+                max_step_pct,
+            ),
+            basis_k_revert: clamp_opt(self.basis_k_revert, current.basis_k_revert, max_step_pct),
+            basis_z_cap: clamp_opt(self.basis_z_cap, current.basis_z_cap, max_step_pct),
+        }
+    }
+
+    pub(crate) fn exp_blend_towards(&mut self, target: &Self, alpha: f64) {
+        fn blend(cur: Option<f64>, target: Option<f64>, alpha: f64) -> Option<f64> {
+            match (cur, target) {
+                (Some(c), Some(t)) => Some(c + (t - c) * alpha),
+                (None, Some(t)) => Some(t),
+                (Some(c), None) => Some(c),
+                (None, None) => None,
+            }
+        }
+        self.position_fraction = blend(self.position_fraction, target.position_fraction, alpha);
+        self.early_size_scale = blend(self.early_size_scale, target.early_size_scale, alpha);
+        self.maturity_size_scale =
+            blend(self.maturity_size_scale, target.maturity_size_scale, alpha);
+        self.late_size_scale = blend(self.late_size_scale, target.late_size_scale, alpha);
+        self.min_edge_net_bps = blend(self.min_edge_net_bps, target.min_edge_net_bps, alpha);
+        self.convergence_exit_ratio = blend(
+            self.convergence_exit_ratio,
+            target.convergence_exit_ratio,
+            alpha,
+        );
+        self.min_velocity_bps_per_sec = blend(
+            self.min_velocity_bps_per_sec,
+            target.min_velocity_bps_per_sec,
+            alpha,
+        );
+        self.capital_fraction_kelly = blend(
+            self.capital_fraction_kelly,
+            target.capital_fraction_kelly,
+            alpha,
+        );
+        self.t100ms_reversal_bps =
+            blend(self.t100ms_reversal_bps, target.t100ms_reversal_bps, alpha);
+        self.t300ms_reversal_bps =
+            blend(self.t300ms_reversal_bps, target.t300ms_reversal_bps, alpha);
+        self.max_single_trade_loss_usdc = blend(
+            self.max_single_trade_loss_usdc,
+            target.max_single_trade_loss_usdc,
+            alpha,
+        );
+        self.risk_max_drawdown_pct = blend(
+            self.risk_max_drawdown_pct,
+            target.risk_max_drawdown_pct,
+            alpha,
+        );
+        self.risk_max_market_notional = blend(
+            self.risk_max_market_notional,
+            target.risk_max_market_notional,
+            alpha,
+        );
+        self.maker_min_edge_bps = blend(self.maker_min_edge_bps, target.maker_min_edge_bps, alpha);
+        self.basis_k_revert = blend(self.basis_k_revert, target.basis_k_revert, alpha);
+        self.basis_z_cap = blend(self.basis_z_cap, target.basis_z_cap, alpha);
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatObjectiveSnapshot {
+    pub(crate) ev_usdc_p50: f64,
+    pub(crate) max_drawdown_pct: f64,
+    pub(crate) roi_notional_10s_bps_p50: f64,
+    pub(crate) win_rate: f64,
+    pub(crate) source_health_min: f64,
+    pub(crate) volatility_proxy: f64,
+    pub(crate) objective: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatObjectivePoint {
+    pub(crate) ts_ms: i64,
+    pub(crate) objective: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatSmoothingState {
+    pub(crate) layer: SeatLayer,
+    pub(crate) old_params: SeatParameterSet,
+    pub(crate) target_params: SeatParameterSet,
+    pub(crate) current_params: SeatParameterSet,
+    pub(crate) baseline: SeatObjectiveSnapshot,
+    pub(crate) started_ms: i64,
+    pub(crate) end_ms: i64,
+    pub(crate) next_step_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatMonitorState {
+    pub(crate) layer: SeatLayer,
+    pub(crate) old_params: SeatParameterSet,
+    pub(crate) new_params: SeatParameterSet,
+    pub(crate) baseline: SeatObjectiveSnapshot,
+    pub(crate) pre_switch_objective_24h: f64,
+    pub(crate) started_ms: i64,
+    pub(crate) end_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatStyleVector {
+    pub(crate) volatility_proxy: f64,
+    pub(crate) source_health_min: f64,
+    pub(crate) roi_notional_10s_bps_p50: f64,
+    pub(crate) win_rate: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatStyleMemoryEntry {
+    pub(crate) style_id: String,
+    pub(crate) vector: SeatStyleVector,
+    pub(crate) params: SeatParameterSet,
+    pub(crate) objective: f64,
+    pub(crate) updated_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatRuntimeState {
+    pub(crate) version: u32,
+    pub(crate) started_ms: i64,
+    pub(crate) current_layer: SeatLayer,
+    pub(crate) forced_layer: Option<SeatLayer>,
+    pub(crate) paused: bool,
+    pub(crate) pause_reason: Option<String>,
+    pub(crate) global_pause_until_ms: i64,
+    pub(crate) layer0_lock_until_ms: i64,
+    pub(crate) layer_pause_until_ms: BTreeMap<String, i64>,
+    pub(crate) active_shadow_until_ms: i64,
+    pub(crate) smoothing: Option<SeatSmoothingState>,
+    pub(crate) monitor: Option<SeatMonitorState>,
+    pub(crate) manual_override: Option<SeatParameterSet>,
+    pub(crate) last_tune_ms_by_layer: BTreeMap<String, i64>,
+    pub(crate) last_activation_check_ms: i64,
+    pub(crate) last_decision_ts_ms: i64,
+    pub(crate) decision_seq: u64,
+    pub(crate) degrade_streak: u32,
+    pub(crate) rollback_streak: u32,
+    pub(crate) live_fill_total: u64,
+    pub(crate) live_fill_seen: u64,
+    pub(crate) proxy_trade_total: u64,
+    pub(crate) proxy_trade_seen: u64,
+    pub(crate) trade_count_source: String,
+    pub(crate) objective_history: Vec<SeatObjectivePoint>,
+    pub(crate) volatility_history: Vec<SeatObjectivePoint>,
+    pub(crate) last_objective: Option<SeatObjectiveSnapshot>,
+    pub(crate) pre_switch_objective_24h: Option<f64>,
+    pub(crate) post_switch_eval_due_ms: i64,
+    pub(crate) post_switch_start_ms: i64,
+    pub(crate) post_switch_baseline_24h: Option<f64>,
+    pub(crate) post_switch_layer: Option<SeatLayer>,
+    pub(crate) last_params: SeatParameterSet,
+    pub(crate) style_memory: Vec<SeatStyleMemoryEntry>,
+    pub(crate) last_archive_ts_ms: i64,
+}
+
+impl Default for SeatRuntimeState {
+    fn default() -> Self {
+        Self {
+            version: 1,
+            started_ms: chrono::Utc::now().timestamp_millis(),
+            current_layer: SeatLayer::Layer0,
+            forced_layer: None,
+            paused: false,
+            pause_reason: None,
+            global_pause_until_ms: 0,
+            layer0_lock_until_ms: 0,
+            layer_pause_until_ms: BTreeMap::new(),
+            active_shadow_until_ms: 0,
+            smoothing: None,
+            monitor: None,
+            manual_override: None,
+            last_tune_ms_by_layer: BTreeMap::new(),
+            last_activation_check_ms: 0,
+            last_decision_ts_ms: 0,
+            decision_seq: 0,
+            degrade_streak: 0,
+            rollback_streak: 0,
+            live_fill_total: 0,
+            live_fill_seen: 0,
+            proxy_trade_total: 0,
+            proxy_trade_seen: 0,
+            trade_count_source: "proxy".to_string(),
+            objective_history: Vec::new(),
+            volatility_history: Vec::new(),
+            last_objective: None,
+            pre_switch_objective_24h: None,
+            post_switch_eval_due_ms: 0,
+            post_switch_start_ms: 0,
+            post_switch_baseline_24h: None,
+            post_switch_layer: None,
+            last_params: SeatParameterSet::default(),
+            style_memory: Vec::new(),
+            last_archive_ts_ms: 0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatValidationResult {
+    pub(crate) mc_runs: u32,
+    pub(crate) mc_pass: bool,
+    pub(crate) walk_forward_pass: bool,
+    pub(crate) shadow_pass: bool,
+    #[serde(default)]
+    pub(crate) walk_forward_windows: u32,
+    #[serde(default)]
+    pub(crate) walk_forward_score: f64,
+    #[serde(default)]
+    pub(crate) mc_ev_delta_p50: f64,
+    #[serde(default)]
+    pub(crate) mc_drawdown_p95: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatOptimizerMeta {
+    #[serde(default)]
+    pub(crate) style_match_score: f64,
+    #[serde(default)]
+    pub(crate) style_match_count: u32,
+    #[serde(default)]
+    pub(crate) top_k_size: u32,
+    #[serde(default)]
+    pub(crate) objective_uplift_estimate: f64,
+    #[serde(default)]
+    pub(crate) rl_signal: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatOptimizerProposal {
+    pub(crate) layer: String,
+    pub(crate) candidate: SeatParameterSet,
+    pub(crate) validation: SeatValidationResult,
+    #[serde(default)]
+    pub(crate) meta: SeatOptimizerMeta,
+    pub(crate) notes: Vec<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatLockState {
+    pub(crate) paused: bool,
+    pub(crate) global_pause_until_ms: i64,
+    pub(crate) layer0_lock_until_ms: i64,
+    pub(crate) active_shadow_until_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatDecisionRecord {
+    pub(crate) ts_ms: i64,
+    pub(crate) layer: SeatLayer,
+    #[serde(default)]
+    pub(crate) previous: SeatParameterSet,
+    pub(crate) candidate: SeatParameterSet,
+    pub(crate) baseline: SeatObjectiveSnapshot,
+    pub(crate) decision: String,
+    pub(crate) rollback: bool,
+    pub(crate) lock_state: SeatLockState,
+    pub(crate) trade_count_source: String,
+    pub(crate) notes: Vec<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatStatusReport {
+    pub(crate) ts_ms: i64,
+    pub(crate) enabled: bool,
+    pub(crate) paused: bool,
+    pub(crate) pause_reason: Option<String>,
+    pub(crate) current_layer: SeatLayer,
+    pub(crate) forced_layer: Option<SeatLayer>,
+    pub(crate) global_pause_until_ms: i64,
+    pub(crate) layer0_lock_until_ms: i64,
+    pub(crate) active_shadow_until_ms: i64,
+    pub(crate) trade_count: u64,
+    pub(crate) trade_count_source: String,
+    pub(crate) started_ms: i64,
+    pub(crate) last_decision_ts_ms: i64,
+    pub(crate) degrade_streak: u32,
+    pub(crate) rollback_streak: u32,
+    pub(crate) smoothing_active: bool,
+    pub(crate) monitor_active: bool,
+    pub(crate) manual_override_active: bool,
+    pub(crate) last_objective: Option<SeatObjectiveSnapshot>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SeatForceLayerReq {
+    pub(crate) layer: Option<SeatLayer>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
+pub(crate) struct SeatManualOverrideReq {
+    pub(crate) params: SeatParameterSet,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn relative_clamp_respects_pct() {
+        let current = SeatParameterSet {
+            position_fraction: Some(0.15),
+            min_edge_net_bps: Some(200.0),
+            ..SeatParameterSet::default()
+        };
+        let candidate = SeatParameterSet {
+            position_fraction: Some(0.20),
+            min_edge_net_bps: Some(260.0),
+            ..SeatParameterSet::default()
+        };
+        let clamped = candidate.clamp_relative(&current, 0.05);
+        assert_eq!(clamped.position_fraction, Some(0.1575));
+        assert_eq!(clamped.min_edge_net_bps, Some(210.0));
+    }
+}
diff --git a/crates/app_runner/src/state.rs b/crates/app_runner/src/state.rs
new file mode 100644
index 0000000..bc2e002
--- /dev/null
+++ b/crates/app_runner/src/state.rs
@@ -0,0 +1,2531 @@
+use std::collections::{HashMap, VecDeque};
+use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
+use std::sync::{Arc, RwLock as StdRwLock};
+use std::time::{Duration, Instant};
+
+use chrono::Utc;
+use core_types::{
+    BookTop, CapitalUpdate, Direction, DirectionSignal, EngineEvent, EnginePnLBreakdown,
+    ExecutionStyle, ProbabilityEstimate, RefTick, Regime, ShadowOutcome, ShadowShot, Signal,
+    SourceHealth, TimeframeClass, ToxicRegime,
+};
+use dashmap::DashMap;
+use direction_detector::{DirectionConfig, DirectionDetector};
+use execution_clob::ClobExecution;
+use exit_manager::{ExitManager, ExitManagerConfig, ExitReason};
+use fair_value::BasisMrConfig;
+use infra_bus::RingBus;
+use paper_executor::ShadowExecutor;
+use portfolio::PortfolioBook;
+use probability_engine::{ProbabilityEngine, ProbabilityEngineConfig};
+use reqwest::Client;
+use risk_engine::{DefaultRiskManager, RiskLimits};
+use serde::{Deserialize, Serialize};
+use settlement_compounder::{CompounderConfig, SettlementCompounder};
+use strategy_maker::MakerConfig;
+use taker_sniper::{TakerSniper, TakerSniperConfig};
+use timeframe_router::{RouterConfig, TimeframeRouter};
+use tokio::sync::RwLock;
+
+use crate::engine_core::{is_gate_block_reason, is_policy_block_reason, is_quote_reject_reason};
+use crate::paper_runtime::PaperRuntimeHandle;
+use crate::gate_eval;
+use crate::report_io::{
+    append_jsonl, build_market_scorecard, dataset_path, fillability_ratio,
+    next_normalized_ingest_seq, survival_ratio,
+};
+use crate::seat_runtime::SeatRuntimeHandle;
+use crate::stats_utils::{
+    freshness_ms, percentile, policy_block_ratio, push_capped, quote_block_ratio, ratio_u64,
+    robust_filter_iqr,
+};
+
+#[derive(Clone)]
+pub(crate) struct AppState {
+    pub(crate) paused: Arc<RwLock<bool>>,
+    pub(crate) bus: RingBus<EngineEvent>,
+    pub(crate) portfolio: Arc<PortfolioBook>,
+    pub(crate) execution: Arc<ClobExecution>,
+    pub(crate) _shadow: Arc<ShadowExecutor>,
+    pub(crate) prometheus: metrics_exporter_prometheus::PrometheusHandle,
+    pub(crate) strategy_cfg: Arc<RwLock<Arc<MakerConfig>>>,
+    pub(crate) fair_value_cfg: Arc<StdRwLock<BasisMrConfig>>,
+    pub(crate) toxicity_cfg: Arc<RwLock<Arc<ToxicityConfig>>>,
+    pub(crate) allocator_cfg: Arc<RwLock<AllocatorConfig>>,
+    pub(crate) risk_limits: Arc<StdRwLock<RiskLimits>>,
+    pub(crate) tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
+    pub(crate) shadow_stats: Arc<ShadowStats>,
+    pub(crate) perf_profile: Arc<RwLock<PerfProfile>>,
+    pub(crate) shared: Arc<EngineShared>,
+    pub(crate) seat: Arc<SeatRuntimeHandle>,
+    pub(crate) paper: Arc<PaperRuntimeHandle>,
+}
+
+#[derive(Debug, Clone)]
+pub(crate) enum StrategyIngress {
+    RefTick(RefTick),
+    BookTop(BookTop),
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct StrategyIngressMsg {
+    pub(crate) enqueued_ns: i64,
+    pub(crate) payload: StrategyIngress,
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct FeeRateEntry {
+    pub(crate) fee_bps: f64,
+    pub(crate) fetched_at: Instant,
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct ScoringState {
+    pub(crate) rebate_bps_est: f64,
+    pub(crate) fetched_at: Instant,
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct SignalCacheEntry {
+    pub(crate) signal: Signal,
+    pub(crate) ts_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "snake_case")]
+#[derive(Default)]
+pub(crate) enum PredatorCPriority {
+    MakerFirst,
+    #[default]
+    TakerFirst,
+    TakerOnly,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct PredatorCConfig {
+    pub(crate) enabled: bool,
+    pub(crate) priority: PredatorCPriority,
+    pub(crate) direction_detector: DirectionConfig,
+    pub(crate) probability_engine: ProbabilityEngineConfig,
+    pub(crate) taker_sniper: TakerSniperConfig,
+    pub(crate) strategy_d: PredatorDConfig,
+    pub(crate) regime: PredatorRegimeConfig,
+    pub(crate) cross_symbol: PredatorCrossSymbolConfig,
+    pub(crate) router: RouterConfig,
+    pub(crate) compounder: CompounderConfig,
+    #[serde(default)]
+    pub(crate) v52: V52Config,
+}
+
+impl Default for PredatorCConfig {
+    fn default() -> Self {
+        Self {
+            enabled: false,
+            priority: PredatorCPriority::TakerFirst,
+            direction_detector: DirectionConfig::default(),
+            probability_engine: ProbabilityEngineConfig::default(),
+            taker_sniper: TakerSniperConfig::default(),
+            strategy_d: PredatorDConfig::default(),
+            regime: PredatorRegimeConfig::default(),
+            cross_symbol: PredatorCrossSymbolConfig::default(),
+            router: RouterConfig::default(),
+            compounder: CompounderConfig::default(),
+            v52: V52Config::default(),
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct V52Config {
+    pub(crate) time_phase: V52TimePhaseConfig,
+    pub(crate) execution: V52ExecutionConfig,
+    pub(crate) dual_arb: V52DualArbConfig,
+    pub(crate) reversal: V52ReversalConfig,
+}
+
+impl Default for V52Config {
+    fn default() -> Self {
+        Self {
+            time_phase: V52TimePhaseConfig::default(),
+            execution: V52ExecutionConfig::default(),
+            dual_arb: V52DualArbConfig::default(),
+            reversal: V52ReversalConfig::default(),
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct V52TimePhaseConfig {
+    pub(crate) early_min_ratio: f64,
+    pub(crate) late_max_ratio: f64,
+    pub(crate) early_size_scale: f64,
+    pub(crate) maturity_size_scale: f64,
+    pub(crate) late_size_scale: f64,
+    pub(crate) allow_timeframes: Vec<String>,
+}
+
+impl Default for V52TimePhaseConfig {
+    fn default() -> Self {
+        Self {
+            early_min_ratio: 0.55,
+            late_max_ratio: 0.10,
+            early_size_scale: 0.80,
+            maturity_size_scale: 1.00,
+            late_size_scale: 1.25,
+            allow_timeframes: vec!["5m".to_string(), "15m".to_string()],
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct V52ExecutionConfig {
+    pub(crate) late_force_taker_remaining_ms: u64,
+    pub(crate) maker_wait_ms_before_force: u64,
+    pub(crate) apply_force_taker_in_maturity: bool,
+    pub(crate) apply_force_taker_in_late: bool,
+    pub(crate) alpha_window_enabled: bool,
+    pub(crate) alpha_window_move_bps: f64,
+    pub(crate) alpha_window_poll_ms: u64,
+    pub(crate) alpha_window_max_wait_ms: u64,
+    pub(crate) require_compounder_when_live: bool,
+}
+
+impl Default for V52ExecutionConfig {
+    fn default() -> Self {
+        Self {
+            late_force_taker_remaining_ms: 30_000,
+            maker_wait_ms_before_force: 800,
+            apply_force_taker_in_maturity: true,
+            apply_force_taker_in_late: true,
+            alpha_window_enabled: true,
+            alpha_window_move_bps: 3.0,
+            alpha_window_poll_ms: 10,
+            alpha_window_max_wait_ms: 1_000,
+            require_compounder_when_live: true,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct V52DualArbConfig {
+    pub(crate) enabled: bool,
+    pub(crate) safety_margin_bps: f64,
+    pub(crate) threshold: f64,
+    pub(crate) fee_buffer_mode: String,
+}
+
+impl Default for V52DualArbConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            safety_margin_bps: 3.0,
+            threshold: 0.99,
+            fee_buffer_mode: "conservative_taker".to_string(),
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct V52ReversalConfig {
+    pub(crate) same_market_opposite_first: bool,
+}
+
+impl Default for V52ReversalConfig {
+    fn default() -> Self {
+        Self {
+            same_market_opposite_first: true,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct PredatorDConfig {
+    pub(crate) enabled: bool,
+    pub(crate) min_gap_bps: f64,
+    pub(crate) min_edge_net_bps: f64,
+    pub(crate) min_confidence: f64,
+    pub(crate) max_notional_usdc: f64,
+    pub(crate) cooldown_ms_per_market: u64,
+}
+
+impl Default for PredatorDConfig {
+    fn default() -> Self {
+        Self {
+            enabled: false,
+            min_gap_bps: 25.0,
+            min_edge_net_bps: 15.0,
+            min_confidence: 0.65,
+            max_notional_usdc: 25.0,
+            cooldown_ms_per_market: 500,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct PredatorRegimeConfig {
+    pub(crate) enabled: bool,
+    pub(crate) active_min_confidence: f64,
+    pub(crate) active_min_magnitude_pct: f64,
+    pub(crate) defend_tox_score: f64,
+    pub(crate) defend_on_toxic_danger: bool,
+    pub(crate) defend_min_source_health: f64,
+    pub(crate) quiet_min_edge_multiplier: f64,
+    pub(crate) quiet_chunk_scale: f64,
+}
+
+impl Default for PredatorRegimeConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            active_min_confidence: 0.75,
+            active_min_magnitude_pct: 0.10,
+            defend_tox_score: 0.70,
+            defend_on_toxic_danger: true,
+            defend_min_source_health: 0.45,
+            quiet_min_edge_multiplier: 1.25,
+            quiet_chunk_scale: 0.50,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub(crate) struct PredatorCrossSymbolConfig {
+    pub(crate) enabled: bool,
+    pub(crate) leader_symbol: String,
+    pub(crate) follower_symbols: Vec<String>,
+    pub(crate) min_leader_confidence: f64,
+    pub(crate) min_leader_magnitude_pct: f64,
+    pub(crate) follower_stale_confidence_max: f64,
+    pub(crate) max_correlated_positions: usize,
+}
+
+impl Default for PredatorCrossSymbolConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            leader_symbol: "BTCUSDT".to_string(),
+            follower_symbols: vec!["ETHUSDT".to_string(), "SOLUSDT".to_string()],
+            min_leader_confidence: 0.80,
+            min_leader_magnitude_pct: 0.12,
+            follower_stale_confidence_max: 0.65,
+            max_correlated_positions: 2,
+        }
+    }
+}
+
+#[derive(Clone)]
+pub(crate) struct EngineShared {
+    pub(crate) latest_books: Arc<RwLock<HashMap<String, BookTop>>>,
+    pub(crate) latest_signals: Arc<DashMap<String, SignalCacheEntry>>,
+    pub(crate) latest_fast_ticks: Arc<DashMap<String, RefTick>>,
+    pub(crate) latest_anchor_ticks: Arc<DashMap<String, RefTick>>,
+    pub(crate) market_to_symbol: Arc<RwLock<HashMap<String, String>>>,
+    pub(crate) token_to_symbol: Arc<RwLock<HashMap<String, String>>>,
+    pub(crate) market_to_timeframe: Arc<RwLock<HashMap<String, TimeframeClass>>>,
+    pub(crate) symbol_to_markets: Arc<RwLock<HashMap<String, Vec<String>>>>,
+    pub(crate) fee_cache: Arc<RwLock<HashMap<String, FeeRateEntry>>>,
+    pub(crate) fee_refresh_inflight: Arc<RwLock<HashMap<String, Instant>>>,
+    pub(crate) scoring_cache: Arc<RwLock<HashMap<String, ScoringState>>>,
+    pub(crate) http: Client,
+    pub(crate) clob_endpoint: String,
+    pub(crate) strategy_cfg: Arc<RwLock<Arc<MakerConfig>>>,
+    pub(crate) settlement_cfg: Arc<RwLock<SettlementConfig>>,
+    pub(crate) source_health_cfg: Arc<RwLock<SourceHealthConfig>>,
+    pub(crate) source_health_latest: Arc<RwLock<HashMap<String, SourceHealth>>>,
+    pub(crate) settlement_prices: Arc<RwLock<HashMap<String, f64>>>,
+    pub(crate) fusion_cfg: Arc<RwLock<FusionConfig>>,
+    pub(crate) edge_model_cfg: Arc<RwLock<EdgeModelConfig>>,
+    pub(crate) exit_cfg: Arc<RwLock<ExitConfig>>,
+    pub(crate) fair_value_cfg: Arc<StdRwLock<BasisMrConfig>>,
+    pub(crate) toxicity_cfg: Arc<RwLock<Arc<ToxicityConfig>>>,
+    pub(crate) risk_manager: Arc<DefaultRiskManager>,
+    pub(crate) risk_limits: Arc<StdRwLock<RiskLimits>>,
+    pub(crate) universe_symbols: Arc<Vec<String>>,
+    pub(crate) universe_market_types: Arc<Vec<String>>,
+    pub(crate) universe_timeframes: Arc<Vec<String>>,
+    pub(crate) rate_limit_rps: f64,
+    pub(crate) tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
+    pub(crate) shadow_stats: Arc<ShadowStats>,
+    pub(crate) predator_cfg: Arc<RwLock<PredatorCConfig>>,
+    pub(crate) predator_direction_detector: Arc<RwLock<DirectionDetector>>,
+    pub(crate) predator_latest_direction: Arc<RwLock<HashMap<String, DirectionSignal>>>,
+    pub(crate) predator_latest_probability: Arc<RwLock<HashMap<String, ProbabilityEstimate>>>,
+    pub(crate) predator_probability_engine: Arc<RwLock<ProbabilityEngine>>,
+    pub(crate) predator_taker_sniper: Arc<RwLock<TakerSniper>>,
+    pub(crate) predator_d_last_fire_ms: Arc<RwLock<HashMap<String, i64>>>,
+    pub(crate) predator_router: Arc<RwLock<TimeframeRouter>>,
+    pub(crate) predator_compounder: Arc<RwLock<SettlementCompounder>>,
+    pub(crate) predator_exit_manager: Arc<RwLock<ExitManager>>,
+    /// WSS User Channel fill broadcaster ‚Äî None in paper mode
+    pub(crate) wss_fill_tx:
+        Option<Arc<tokio::sync::broadcast::Sender<execution_clob::wss_user_feed::WssFillEvent>>>,
+}
+
+#[derive(Serialize)]
+pub(crate) struct HealthResp {
+    pub(crate) status: &'static str,
+    pub(crate) paused: bool,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct StrategyReloadReq {
+    pub(crate) min_edge_bps: Option<f64>,
+    pub(crate) ttl_ms: Option<u64>,
+    pub(crate) inventory_skew: Option<f64>,
+    pub(crate) base_quote_size: Option<f64>,
+    pub(crate) max_spread: Option<f64>,
+    pub(crate) basis_k_revert: Option<f64>,
+    pub(crate) basis_z_cap: Option<f64>,
+    pub(crate) basis_min_confidence: Option<f64>,
+    pub(crate) taker_trigger_bps: Option<f64>,
+    pub(crate) taker_max_slippage_bps: Option<f64>,
+    pub(crate) stale_tick_filter_ms: Option<f64>,
+    pub(crate) market_tier_profile: Option<String>,
+    pub(crate) capital_fraction_kelly: Option<f64>,
+    pub(crate) variance_penalty_lambda: Option<f64>,
+    pub(crate) min_eval_notional_usdc: Option<f64>,
+    pub(crate) min_expected_edge_usdc: Option<f64>,
+    pub(crate) v52: Option<V52Config>,
+    pub(crate) v52_time_phase: Option<V52TimePhaseConfig>,
+    pub(crate) v52_execution: Option<V52ExecutionConfig>,
+    pub(crate) v52_dual_arb: Option<V52DualArbConfig>,
+    pub(crate) v52_reversal: Option<V52ReversalConfig>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct FusionReloadReq {
+    pub(crate) enable_udp: Option<bool>,
+    pub(crate) mode: Option<String>,
+    pub(crate) udp_port: Option<u16>,
+    pub(crate) dedupe_window_ms: Option<i64>,
+    pub(crate) dedupe_price_bps: Option<f64>,
+    pub(crate) udp_share_cap: Option<f64>,
+    pub(crate) jitter_threshold_ms: Option<f64>,
+    pub(crate) fallback_arm_duration_ms: Option<u64>,
+    pub(crate) fallback_cooldown_sec: Option<u64>,
+    pub(crate) udp_local_only: Option<bool>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct EdgeModelReloadReq {
+    pub(crate) model: Option<String>,
+    pub(crate) gate_mode: Option<String>,
+    pub(crate) version: Option<String>,
+    pub(crate) base_gate_bps: Option<f64>,
+    pub(crate) congestion_penalty_bps: Option<f64>,
+    pub(crate) latency_penalty_bps: Option<f64>,
+    pub(crate) fail_cost_bps: Option<f64>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct ProbabilityReloadReq {
+    pub(crate) momentum_gain: Option<f64>,
+    pub(crate) lag_penalty_per_ms: Option<f64>,
+    pub(crate) confidence_floor: Option<f64>,
+    pub(crate) sigma_annual: Option<f64>,
+    pub(crate) horizon_sec: Option<f64>,
+    pub(crate) drift_annual: Option<f64>,
+    pub(crate) velocity_drift_gain: Option<f64>,
+    pub(crate) acceleration_drift_gain: Option<f64>,
+    pub(crate) fair_blend_weight: Option<f64>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct SourceHealthReloadReq {
+    pub(crate) min_samples: Option<u64>,
+    pub(crate) gap_window_ms: Option<i64>,
+    pub(crate) jitter_limit_ms: Option<f64>,
+    pub(crate) deviation_limit_bps: Option<f64>,
+    pub(crate) freshness_limit_ms: Option<f64>,
+    pub(crate) min_score_for_trading: Option<f64>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct ExitReloadReq {
+    pub(crate) enabled: Option<bool>,
+    pub(crate) t100ms_reversal_bps: Option<f64>,
+    pub(crate) t300ms_reversal_bps: Option<f64>,
+    pub(crate) convergence_exit_ratio: Option<f64>,
+    pub(crate) time_stop_ms: Option<u64>,
+    pub(crate) edge_decay_bps: Option<f64>,
+    pub(crate) adverse_move_bps: Option<f64>,
+    pub(crate) flatten_on_trigger: Option<bool>,
+    pub(crate) t3_take_ratio: Option<f64>,
+    pub(crate) t15_min_unrealized_usdc: Option<f64>,
+    pub(crate) t60_true_prob_floor: Option<f64>,
+    pub(crate) t300_force_exit_ms: Option<u64>,
+    pub(crate) t300_hold_prob_threshold: Option<f64>,
+    pub(crate) t300_hold_time_to_expiry_ms: Option<u64>,
+    pub(crate) max_single_trade_loss_usdc: Option<f64>,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct StrategyReloadResp {
+    pub(crate) maker: MakerConfig,
+    pub(crate) fair_value: BasisMrConfig,
+    pub(crate) v52: V52Config,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct RiskReloadReq {
+    pub(crate) max_market_notional: Option<f64>,
+    pub(crate) max_asset_notional: Option<f64>,
+    pub(crate) max_open_orders: Option<usize>,
+    pub(crate) daily_drawdown_cap_pct: Option<f64>,
+    pub(crate) max_loss_streak: Option<u32>,
+    pub(crate) cooldown_sec: Option<u64>,
+    pub(crate) progressive_enabled: Option<bool>,
+    pub(crate) drawdown_tier1_ratio: Option<f64>,
+    pub(crate) drawdown_tier2_ratio: Option<f64>,
+    pub(crate) tier1_size_scale: Option<f64>,
+    pub(crate) tier2_size_scale: Option<f64>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct TakerReloadReq {
+    pub(crate) trigger_bps: Option<f64>,
+    pub(crate) max_slippage_bps: Option<f64>,
+    pub(crate) stale_tick_filter_ms: Option<f64>,
+    pub(crate) market_tier_profile: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct TakerReloadResp {
+    pub(crate) trigger_bps: f64,
+    pub(crate) max_slippage_bps: f64,
+    pub(crate) stale_tick_filter_ms: f64,
+    pub(crate) market_tier_profile: String,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct AllocatorReloadReq {
+    pub(crate) capital_fraction_kelly: Option<f64>,
+    pub(crate) variance_penalty_lambda: Option<f64>,
+    pub(crate) active_top_n_markets: Option<usize>,
+    pub(crate) taker_weight: Option<f64>,
+    pub(crate) maker_weight: Option<f64>,
+    pub(crate) arb_weight: Option<f64>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct AllocatorConfig {
+    pub(crate) capital_fraction_kelly: f64,
+    pub(crate) variance_penalty_lambda: f64,
+    pub(crate) active_top_n_markets: usize,
+    pub(crate) taker_weight: f64,
+    pub(crate) maker_weight: f64,
+    pub(crate) arb_weight: f64,
+}
+
+impl Default for AllocatorConfig {
+    fn default() -> Self {
+        Self {
+            capital_fraction_kelly: 0.35,
+            variance_penalty_lambda: 0.25,
+            active_top_n_markets: 8,
+            taker_weight: 0.7,
+            maker_weight: 0.2,
+            arb_weight: 0.1,
+        }
+    }
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct AllocatorReloadResp {
+    pub(crate) allocator: AllocatorConfig,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct RiskReloadResp {
+    pub(crate) risk: RiskLimits,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct ToxicityReloadReq {
+    pub(crate) safe_threshold: Option<f64>,
+    pub(crate) caution_threshold: Option<f64>,
+    pub(crate) cooldown_min_sec: Option<u64>,
+    pub(crate) cooldown_max_sec: Option<u64>,
+    pub(crate) min_market_score: Option<f64>,
+    pub(crate) active_top_n_markets: Option<usize>,
+    pub(crate) markout_1s_caution_bps: Option<f64>,
+    pub(crate) markout_5s_caution_bps: Option<f64>,
+    pub(crate) markout_10s_caution_bps: Option<f64>,
+    pub(crate) markout_1s_danger_bps: Option<f64>,
+    pub(crate) markout_5s_danger_bps: Option<f64>,
+    pub(crate) markout_10s_danger_bps: Option<f64>,
+}
+
+#[derive(Debug, Deserialize)]
+pub(crate) struct PerfProfileReloadReq {
+    pub(crate) tail_guard: Option<f64>,
+    pub(crate) io_flush_batch: Option<usize>,
+    pub(crate) io_queue_capacity: Option<usize>,
+    pub(crate) json_mode: Option<String>,
+    pub(crate) io_drop_on_full: Option<bool>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct FusionConfig {
+    pub(crate) enable_udp: bool,
+    pub(crate) mode: String,
+    pub(crate) udp_port: u16,
+    pub(crate) dedupe_window_ms: i64,
+    pub(crate) dedupe_price_bps: f64,
+    pub(crate) udp_share_cap: f64,
+    pub(crate) jitter_threshold_ms: f64,
+    pub(crate) fallback_arm_duration_ms: u64,
+    pub(crate) fallback_cooldown_sec: u64,
+    pub(crate) udp_local_only: bool,
+}
+
+impl Default for FusionConfig {
+    fn default() -> Self {
+        Self {
+            enable_udp: true,
+            mode: "direct_only".to_string(),
+            udp_port: 6666,
+            dedupe_window_ms: 120,
+            dedupe_price_bps: 0.2,
+            udp_share_cap: 0.35,
+            jitter_threshold_ms: 25.0,
+            fallback_arm_duration_ms: 8_000,
+            fallback_cooldown_sec: 300,
+            udp_local_only: true,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct EdgeModelConfig {
+    pub(crate) model: String,
+    pub(crate) gate_mode: String,
+    pub(crate) version: String,
+    pub(crate) base_gate_bps: f64,
+    pub(crate) congestion_penalty_bps: f64,
+    pub(crate) latency_penalty_bps: f64,
+    pub(crate) fail_cost_bps: f64,
+}
+
+impl Default for EdgeModelConfig {
+    fn default() -> Self {
+        Self {
+            model: "ev_net".to_string(),
+            gate_mode: "dynamic".to_string(),
+            version: "v2-ev-net".to_string(),
+            base_gate_bps: 0.0,
+            congestion_penalty_bps: 2.0,
+            latency_penalty_bps: 2.0,
+            fail_cost_bps: 1.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct ExitConfig {
+    pub(crate) enabled: bool,
+    pub(crate) t100ms_reversal_bps: f64,
+    pub(crate) t300ms_reversal_bps: f64,
+    pub(crate) convergence_exit_ratio: f64,
+    pub(crate) time_stop_ms: u64,
+    pub(crate) edge_decay_bps: f64,
+    pub(crate) adverse_move_bps: f64,
+    pub(crate) flatten_on_trigger: bool,
+    pub(crate) t3_take_ratio: f64,
+    pub(crate) t15_min_unrealized_usdc: f64,
+    pub(crate) t60_true_prob_floor: f64,
+    pub(crate) t300_force_exit_ms: u64,
+    pub(crate) t300_hold_prob_threshold: f64,
+    pub(crate) t300_hold_time_to_expiry_ms: u64,
+    pub(crate) max_single_trade_loss_usdc: f64,
+}
+
+impl Default for ExitConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            t100ms_reversal_bps: -3.0,
+            t300ms_reversal_bps: -2.0,
+            convergence_exit_ratio: 0.85,
+            time_stop_ms: 300_000,
+            edge_decay_bps: -2.0,
+            adverse_move_bps: -8.0,
+            flatten_on_trigger: true,
+            t3_take_ratio: 0.60,
+            t15_min_unrealized_usdc: 0.0,
+            t60_true_prob_floor: 0.70,
+            t300_force_exit_ms: 300_000,
+            t300_hold_prob_threshold: 0.95,
+            t300_hold_time_to_expiry_ms: 300_000,
+            max_single_trade_loss_usdc: 1.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SettlementConfig {
+    pub(crate) enabled: bool,
+    pub(crate) endpoint: String,
+    pub(crate) required_for_live: bool,
+    pub(crate) poll_interval_ms: u64,
+    pub(crate) timeout_ms: u64,
+    pub(crate) symbols: Vec<String>,
+}
+
+impl Default for SettlementConfig {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            endpoint: String::new(),
+            required_for_live: true,
+            poll_interval_ms: 1_000,
+            timeout_ms: 800,
+            symbols: vec![
+                "BTCUSDT".to_string(),
+                "ETHUSDT".to_string(),
+                "SOLUSDT".to_string(),
+                "XRPUSDT".to_string(),
+            ],
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize)]
+pub(crate) struct LiveGateStatus {
+    pub(crate) ready: bool,
+    pub(crate) reason: String,
+}
+
+pub(crate) fn settlement_live_gate_status(cfg: &SettlementConfig) -> LiveGateStatus {
+    if !cfg.required_for_live {
+        return LiveGateStatus {
+            ready: true,
+            reason: "settlement_required_for_live_disabled".to_string(),
+        };
+    }
+    if !cfg.enabled {
+        return LiveGateStatus {
+            ready: false,
+            reason: "settlement_feed_disabled".to_string(),
+        };
+    }
+    if cfg.endpoint.trim().is_empty() {
+        return LiveGateStatus {
+            ready: false,
+            reason: "settlement_endpoint_empty".to_string(),
+        };
+    }
+    LiveGateStatus {
+        ready: true,
+        reason: "ok".to_string(),
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct SourceHealthConfig {
+    pub(crate) min_samples: u64,
+    pub(crate) gap_window_ms: i64,
+    pub(crate) jitter_limit_ms: f64,
+    pub(crate) deviation_limit_bps: f64,
+    pub(crate) freshness_limit_ms: f64,
+    pub(crate) min_score_for_trading: f64,
+}
+
+impl Default for SourceHealthConfig {
+    fn default() -> Self {
+        Self {
+            min_samples: 64,
+            gap_window_ms: 2_000,
+            jitter_limit_ms: 12.0,
+            deviation_limit_bps: 30.0,
+            freshness_limit_ms: 2_000.0,
+            min_score_for_trading: 0.45,
+        }
+    }
+}
+
+pub(crate) fn to_exit_manager_config(cfg: &ExitConfig) -> ExitManagerConfig {
+    ExitManagerConfig {
+        t100ms_reversal_bps: cfg.t100ms_reversal_bps,
+        t300ms_reversal_bps: cfg.t300ms_reversal_bps,
+        convergence_exit_ratio: cfg.convergence_exit_ratio.clamp(0.0, 1.0),
+        t3_take_ratio: cfg.t3_take_ratio.clamp(0.0, 5.0),
+        t15_min_unrealized_usdc: cfg.t15_min_unrealized_usdc,
+        t60_true_prob_floor: cfg.t60_true_prob_floor.clamp(0.0, 1.0),
+        t300_force_exit_ms: cfg.t300_force_exit_ms.max(1_000),
+        t300_hold_prob_threshold: cfg.t300_hold_prob_threshold.clamp(0.0, 1.0),
+        t300_hold_time_to_expiry_ms: cfg.t300_hold_time_to_expiry_ms.max(1_000),
+        max_single_trade_loss_usdc: cfg.max_single_trade_loss_usdc.max(0.0),
+    }
+}
+
+pub(crate) fn exit_reason_label(reason: ExitReason) -> &'static str {
+    match reason {
+        ExitReason::StopLoss => "stop_loss",
+        ExitReason::Reversal100ms => "t_plus_100ms_reversal",
+        ExitReason::Reversal300ms => "t_plus_300ms_reversal",
+        // ‰ª∑Ê†ºÊî∂ÊïõÂà∞ÂÖ¨ÂÖÅ‰ª∑ÂÄº 85%+ÔºåÂ•óÂà©Âà©Ê∂¶Â∑≤ÂêÉÊª°
+        ExitReason::ConvergenceExit => "convergence_exit",
+        ExitReason::TakeProfit3s => "t_plus_3s",
+        ExitReason::TakeProfit15s => "t_plus_15s",
+        ExitReason::ProbGuard60s => "t_plus_60s_prob_guard",
+        ExitReason::ForceClose300s => "t_plus_300s_force",
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct ExecutionConfig {
+    pub(crate) mode: String,
+    pub(crate) rate_limit_rps: f64,
+    pub(crate) http_timeout_ms: u64,
+    pub(crate) clob_endpoint: String,
+    #[serde(default)]
+    pub(crate) order_endpoint: Option<String>,
+    #[serde(default)]
+    pub(crate) order_backup_endpoint: Option<String>,
+    #[serde(default)]
+    pub(crate) order_failover_timeout_ms: u64,
+}
+
+impl Default for ExecutionConfig {
+    fn default() -> Self {
+        Self {
+            mode: "paper".to_string(),
+            rate_limit_rps: 15.0,
+            http_timeout_ms: 3000,
+            clob_endpoint: "https://clob.polymarket.com".to_string(),
+            order_endpoint: None,
+            order_backup_endpoint: None,
+            order_failover_timeout_ms: 200,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct PerfProfile {
+    pub(crate) tail_guard: f64,
+    pub(crate) io_flush_batch: usize,
+    pub(crate) io_queue_capacity: usize,
+    pub(crate) json_mode: String,
+    pub(crate) io_drop_on_full: bool,
+}
+
+impl Default for PerfProfile {
+    fn default() -> Self {
+        Self {
+            tail_guard: 0.99,
+            io_flush_batch: 64,
+            io_queue_capacity: 16_384,
+            json_mode: "typed".to_string(),
+            io_drop_on_full: true,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub(crate) struct ToxicityConfig {
+    pub(crate) w1: f64,
+    pub(crate) w2: f64,
+    pub(crate) w3: f64,
+    pub(crate) w4: f64,
+    pub(crate) w5: f64,
+    pub(crate) w6: f64,
+    pub(crate) safe_threshold: f64,
+    pub(crate) caution_threshold: f64,
+    pub(crate) k_spread: f64,
+    pub(crate) cooldown_min_sec: u64,
+    pub(crate) cooldown_max_sec: u64,
+    pub(crate) min_market_score: f64,
+    pub(crate) active_top_n_markets: usize,
+    pub(crate) markout_1s_caution_bps: f64,
+    pub(crate) markout_5s_caution_bps: f64,
+    pub(crate) markout_10s_caution_bps: f64,
+    pub(crate) markout_1s_danger_bps: f64,
+    pub(crate) markout_5s_danger_bps: f64,
+    pub(crate) markout_10s_danger_bps: f64,
+}
+
+impl Default for ToxicityConfig {
+    fn default() -> Self {
+        Self {
+            w1: 0.30,
+            w2: 0.25,
+            w3: 0.20,
+            w4: 0.10,
+            w5: 0.10,
+            w6: 0.05,
+            safe_threshold: 0.35,
+            caution_threshold: 0.65,
+            k_spread: 1.5,
+            cooldown_min_sec: 30,
+            cooldown_max_sec: 120,
+            min_market_score: 70.0,
+            active_top_n_markets: 8,
+            markout_1s_caution_bps: -4.0,
+            markout_5s_caution_bps: -6.0,
+            markout_10s_caution_bps: -8.0,
+            markout_1s_danger_bps: -10.0,
+            markout_5s_danger_bps: -14.0,
+            markout_10s_danger_bps: -18.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct MarketToxicState {
+    pub(crate) symbol: String,
+    pub(crate) markout_1s: VecDeque<f64>,
+    pub(crate) markout_5s: VecDeque<f64>,
+    pub(crate) markout_10s: VecDeque<f64>,
+    pub(crate) attempted: u64,
+    pub(crate) no_quote: u64,
+    pub(crate) symbol_missing: u64,
+    pub(crate) last_tox_score: f64,
+    pub(crate) last_regime: ToxicRegime,
+    pub(crate) market_score: f64,
+    pub(crate) cooldown_until_ms: i64,
+}
+
+impl Default for MarketToxicState {
+    fn default() -> Self {
+        Self {
+            symbol: String::new(),
+            markout_1s: VecDeque::new(),
+            markout_5s: VecDeque::new(),
+            markout_10s: VecDeque::new(),
+            attempted: 0,
+            no_quote: 0,
+            symbol_missing: 0,
+            last_tox_score: 0.0,
+            last_regime: ToxicRegime::Safe,
+            market_score: 80.0,
+            cooldown_until_ms: 0,
+        }
+    }
+}
+
+#[derive(Debug, Serialize, Clone)]
+pub(crate) struct ToxicityMarketRow {
+    pub(crate) market_rank: usize,
+    pub(crate) market_id: String,
+    pub(crate) symbol: String,
+    pub(crate) tox_score: f64,
+    pub(crate) regime: ToxicRegime,
+    pub(crate) market_score: f64,
+    pub(crate) markout_10s_bps: f64,
+    pub(crate) no_quote_rate: f64,
+    pub(crate) symbol_missing_rate: f64,
+    pub(crate) pending_exposure: f64,
+    pub(crate) active_for_quoting: bool,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct ToxicityLiveReport {
+    pub(crate) ts_ms: i64,
+    pub(crate) average_tox_score: f64,
+    pub(crate) safe_count: usize,
+    pub(crate) caution_count: usize,
+    pub(crate) danger_count: usize,
+    pub(crate) rows: Vec<ToxicityMarketRow>,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct ToxicityFinalReport {
+    pub(crate) pass: bool,
+    pub(crate) failed_reasons: Vec<String>,
+    pub(crate) live: ToxicityLiveReport,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct GateEvaluation {
+    pub(crate) window_id: u64,
+    pub(crate) gate_ready: bool,
+    pub(crate) min_outcomes: usize,
+    pub(crate) pass: bool,
+    pub(crate) data_valid_ratio: f64,
+    pub(crate) seq_gap_rate: f64,
+    pub(crate) ts_inversion_rate: f64,
+    pub(crate) stale_tick_drop_ratio: f64,
+    pub(crate) fillability_10ms: f64,
+    pub(crate) net_edge_p50_bps: f64,
+    pub(crate) net_edge_p10_bps: f64,
+    pub(crate) net_markout_10s_usdc_p50: f64,
+    pub(crate) roi_notional_10s_bps_p50: f64,
+    pub(crate) pnl_10s_p50_bps_raw: f64,
+    pub(crate) pnl_10s_p50_bps_robust: f64,
+    pub(crate) pnl_10s_sample_count: usize,
+    pub(crate) pnl_10s_outlier_ratio: f64,
+    pub(crate) eligible_count: u64,
+    pub(crate) executed_count: u64,
+    pub(crate) executed_over_eligible: f64,
+    pub(crate) ev_net_usdc_p50: f64,
+    pub(crate) ev_net_usdc_p10: f64,
+    pub(crate) ev_positive_ratio: f64,
+    pub(crate) quote_block_ratio: f64,
+    pub(crate) policy_block_ratio: f64,
+    pub(crate) gate_blocked: u64,
+    pub(crate) gate_block_ratio: f64,
+    pub(crate) strategy_uptime_pct: f64,
+    pub(crate) tick_to_ack_p99_ms: f64,
+    pub(crate) decision_queue_wait_p99_ms: f64,
+    pub(crate) decision_compute_p99_ms: f64,
+    pub(crate) source_latency_p99_ms: f64,
+    pub(crate) exchange_lag_p99_ms: f64,
+    pub(crate) path_lag_p99_ms: f64,
+    pub(crate) local_backlog_p99_ms: f64,
+    pub(crate) failed_reasons: Vec<String>,
+}
+
+#[derive(Debug, Serialize, Clone, Default)]
+pub(crate) struct LatencyBreakdown {
+    pub(crate) feed_in_p50_ms: f64,
+    pub(crate) feed_in_p90_ms: f64,
+    pub(crate) feed_in_p99_ms: f64,
+    pub(crate) signal_p50_us: f64,
+    pub(crate) signal_p90_us: f64,
+    pub(crate) signal_p99_us: f64,
+    pub(crate) quote_p50_us: f64,
+    pub(crate) quote_p90_us: f64,
+    pub(crate) quote_p99_us: f64,
+    pub(crate) risk_p50_us: f64,
+    pub(crate) risk_p90_us: f64,
+    pub(crate) risk_p99_us: f64,
+    pub(crate) decision_queue_wait_p50_ms: f64,
+    pub(crate) decision_queue_wait_p90_ms: f64,
+    pub(crate) decision_queue_wait_p99_ms: f64,
+    pub(crate) decision_compute_p50_ms: f64,
+    pub(crate) decision_compute_p90_ms: f64,
+    pub(crate) decision_compute_p99_ms: f64,
+    pub(crate) tick_to_decision_p50_ms: f64,
+    pub(crate) tick_to_decision_p90_ms: f64,
+    pub(crate) tick_to_decision_p99_ms: f64,
+    pub(crate) ack_only_p50_ms: f64,
+    pub(crate) ack_only_p90_ms: f64,
+    pub(crate) ack_only_p99_ms: f64,
+    pub(crate) tick_to_ack_p50_ms: f64,
+    pub(crate) tick_to_ack_p90_ms: f64,
+    pub(crate) tick_to_ack_p99_ms: f64,
+    pub(crate) parse_p99_us: f64,
+    pub(crate) io_queue_p99_ms: f64,
+    pub(crate) bus_lag_p99_ms: f64,
+    pub(crate) shadow_fill_p50_ms: f64,
+    pub(crate) shadow_fill_p90_ms: f64,
+    pub(crate) shadow_fill_p99_ms: f64,
+    pub(crate) source_latency_p50_ms: f64,
+    pub(crate) source_latency_p90_ms: f64,
+    pub(crate) source_latency_p99_ms: f64,
+    pub(crate) exchange_lag_p50_ms: f64,
+    pub(crate) exchange_lag_p90_ms: f64,
+    pub(crate) exchange_lag_p99_ms: f64,
+    pub(crate) path_lag_p50_ms: f64,
+    pub(crate) path_lag_p90_ms: f64,
+    pub(crate) path_lag_p99_ms: f64,
+    pub(crate) path_lag_coverage_ratio: f64,
+    pub(crate) book_latency_p50_ms: f64,
+    pub(crate) book_latency_p90_ms: f64,
+    pub(crate) book_latency_p99_ms: f64,
+    pub(crate) local_backlog_p50_ms: f64,
+    pub(crate) local_backlog_p90_ms: f64,
+    pub(crate) local_backlog_p99_ms: f64,
+    pub(crate) ref_decode_p50_ms: f64,
+    pub(crate) ref_decode_p90_ms: f64,
+    pub(crate) ref_decode_p99_ms: f64,
+    /// `book_top_lag_ms` distribution *for the same primary-delay executed shots* that have a
+    /// measured `ack_only_ms` (i.e. same sample set as capturable_window).
+    pub(crate) book_top_lag_at_ack_p50_ms: f64,
+    pub(crate) book_top_lag_at_ack_p90_ms: f64,
+    pub(crate) book_top_lag_at_ack_p99_ms: f64,
+    pub(crate) book_top_lag_at_ack_n: u64,
+    pub(crate) capturable_window_p50_ms: f64,
+    pub(crate) capturable_window_p75_ms: f64,
+    pub(crate) capturable_window_p90_ms: f64,
+    pub(crate) capturable_window_p99_ms: f64,
+    pub(crate) alpha_window_p50_ms: f64,
+    pub(crate) alpha_window_p90_ms: f64,
+    pub(crate) alpha_window_p99_ms: f64,
+    pub(crate) alpha_window_hit_ratio: f64,
+    pub(crate) alpha_window_n: u64,
+    /// Ratio of samples where capturable_window_ms > 0.0.
+    pub(crate) profitable_window_ratio: f64,
+    /// Number of capturable window samples included in the distribution.
+    pub(crate) capturable_window_n: u64,
+    /// Number of ack_only_ms samples (only meaningful in live execution).
+    pub(crate) ack_only_n: u64,
+    /// Number of tick_to_ack_ms samples.
+    pub(crate) tick_to_ack_n: u64,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct ShadowLiveReport {
+    pub(crate) window_id: u64,
+    pub(crate) window_shots: usize,
+    pub(crate) window_outcomes: usize,
+    // Backward-compatible strict gate bit used by existing risk/optimizer scripts.
+    pub(crate) gate_ready: bool,
+    // Explicit strict/effective split to avoid semantic ambiguity in external audits.
+    pub(crate) gate_ready_strict: bool,
+    pub(crate) gate_ready_effective: bool,
+    pub(crate) gate_fail_reasons: Vec<String>,
+    pub(crate) observe_only: bool,
+    pub(crate) started_at_ms: i64,
+    pub(crate) elapsed_sec: u64,
+    pub(crate) total_shots: usize,
+    pub(crate) total_outcomes: usize,
+    pub(crate) data_valid_ratio: f64,
+    pub(crate) seq_gap_rate: f64,
+    pub(crate) ts_inversion_rate: f64,
+    pub(crate) stale_tick_drop_ratio: f64,
+    pub(crate) quote_attempted: u64,
+    pub(crate) quote_blocked: u64,
+    pub(crate) policy_blocked: u64,
+    pub(crate) fillability_5ms: f64,
+    pub(crate) fillability_10ms: f64,
+    pub(crate) fillability_25ms: f64,
+    pub(crate) survival_5ms: f64,
+    pub(crate) survival_10ms: f64,
+    pub(crate) survival_25ms: f64,
+    // Survival probe is an "orderless" latency-arb competitiveness metric:
+    // at T0 we observe a crossable top-of-book price, then check at +Œî whether
+    // it is still crossable. This intentionally does not depend on order acks.
+    pub(crate) survival_probe_5ms: f64,
+    pub(crate) survival_probe_10ms: f64,
+    pub(crate) survival_probe_25ms: f64,
+    pub(crate) survival_probe_5ms_n: u64,
+    pub(crate) survival_probe_10ms_n: u64,
+    pub(crate) survival_probe_25ms_n: u64,
+    pub(crate) net_edge_p50_bps: f64,
+    pub(crate) net_edge_p10_bps: f64,
+    pub(crate) pnl_1s_p50_bps: f64,
+    pub(crate) pnl_5s_p50_bps: f64,
+    pub(crate) pnl_10s_p50_bps: f64,
+    pub(crate) pnl_10s_p50_bps_raw: f64,
+    pub(crate) pnl_10s_p50_bps_robust: f64,
+    pub(crate) net_markout_10s_usdc_p50: f64,
+    pub(crate) roi_notional_10s_bps_p50: f64,
+    pub(crate) pnl_10s_sample_count: usize,
+    pub(crate) pnl_10s_outlier_ratio: f64,
+    pub(crate) eligible_count: u64,
+    pub(crate) executed_count: u64,
+    pub(crate) executed_over_eligible: f64,
+    pub(crate) ev_net_usdc_p50: f64,
+    pub(crate) ev_net_usdc_p10: f64,
+    pub(crate) ev_positive_ratio: f64,
+    pub(crate) quote_block_ratio: f64,
+    pub(crate) policy_block_ratio: f64,
+    pub(crate) gate_blocked: u64,
+    pub(crate) gate_block_ratio: f64,
+    pub(crate) queue_depth_p99: f64,
+    pub(crate) event_backlog_p99: f64,
+    pub(crate) tick_to_decision_p50_ms: f64,
+    pub(crate) tick_to_decision_p90_ms: f64,
+    pub(crate) tick_to_decision_p99_ms: f64,
+    pub(crate) decision_queue_wait_p99_ms: f64,
+    pub(crate) decision_compute_p99_ms: f64,
+    pub(crate) source_latency_p99_ms: f64,
+    pub(crate) exchange_lag_p99_ms: f64,
+    pub(crate) path_lag_p99_ms: f64,
+    pub(crate) local_backlog_p99_ms: f64,
+    pub(crate) lag_half_life_ms: f64,
+    pub(crate) probability_total: u64,
+    pub(crate) settlement_source_degraded_ratio: f64,
+    pub(crate) settle_fast_delta_p50_bps: f64,
+    pub(crate) settle_fast_delta_p90_bps: f64,
+    pub(crate) probability_confidence_p50: f64,
+    pub(crate) ack_only_p50_ms: f64,
+    pub(crate) ack_only_p90_ms: f64,
+    pub(crate) ack_only_p99_ms: f64,
+    pub(crate) alpha_window_p50_ms: f64,
+    pub(crate) alpha_window_p90_ms: f64,
+    pub(crate) alpha_window_p99_ms: f64,
+    pub(crate) alpha_window_hit_ratio: f64,
+    pub(crate) alpha_window_n: u64,
+    pub(crate) strategy_uptime_pct: f64,
+    pub(crate) tick_to_ack_p99_ms: f64,
+    pub(crate) ref_ticks_total: u64,
+    pub(crate) book_ticks_total: u64,
+    pub(crate) ref_freshness_ms: i64,
+    pub(crate) book_freshness_ms: i64,
+    pub(crate) book_top_lag_p50_ms: f64,
+    pub(crate) book_top_lag_p90_ms: f64,
+    pub(crate) book_top_lag_p99_ms: f64,
+    pub(crate) book_top_lag_by_symbol_p50_ms: HashMap<String, f64>,
+    pub(crate) survival_10ms_by_symbol: HashMap<String, f64>,
+    pub(crate) survival_probe_10ms_by_symbol: HashMap<String, f64>,
+    pub(crate) blocked_reason_counts: HashMap<String, u64>,
+    pub(crate) policy_block_reason_distribution: HashMap<String, u64>,
+    pub(crate) gate_block_reason_distribution: HashMap<String, u64>,
+    pub(crate) source_mix_ratio: HashMap<String, f64>,
+    pub(crate) udp_share_effective: f64,
+    pub(crate) udp_local_drop_count: u64,
+    pub(crate) share_cap_drop_count: u64,
+    pub(crate) fallback_state: String,
+    pub(crate) fallback_trigger_reason_distribution: HashMap<String, u64>,
+    pub(crate) source_health: Vec<SourceHealth>,
+    pub(crate) exit_reason_top: Vec<(String, u64)>,
+    pub(crate) edge_model_version: String,
+    pub(crate) latency: LatencyBreakdown,
+    pub(crate) market_scorecard: Vec<MarketScoreRow>,
+    pub(crate) predator_c_enabled: bool,
+    pub(crate) direction_signals_up: u64,
+    pub(crate) direction_signals_down: u64,
+    pub(crate) direction_signals_neutral: u64,
+    pub(crate) taker_sniper_fired: u64,
+    pub(crate) taker_sniper_skipped: u64,
+    pub(crate) predator_regime_active: u64,
+    pub(crate) predator_regime_quiet: u64,
+    pub(crate) predator_regime_defend: u64,
+    pub(crate) predator_cross_symbol_fired: u64,
+    pub(crate) taker_sniper_skip_reasons_top: Vec<(String, u64)>,
+    pub(crate) last_30s_taker_fallback_count: u64,
+    pub(crate) router_locked_by_tf_usdc: HashMap<String, f64>,
+    pub(crate) capital_available_usdc: f64,
+    pub(crate) capital_base_quote_size: f64,
+    pub(crate) capital_halt: bool,
+}
+
+#[derive(Debug, Serialize)]
+pub(crate) struct ShadowFinalReport {
+    pub(crate) live: ShadowLiveReport,
+    pub(crate) gate: GateEvaluation,
+}
+
+#[derive(Debug, Serialize, Clone)]
+pub(crate) struct EnginePnlRow {
+    pub(crate) engine: String,
+    pub(crate) samples: usize,
+    pub(crate) total_usdc: f64,
+    pub(crate) p50_usdc: f64,
+    pub(crate) p10_usdc: f64,
+    pub(crate) positive_ratio: f64,
+}
+
+#[derive(Debug, Serialize, Clone)]
+pub(crate) struct EnginePnlReport {
+    pub(crate) window_id: u64,
+    pub(crate) breakdown: EnginePnLBreakdown,
+    pub(crate) rows: Vec<EnginePnlRow>,
+}
+
+#[derive(Debug, Serialize, Clone)]
+pub(crate) struct MarketScoreRow {
+    pub(crate) market_id: String,
+    pub(crate) symbol: String,
+    pub(crate) shots: usize,
+    pub(crate) outcomes: usize,
+    pub(crate) fillability_10ms: f64,
+    pub(crate) net_edge_p50_bps: f64,
+    pub(crate) net_edge_p10_bps: f64,
+    pub(crate) pnl_10s_p50_bps: f64,
+    pub(crate) net_markout_10s_usdc_p50: f64,
+    pub(crate) roi_notional_10s_bps_p50: f64,
+}
+
+#[derive(Debug, Clone, Copy, Default)]
+pub(crate) struct SurvivalProbeCounters {
+    pub(crate) n_5: u64,
+    pub(crate) s_5: u64,
+    pub(crate) n_10: u64,
+    pub(crate) s_10: u64,
+    pub(crate) n_25: u64,
+    pub(crate) s_25: u64,
+}
+
+impl SurvivalProbeCounters {
+    pub(crate) fn record(&mut self, delay_ms: u64, survived: bool) {
+        let (n, s) = match delay_ms {
+            5 => (&mut self.n_5, &mut self.s_5),
+            10 => (&mut self.n_10, &mut self.s_10),
+            25 => (&mut self.n_25, &mut self.s_25),
+            _ => return,
+        };
+        *n = n.saturating_add(1);
+        if survived {
+            *s = s.saturating_add(1);
+        }
+    }
+
+    pub(crate) fn ratio(&self, delay_ms: u64) -> f64 {
+        let (n, s) = match delay_ms {
+            5 => (self.n_5, self.s_5),
+            10 => (self.n_10, self.s_10),
+            25 => (self.n_25, self.s_25),
+            _ => (0, 0),
+        };
+        if n == 0 {
+            0.0
+        } else {
+            s as f64 / n as f64
+        }
+    }
+
+    pub(crate) fn n(&self, delay_ms: u64) -> u64 {
+        match delay_ms {
+            5 => self.n_5,
+            10 => self.n_10,
+            25 => self.n_25,
+            _ => 0,
+        }
+    }
+}
+
+pub(crate) struct ShadowStats {
+    pub(crate) window_id: AtomicU64,
+    pub(crate) started_at: RwLock<Instant>,
+    pub(crate) started_at_ms: AtomicI64,
+    pub(crate) quote_attempted: AtomicU64,
+    pub(crate) quote_blocked: AtomicU64,
+    pub(crate) policy_blocked: AtomicU64,
+    pub(crate) seen_count: AtomicU64,
+    pub(crate) candidate_count: AtomicU64,
+    pub(crate) quoted_count: AtomicU64,
+    pub(crate) eligible_count: AtomicU64,
+    pub(crate) executed_count: AtomicU64,
+    pub(crate) filled_count: AtomicU64,
+    pub(crate) blocked_reasons: RwLock<HashMap<String, u64>>,
+    pub(crate) exit_reasons: RwLock<HashMap<String, u64>>,
+    pub(crate) ref_ticks_total: AtomicU64,
+    pub(crate) book_ticks_total: AtomicU64,
+    pub(crate) ref_source_counts: DashMap<String, u64>,
+    pub(crate) ref_dedupe_dropped: AtomicU64,
+    pub(crate) share_cap_drop_count: AtomicU64,
+    pub(crate) udp_local_drop_count_baseline: AtomicU64,
+    pub(crate) fallback_state_code: AtomicU64,
+    pub(crate) fallback_trigger_reasons: RwLock<HashMap<String, u64>>,
+    pub(crate) last_ref_tick_ms: AtomicI64,
+    pub(crate) last_book_tick_ms: AtomicI64,
+    pub(crate) shots: RwLock<Vec<ShadowShot>>,
+    pub(crate) outcomes: RwLock<Vec<ShadowOutcome>>,
+    pub(crate) samples: RwLock<ShadowSamples>,
+    pub(crate) book_top_lag_by_symbol_ms: RwLock<HashMap<String, Vec<f64>>>,
+    pub(crate) survival_probe_overall: RwLock<SurvivalProbeCounters>,
+    pub(crate) survival_probe_by_symbol: RwLock<HashMap<String, SurvivalProbeCounters>>,
+    pub(crate) data_total: AtomicU64,
+    pub(crate) data_invalid: AtomicU64,
+    pub(crate) seq_gap: AtomicU64,
+    pub(crate) ts_inversion: AtomicU64,
+    pub(crate) stale_tick_dropped: AtomicU64,
+    pub(crate) loss_streak: AtomicU64,
+    pub(crate) observe_only: AtomicBool,
+    pub(crate) paused: AtomicBool,
+    pub(crate) paused_since_ms: AtomicU64,
+    pub(crate) paused_total_ms: AtomicU64,
+    pub(crate) predator_c_enabled: AtomicBool,
+    pub(crate) predator_dir_up: AtomicU64,
+    pub(crate) predator_dir_down: AtomicU64,
+    pub(crate) predator_dir_neutral: AtomicU64,
+    pub(crate) predator_taker_fired: AtomicU64,
+    pub(crate) predator_taker_skipped: AtomicU64,
+    pub(crate) predator_regime_active: AtomicU64,
+    pub(crate) predator_regime_quiet: AtomicU64,
+    pub(crate) predator_regime_defend: AtomicU64,
+    pub(crate) predator_cross_symbol_fired: AtomicU64,
+    pub(crate) predator_last_30s_taker_fallback_count: AtomicU64,
+    pub(crate) predator_taker_skip_reasons: RwLock<HashMap<String, u64>>,
+    pub(crate) predator_router_locked_by_tf_usdc: RwLock<HashMap<String, f64>>,
+    pub(crate) predator_capital: RwLock<CapitalUpdate>,
+    pub(crate) predator_capital_halt: AtomicBool,
+    pub(crate) probability_total: AtomicU64,
+    pub(crate) probability_degraded: AtomicU64,
+}
+
+#[derive(Debug, Clone, Default)]
+pub(crate) struct ShadowSamples {
+    pub(crate) decision_queue_wait_ms: Vec<f64>,
+    pub(crate) decision_compute_ms: Vec<f64>,
+    pub(crate) tick_to_decision_ms: Vec<f64>,
+    pub(crate) ack_only_ms: Vec<f64>,
+    pub(crate) tick_to_ack_ms: Vec<f64>,
+    pub(crate) capturable_window_ms: Vec<f64>,
+    pub(crate) alpha_window_ms: Vec<f64>,
+    pub(crate) alpha_window_hit: Vec<f64>,
+    pub(crate) feed_in_ms: Vec<f64>,
+    pub(crate) source_latency_ms: Vec<f64>,
+    pub(crate) exchange_lag_ms: Vec<f64>,
+    pub(crate) path_lag_ms: Vec<f64>,
+    pub(crate) book_latency_ms: Vec<f64>,
+    pub(crate) local_backlog_ms: Vec<f64>,
+    pub(crate) ref_decode_ms: Vec<f64>,
+    pub(crate) book_top_lag_ms: Vec<f64>,
+    pub(crate) signal_us: Vec<f64>,
+    pub(crate) quote_us: Vec<f64>,
+    pub(crate) risk_us: Vec<f64>,
+    pub(crate) shadow_fill_ms: Vec<f64>,
+    pub(crate) queue_depth: Vec<f64>,
+    pub(crate) event_backlog: Vec<f64>,
+    pub(crate) parse_us: Vec<f64>,
+    pub(crate) io_queue_depth: Vec<f64>,
+    pub(crate) settle_fast_delta_bps: Vec<f64>,
+    pub(crate) probability_confidence: Vec<f64>,
+}
+
+impl ShadowStats {
+    const SHADOW_CAP: usize = 200_000;
+    const SAMPLE_CAP: usize = 65_536;
+    pub(crate) const GATE_MIN_OUTCOMES: usize = 30;
+
+    pub(crate) fn new() -> Self {
+        Self {
+            window_id: AtomicU64::new(0),
+            started_at: RwLock::new(Instant::now()),
+            started_at_ms: AtomicI64::new(Utc::now().timestamp_millis()),
+            quote_attempted: AtomicU64::new(0),
+            quote_blocked: AtomicU64::new(0),
+            policy_blocked: AtomicU64::new(0),
+            seen_count: AtomicU64::new(0),
+            candidate_count: AtomicU64::new(0),
+            quoted_count: AtomicU64::new(0),
+            eligible_count: AtomicU64::new(0),
+            executed_count: AtomicU64::new(0),
+            filled_count: AtomicU64::new(0),
+            blocked_reasons: RwLock::new(HashMap::new()),
+            exit_reasons: RwLock::new(HashMap::new()),
+            ref_ticks_total: AtomicU64::new(0),
+            book_ticks_total: AtomicU64::new(0),
+            ref_source_counts: DashMap::new(),
+            ref_dedupe_dropped: AtomicU64::new(0),
+            share_cap_drop_count: AtomicU64::new(0),
+            udp_local_drop_count_baseline: AtomicU64::new(feed_udp::udp_local_drop_count()),
+            fallback_state_code: AtomicU64::new(0),
+            fallback_trigger_reasons: RwLock::new(HashMap::new()),
+            last_ref_tick_ms: AtomicI64::new(0),
+            last_book_tick_ms: AtomicI64::new(0),
+            shots: RwLock::new(Vec::new()),
+            outcomes: RwLock::new(Vec::new()),
+            samples: RwLock::new(ShadowSamples::default()),
+            book_top_lag_by_symbol_ms: RwLock::new(HashMap::new()),
+            survival_probe_overall: RwLock::new(SurvivalProbeCounters::default()),
+            survival_probe_by_symbol: RwLock::new(HashMap::new()),
+            data_total: AtomicU64::new(0),
+            data_invalid: AtomicU64::new(0),
+            seq_gap: AtomicU64::new(0),
+            ts_inversion: AtomicU64::new(0),
+            stale_tick_dropped: AtomicU64::new(0),
+            loss_streak: AtomicU64::new(0),
+            observe_only: AtomicBool::new(false),
+            paused: AtomicBool::new(false),
+            paused_since_ms: AtomicU64::new(0),
+            paused_total_ms: AtomicU64::new(0),
+            predator_c_enabled: AtomicBool::new(false),
+            predator_dir_up: AtomicU64::new(0),
+            predator_dir_down: AtomicU64::new(0),
+            predator_dir_neutral: AtomicU64::new(0),
+            predator_taker_fired: AtomicU64::new(0),
+            predator_taker_skipped: AtomicU64::new(0),
+            predator_regime_active: AtomicU64::new(0),
+            predator_regime_quiet: AtomicU64::new(0),
+            predator_regime_defend: AtomicU64::new(0),
+            predator_cross_symbol_fired: AtomicU64::new(0),
+            predator_last_30s_taker_fallback_count: AtomicU64::new(0),
+            predator_taker_skip_reasons: RwLock::new(HashMap::new()),
+            predator_router_locked_by_tf_usdc: RwLock::new(HashMap::new()),
+            predator_capital: RwLock::new(CapitalUpdate {
+                available_usdc: 0.0,
+                base_quote_size: 0.0,
+                ts_ms: 0,
+            }),
+            predator_capital_halt: AtomicBool::new(false),
+            probability_total: AtomicU64::new(0),
+            probability_degraded: AtomicU64::new(0),
+        }
+    }
+
+    pub(crate) async fn reset(&self) -> u64 {
+        let window_id = self.window_id.fetch_add(1, Ordering::Relaxed) + 1;
+        *self.started_at.write().await = Instant::now();
+        self.started_at_ms
+            .store(Utc::now().timestamp_millis(), Ordering::Relaxed);
+        self.quote_attempted.store(0, Ordering::Relaxed);
+        self.quote_blocked.store(0, Ordering::Relaxed);
+        self.policy_blocked.store(0, Ordering::Relaxed);
+        self.seen_count.store(0, Ordering::Relaxed);
+        self.candidate_count.store(0, Ordering::Relaxed);
+        self.quoted_count.store(0, Ordering::Relaxed);
+        self.eligible_count.store(0, Ordering::Relaxed);
+        self.executed_count.store(0, Ordering::Relaxed);
+        self.filled_count.store(0, Ordering::Relaxed);
+        self.ref_ticks_total.store(0, Ordering::Relaxed);
+        self.book_ticks_total.store(0, Ordering::Relaxed);
+        self.ref_dedupe_dropped.store(0, Ordering::Relaxed);
+        self.share_cap_drop_count.store(0, Ordering::Relaxed);
+        self.udp_local_drop_count_baseline
+            .store(feed_udp::udp_local_drop_count(), Ordering::Relaxed);
+        self.fallback_state_code.store(0, Ordering::Relaxed);
+        self.last_ref_tick_ms.store(0, Ordering::Relaxed);
+        self.last_book_tick_ms.store(0, Ordering::Relaxed);
+        self.blocked_reasons.write().await.clear();
+        self.exit_reasons.write().await.clear();
+        self.ref_source_counts.clear();
+        self.fallback_trigger_reasons.write().await.clear();
+        self.shots.write().await.clear();
+        self.outcomes.write().await.clear();
+        *self.samples.write().await = ShadowSamples::default();
+        self.book_top_lag_by_symbol_ms.write().await.clear();
+        *self.survival_probe_overall.write().await = SurvivalProbeCounters::default();
+        self.survival_probe_by_symbol.write().await.clear();
+        self.data_total.store(0, Ordering::Relaxed);
+        self.data_invalid.store(0, Ordering::Relaxed);
+        self.seq_gap.store(0, Ordering::Relaxed);
+        self.ts_inversion.store(0, Ordering::Relaxed);
+        self.stale_tick_dropped.store(0, Ordering::Relaxed);
+        self.loss_streak.store(0, Ordering::Relaxed);
+        self.observe_only.store(false, Ordering::Relaxed);
+        self.paused.store(false, Ordering::Relaxed);
+        self.paused_since_ms.store(0, Ordering::Relaxed);
+        self.paused_total_ms.store(0, Ordering::Relaxed);
+        self.predator_c_enabled.store(false, Ordering::Relaxed);
+        self.predator_dir_up.store(0, Ordering::Relaxed);
+        self.predator_dir_down.store(0, Ordering::Relaxed);
+        self.predator_dir_neutral.store(0, Ordering::Relaxed);
+        self.predator_taker_fired.store(0, Ordering::Relaxed);
+        self.predator_taker_skipped.store(0, Ordering::Relaxed);
+        self.predator_regime_active.store(0, Ordering::Relaxed);
+        self.predator_regime_quiet.store(0, Ordering::Relaxed);
+        self.predator_regime_defend.store(0, Ordering::Relaxed);
+        self.predator_cross_symbol_fired.store(0, Ordering::Relaxed);
+        self.predator_last_30s_taker_fallback_count
+            .store(0, Ordering::Relaxed);
+        self.predator_taker_skip_reasons.write().await.clear();
+        self.predator_router_locked_by_tf_usdc.write().await.clear();
+        *self.predator_capital.write().await = CapitalUpdate {
+            available_usdc: 0.0,
+            base_quote_size: 0.0,
+            ts_ms: 0,
+        };
+        self.predator_capital_halt.store(false, Ordering::Relaxed);
+        self.probability_total.store(0, Ordering::Relaxed);
+        self.probability_degraded.store(0, Ordering::Relaxed);
+        window_id
+    }
+
+    #[inline]
+    pub(crate) fn is_current_window_ts_ns(&self, ts_ns: i64) -> bool {
+        let started_at_ms = self.started_at_ms.load(Ordering::Relaxed);
+        if started_at_ms <= 0 {
+            return true;
+        }
+        let ts_ms = ts_ns / 1_000_000;
+        // 1ms tolerance for clock granularity and ordering jitter around reset.
+        ts_ms.saturating_add(1) >= started_at_ms
+    }
+
+    pub(crate) async fn push_shot(&self, shot: ShadowShot) {
+        let ingest_seq = next_normalized_ingest_seq();
+        let source_seq = shot.t0_ns.max(0) as u64;
+        append_jsonl(
+            &dataset_path("normalized", "shadow_shots.jsonl"),
+            &serde_json::json!({
+                "ts_ms": Utc::now().timestamp_millis(),
+                "source_seq": source_seq,
+                "ingest_seq": ingest_seq,
+                "shot": shot
+            }),
+        );
+        let mut shots = self.shots.write().await;
+        push_capped(&mut shots, shot, Self::SHADOW_CAP);
+    }
+
+    pub(crate) async fn push_outcome(&self, outcome: ShadowOutcome) {
+        // Loss-streak only considers primary delay (10ms) *fillable* outcomes, so "no fills"
+        // does not trip risk controls.
+        const PRIMARY_DELAY_MS: u64 = 10;
+        if outcome.delay_ms == PRIMARY_DELAY_MS && outcome.fillable {
+            if outcome.net_markout_10s_usdc.unwrap_or(0.0) < 0.0 {
+                self.loss_streak.fetch_add(1, Ordering::Relaxed);
+            } else {
+                self.loss_streak.store(0, Ordering::Relaxed);
+            }
+        }
+        let ingest_seq = next_normalized_ingest_seq();
+        let source_seq = outcome.ts_ns.max(0) as u64;
+        append_jsonl(
+            &dataset_path("normalized", "shadow_outcomes.jsonl"),
+            &serde_json::json!({
+                "ts_ms": Utc::now().timestamp_millis(),
+                "source_seq": source_seq,
+                "ingest_seq": ingest_seq,
+                "outcome": outcome
+            }),
+        );
+        let mut outcomes = self.outcomes.write().await;
+        push_capped(&mut outcomes, outcome, Self::SHADOW_CAP);
+    }
+
+    pub(crate) fn loss_streak(&self) -> u32 {
+        self.loss_streak
+            .load(Ordering::Relaxed)
+            .min(u32::MAX as u64) as u32
+    }
+
+    pub(crate) async fn push_depth_sample(
+        &self,
+        event_backlog: f64,
+        queue_depth: f64,
+        io_queue_depth: f64,
+    ) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.event_backlog, event_backlog, Self::SAMPLE_CAP);
+        push_capped(&mut s.queue_depth, queue_depth, Self::SAMPLE_CAP);
+        push_capped(&mut s.io_queue_depth, io_queue_depth, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_latency_sample(
+        &self,
+        feed_in_ms: f64,
+        source_latency_ms: f64,
+        exchange_lag_ms: f64,
+        path_lag_ms: f64,
+        book_latency_ms: f64,
+        local_backlog_ms: f64,
+        ref_decode_ms: f64,
+    ) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.feed_in_ms, feed_in_ms, Self::SAMPLE_CAP);
+        push_capped(
+            &mut s.source_latency_ms,
+            source_latency_ms,
+            Self::SAMPLE_CAP,
+        );
+        push_capped(&mut s.exchange_lag_ms, exchange_lag_ms, Self::SAMPLE_CAP);
+        if path_lag_ms.is_finite() && path_lag_ms >= 0.0 {
+            push_capped(&mut s.path_lag_ms, path_lag_ms, Self::SAMPLE_CAP);
+        }
+        push_capped(&mut s.book_latency_ms, book_latency_ms, Self::SAMPLE_CAP);
+        push_capped(&mut s.local_backlog_ms, local_backlog_ms, Self::SAMPLE_CAP);
+        push_capped(&mut s.ref_decode_ms, ref_decode_ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_decision_queue_wait_ms(&self, ms: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.decision_queue_wait_ms, ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_ack_only_ms(&self, ms: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.ack_only_ms, ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_tick_to_ack_ms(&self, ms: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.tick_to_ack_ms, ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_capturable_window_ms(&self, ms: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.capturable_window_ms, ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_alpha_window_sample(&self, ms: f64, hit: bool) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.alpha_window_ms, ms.max(0.0), Self::SAMPLE_CAP);
+        push_capped(
+            &mut s.alpha_window_hit,
+            if hit { 1.0 } else { 0.0 },
+            Self::SAMPLE_CAP,
+        );
+    }
+
+    pub(crate) async fn push_book_top_lag_ms(&self, symbol: &str, ms: f64) {
+        {
+            let mut s = self.samples.write().await;
+            push_capped(&mut s.book_top_lag_ms, ms, Self::SAMPLE_CAP);
+        }
+
+        let mut by_symbol = self.book_top_lag_by_symbol_ms.write().await;
+        let entry = by_symbol.entry(symbol.to_string()).or_default();
+        push_capped(entry, ms, 4_096);
+    }
+
+    pub(crate) fn book_top_lag_p50_ms_for_symbol_sync(&self, symbol: &str) -> Option<f64> {
+        let by_symbol = self.book_top_lag_by_symbol_ms.try_read().ok()?;
+        let samples = by_symbol.get(symbol)?;
+        if samples.len() < 8 {
+            return None;
+        }
+        let mut sorted = samples.clone();
+        sorted.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
+        let idx = (sorted.len() as f64 * 0.50) as usize;
+        sorted.get(idx.min(sorted.len().saturating_sub(1))).copied()
+    }
+
+    pub(crate) async fn record_survival_probe(&self, symbol: &str, delay_ms: u64, survived: bool) {
+        {
+            let mut c = self.survival_probe_overall.write().await;
+            c.record(delay_ms, survived);
+        }
+        let mut by_symbol = self.survival_probe_by_symbol.write().await;
+        let entry = by_symbol.entry(symbol.to_string()).or_default();
+        entry.record(delay_ms, survived);
+    }
+
+    pub(crate) async fn push_signal_us(&self, us: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.signal_us, us, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_shadow_fill_ms(&self, ms: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.shadow_fill_ms, ms, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_parse_us(&self, us: f64) {
+        let mut s = self.samples.write().await;
+        push_capped(&mut s.parse_us, us, Self::SAMPLE_CAP);
+    }
+
+    pub(crate) async fn push_probability_sample(&self, estimate: &ProbabilityEstimate) {
+        self.probability_total.fetch_add(1, Ordering::Relaxed);
+        if estimate.settlement_source_degraded {
+            self.probability_degraded.fetch_add(1, Ordering::Relaxed);
+        }
+        let mut s = self.samples.write().await;
+        let delta_bps =
+            ((estimate.p_settle - estimate.p_fast).abs() * 10_000.0).clamp(0.0, 10_000.0);
+        push_capped(&mut s.settle_fast_delta_bps, delta_bps, Self::SAMPLE_CAP);
+        push_capped(
+            &mut s.probability_confidence,
+            estimate.confidence.clamp(0.0, 1.0),
+            Self::SAMPLE_CAP,
+        );
+    }
+
+    pub(crate) fn mark_attempted(&self) {
+        self.quote_attempted.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_seen(&self) {
+        self.seen_count.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_candidate(&self) {
+        self.candidate_count.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_eligible(&self) {
+        self.eligible_count.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_executed(&self) {
+        self.executed_count.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_filled(&self, n: u64) {
+        self.filled_count.fetch_add(n, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_blocked(&self) {
+        self.quote_blocked.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_policy_blocked(&self) {
+        self.policy_blocked.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) async fn mark_blocked_with_reason(&self, reason: &str) {
+        if is_quote_reject_reason(reason) {
+            self.mark_blocked();
+        }
+        if is_policy_block_reason(reason) {
+            self.mark_policy_blocked();
+        }
+        let mut reasons = self.blocked_reasons.write().await;
+        *reasons.entry(reason.to_string()).or_insert(0) += 1;
+    }
+
+    pub(crate) async fn record_issue(&self, reason: &str) {
+        let mut reasons = self.blocked_reasons.write().await;
+        *reasons.entry(reason.to_string()).or_insert(0) += 1;
+    }
+
+    pub(crate) fn mark_ref_tick(&self, source: &str, ts_ms: i64) {
+        self.ref_ticks_total.fetch_add(1, Ordering::Relaxed);
+        self.last_ref_tick_ms.store(ts_ms, Ordering::Relaxed);
+        self.ref_source_counts
+            .entry(source.to_string())
+            .and_modify(|count| *count = count.saturating_add(1))
+            .or_insert(1);
+    }
+
+    pub(crate) fn mark_ref_dedupe_dropped(&self) {
+        self.ref_dedupe_dropped.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_share_cap_drop(&self) {
+        self.share_cap_drop_count.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) async fn mark_fallback_trigger_reason(&self, reason: &str) {
+        let mut reasons = self.fallback_trigger_reasons.write().await;
+        *reasons.entry(reason.to_string()).or_insert(0) += 1;
+    }
+
+    pub(crate) fn set_fallback_state(&self, state: &str) {
+        let code = match state {
+            "ws_primary" => 0,
+            "armed" => 1,
+            "udp_fallback" => 2,
+            "cooldown" => 3,
+            _ => 0,
+        };
+        self.fallback_state_code.store(code, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_book_tick(&self, ts_ms: i64) {
+        self.book_ticks_total.fetch_add(1, Ordering::Relaxed);
+        self.last_book_tick_ms.store(ts_ms, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_data_validity(&self, valid: bool) {
+        self.data_total.fetch_add(1, Ordering::Relaxed);
+        if !valid {
+            self.data_invalid.fetch_add(1, Ordering::Relaxed);
+        }
+    }
+
+    pub(crate) fn mark_ts_inversion(&self) {
+        self.ts_inversion.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_stale_tick_dropped(&self) {
+        self.stale_tick_dropped.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) async fn record_exit_reason(&self, reason: &str) {
+        let mut reasons = self.exit_reasons.write().await;
+        *reasons.entry(reason.to_string()).or_insert(0) += 1;
+    }
+
+    pub(crate) fn observe_only(&self) -> bool {
+        self.observe_only.load(Ordering::Relaxed)
+    }
+
+    pub(crate) fn set_observe_only(&self, v: bool) {
+        self.observe_only.store(v, Ordering::Relaxed);
+    }
+
+    pub(crate) fn set_paused(&self, v: bool) {
+        let now_ms = Utc::now().timestamp_millis().max(0) as u64;
+        let was = self.paused.swap(v, Ordering::Relaxed);
+        if was == v {
+            return;
+        }
+        if v {
+            self.paused_since_ms.store(now_ms, Ordering::Relaxed);
+            return;
+        }
+        let since = self.paused_since_ms.swap(0, Ordering::Relaxed);
+        if since > 0 {
+            self.paused_total_ms
+                .fetch_add(now_ms.saturating_sub(since), Ordering::Relaxed);
+        }
+    }
+
+    pub(crate) fn set_predator_enabled(&self, v: bool) {
+        self.predator_c_enabled.store(v, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_predator_direction(&self, dir: &Direction) {
+        match dir {
+            Direction::Up => {
+                self.predator_dir_up.fetch_add(1, Ordering::Relaxed);
+            }
+            Direction::Down => {
+                self.predator_dir_down.fetch_add(1, Ordering::Relaxed);
+            }
+            Direction::Neutral => {
+                self.predator_dir_neutral.fetch_add(1, Ordering::Relaxed);
+            }
+        }
+    }
+
+    pub(crate) fn mark_predator_taker_fired(&self) {
+        self.predator_taker_fired.fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_predator_last_30s_taker_fallback(&self) {
+        self.predator_last_30s_taker_fallback_count
+            .fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) fn mark_predator_regime(&self, regime: &Regime) {
+        match regime {
+            Regime::Active => {
+                self.predator_regime_active.fetch_add(1, Ordering::Relaxed);
+            }
+            Regime::Quiet => {
+                self.predator_regime_quiet.fetch_add(1, Ordering::Relaxed);
+            }
+            Regime::Defend => {
+                self.predator_regime_defend.fetch_add(1, Ordering::Relaxed);
+            }
+        }
+    }
+
+    pub(crate) fn mark_predator_cross_symbol_fired(&self) {
+        self.predator_cross_symbol_fired
+            .fetch_add(1, Ordering::Relaxed);
+    }
+
+    pub(crate) async fn mark_predator_taker_skipped(&self, reason: &str) {
+        self.predator_taker_skipped.fetch_add(1, Ordering::Relaxed);
+        let mut reasons = self.predator_taker_skip_reasons.write().await;
+        *reasons.entry(reason.to_string()).or_insert(0) += 1;
+    }
+
+    pub(crate) async fn set_predator_router_locked_by_tf_usdc(&self, locked: HashMap<String, f64>) {
+        *self.predator_router_locked_by_tf_usdc.write().await = locked;
+    }
+
+    pub(crate) async fn set_predator_capital(&self, update: CapitalUpdate, halt: bool) {
+        *self.predator_capital.write().await = update;
+        self.predator_capital_halt.store(halt, Ordering::Relaxed);
+    }
+
+    pub(crate) fn uptime_pct(&self, elapsed: Duration) -> f64 {
+        let elapsed_ms = elapsed.as_millis() as u64;
+        if elapsed_ms == 0 {
+            return 100.0;
+        }
+        let now_ms = Utc::now().timestamp_millis().max(0) as u64;
+        let base_paused = self.paused_total_ms.load(Ordering::Relaxed);
+        let paused_extra = if self.paused.load(Ordering::Relaxed) {
+            let since = self.paused_since_ms.load(Ordering::Relaxed);
+            if since > 0 {
+                now_ms.saturating_sub(since)
+            } else {
+                0
+            }
+        } else {
+            0
+        };
+        let paused_ms = base_paused.saturating_add(paused_extra).min(elapsed_ms);
+        let uptime_ms = elapsed_ms.saturating_sub(paused_ms);
+        ((uptime_ms as f64) * 100.0 / elapsed_ms as f64).clamp(0.0, 100.0)
+    }
+}
+
+impl ShadowStats {
+    pub(crate) async fn build_live_report(&self) -> ShadowLiveReport {
+        const PRIMARY_DELAY_MS: u64 = 10;
+        let ShadowSamples {
+            decision_queue_wait_ms,
+            decision_compute_ms,
+            tick_to_decision_ms,
+            ack_only_ms,
+            tick_to_ack_ms,
+            capturable_window_ms,
+            alpha_window_ms,
+            alpha_window_hit,
+            feed_in_ms,
+            source_latency_ms,
+            exchange_lag_ms,
+            path_lag_ms,
+            book_latency_ms,
+            local_backlog_ms,
+            ref_decode_ms,
+            book_top_lag_ms,
+            signal_us,
+            quote_us,
+            risk_us,
+            shadow_fill_ms,
+            queue_depth,
+            event_backlog,
+            parse_us,
+            io_queue_depth,
+            settle_fast_delta_bps,
+            probability_confidence,
+        } = self.samples.read().await.clone();
+        let book_top_lag_by_symbol_ms = self.book_top_lag_by_symbol_ms.read().await.clone();
+        let mut blocked_reason_counts = self.blocked_reasons.read().await.clone();
+        let source_counts = self
+            .ref_source_counts
+            .iter()
+            .map(|entry| (entry.key().clone(), *entry.value()))
+            .collect::<HashMap<_, _>>();
+        let exit_reason_counts = self.exit_reasons.read().await.clone();
+        let survival_probe_overall = *self.survival_probe_overall.read().await;
+        let survival_probe_by_symbol = self.survival_probe_by_symbol.read().await.clone();
+        let elapsed = self.started_at.read().await.elapsed();
+        let uptime_pct = self.uptime_pct(elapsed);
+
+        // Avoid cloning large shot/outcome vectors per request. Under stress polling this can
+        // cause massive allocation churn and even OOM kills (esp. when market_scorecard is large).
+        let shots_guard = self.shots.read().await;
+        let outcomes_guard = self.outcomes.read().await;
+
+        let fillability_5 = fillability_ratio(&outcomes_guard, 5);
+        let fillability_10 = fillability_ratio(&outcomes_guard, 10);
+        let fillability_25 = fillability_ratio(&outcomes_guard, 25);
+        let survival_5 = survival_ratio(&outcomes_guard, 5);
+        let survival_10 = survival_ratio(&outcomes_guard, 10);
+        let survival_25 = survival_ratio(&outcomes_guard, 25);
+        let survival_probe_5 = survival_probe_overall.ratio(5);
+        let survival_probe_10 = survival_probe_overall.ratio(10);
+        let survival_probe_25 = survival_probe_overall.ratio(25);
+        let survival_probe_5_n = survival_probe_overall.n(5);
+        let survival_probe_10_n = survival_probe_overall.n(10);
+        let survival_probe_25_n = survival_probe_overall.n(25);
+
+        let shots_primary = shots_guard
+            .iter()
+            .filter(|s| s.delay_ms == PRIMARY_DELAY_MS)
+            .collect::<Vec<_>>();
+        let outcomes_primary = outcomes_guard
+            .iter()
+            .filter(|o| o.delay_ms == PRIMARY_DELAY_MS)
+            .collect::<Vec<_>>();
+        let outcomes_primary_valid = outcomes_primary
+            .iter()
+            .filter(|o| !o.is_stale_tick)
+            .collect::<Vec<_>>();
+        let net_edges = shots_primary
+            .iter()
+            .map(|s| s.edge_net_bps)
+            .collect::<Vec<_>>();
+        let net_edge_p50 = percentile(&net_edges, 0.50).unwrap_or(0.0);
+        let net_edge_p10 = percentile(&net_edges, 0.10).unwrap_or(0.0);
+        let pnl_1s = outcomes_primary_valid
+            .iter()
+            .filter_map(|o| o.net_markout_1s_bps.or(o.pnl_1s_bps))
+            .collect::<Vec<_>>();
+        let pnl_5s = outcomes_primary_valid
+            .iter()
+            .filter_map(|o| o.net_markout_5s_bps.or(o.pnl_5s_bps))
+            .collect::<Vec<_>>();
+        let pnl_10s = outcomes_primary_valid
+            .iter()
+            .filter_map(|o| o.net_markout_10s_bps.or(o.pnl_10s_bps))
+            .collect::<Vec<_>>();
+        let net_markout_10s_usdc = outcomes_primary_valid
+            .iter()
+            .filter_map(|o| o.net_markout_10s_usdc)
+            .collect::<Vec<_>>();
+        let roi_notional_10s_bps = outcomes_primary_valid
+            .iter()
+            .filter_map(|o| o.roi_notional_10s_bps)
+            .collect::<Vec<_>>();
+        let pnl_1s_p50 = percentile(&pnl_1s, 0.50).unwrap_or(0.0);
+        let pnl_5s_p50 = percentile(&pnl_5s, 0.50).unwrap_or(0.0);
+        let pnl_10s_p50_raw = percentile(&pnl_10s, 0.50).unwrap_or(0.0);
+        let net_markout_10s_usdc_p50 = percentile(&net_markout_10s_usdc, 0.50).unwrap_or(0.0);
+        let roi_notional_10s_bps_p50 = percentile(&roi_notional_10s_bps, 0.50).unwrap_or(0.0);
+        let ev_net_usdc_p50 = percentile(&net_markout_10s_usdc, 0.50).unwrap_or(0.0);
+        let ev_net_usdc_p10 = percentile(&net_markout_10s_usdc, 0.10).unwrap_or(0.0);
+        let ev_positive_ratio = if net_markout_10s_usdc.is_empty() {
+            0.0
+        } else {
+            net_markout_10s_usdc.iter().filter(|v| **v > 0.0).count() as f64
+                / net_markout_10s_usdc.len() as f64
+        };
+        let (pnl_10s_filtered, pnl_10s_outlier_ratio) = robust_filter_iqr(&pnl_10s);
+        let pnl_10s_p50_robust = percentile(&pnl_10s_filtered, 0.50).unwrap_or(pnl_10s_p50_raw);
+        let pnl_10s_sample_count = pnl_10s.len();
+
+        let attempted = self.quote_attempted.load(Ordering::Relaxed);
+        let blocked = self.quote_blocked.load(Ordering::Relaxed);
+        let policy_blocked = self.policy_blocked.load(Ordering::Relaxed);
+        let eligible_count = self.eligible_count.load(Ordering::Relaxed);
+        let executed_count = self.executed_count.load(Ordering::Relaxed);
+        let executed_over_eligible = if eligible_count == 0 {
+            0.0
+        } else {
+            executed_count as f64 / eligible_count as f64
+        };
+        let quote_block_ratio = quote_block_ratio(attempted, blocked);
+        let policy_ratio = policy_block_ratio(attempted, policy_blocked);
+
+        let tick_to_ack_p99 = percentile(&tick_to_ack_ms, 0.99).unwrap_or(0.0);
+        let scorecard = build_market_scorecard(&shots_guard, &outcomes_guard);
+        let ref_ticks_total = self.ref_ticks_total.load(Ordering::Relaxed);
+        let book_ticks_total = self.book_ticks_total.load(Ordering::Relaxed);
+        let now_ms = Utc::now().timestamp_millis();
+        let last_ref_tick_ms = self.last_ref_tick_ms.load(Ordering::Relaxed);
+        let last_book_tick_ms = self.last_book_tick_ms.load(Ordering::Relaxed);
+        let ref_freshness_ms = freshness_ms(now_ms, last_ref_tick_ms);
+        let book_freshness_ms = freshness_ms(now_ms, last_book_tick_ms);
+        let data_total = self.data_total.load(Ordering::Relaxed);
+        let data_invalid = self.data_invalid.load(Ordering::Relaxed);
+        let seq_gap = self.seq_gap.load(Ordering::Relaxed);
+        let ts_inversion = self.ts_inversion.load(Ordering::Relaxed);
+        let stale_tick_dropped = self.stale_tick_dropped.load(Ordering::Relaxed);
+        let data_valid_ratio = if data_total == 0 {
+            1.0
+        } else {
+            1.0 - (data_invalid as f64 / data_total as f64)
+        };
+        let seq_gap_rate = if data_total == 0 {
+            0.0
+        } else {
+            seq_gap as f64 / data_total as f64
+        };
+        let ts_inversion_rate = if data_total == 0 {
+            0.0
+        } else {
+            ts_inversion as f64 / data_total as f64
+        };
+        let stale_tick_drop_ratio = if data_total == 0 {
+            0.0
+        } else {
+            stale_tick_dropped as f64 / data_total as f64
+        };
+        let dedupe_dropped = self.ref_dedupe_dropped.load(Ordering::Relaxed);
+        let probability_total = self.probability_total.load(Ordering::Relaxed);
+        let probability_degraded = self.probability_degraded.load(Ordering::Relaxed);
+        let settlement_source_degraded_ratio = if probability_total == 0 {
+            0.0
+        } else {
+            probability_degraded as f64 / probability_total as f64
+        };
+        let settle_fast_delta_p50_bps = percentile(&settle_fast_delta_bps, 0.50).unwrap_or(0.0);
+        let settle_fast_delta_p90_bps = percentile(&settle_fast_delta_bps, 0.90).unwrap_or(0.0);
+        let probability_confidence_p50 = percentile(&probability_confidence, 0.50).unwrap_or(0.0);
+        if dedupe_dropped > 0 {
+            blocked_reason_counts.insert("ref_dedupe_dropped".to_string(), dedupe_dropped);
+        }
+        let mut policy_block_reason_distribution = HashMap::new();
+        let mut gate_block_reason_distribution = HashMap::new();
+        let mut gate_blocked: u64 = 0;
+        if policy_blocked > 0 {
+            for (reason, count) in &blocked_reason_counts {
+                if is_policy_block_reason(reason.as_str()) {
+                    policy_block_reason_distribution.insert(reason.clone(), *count);
+                }
+            }
+        }
+        for (reason, count) in &blocked_reason_counts {
+            if is_gate_block_reason(reason.as_str()) {
+                gate_block_reason_distribution.insert(reason.clone(), *count);
+                gate_blocked = gate_blocked.saturating_add(*count);
+            }
+        }
+        let gate_block_ratio = ratio_u64(gate_blocked, attempted.saturating_add(gate_blocked));
+        let mut source_mix_ratio = HashMap::new();
+        if ref_ticks_total > 0 {
+            for (source, cnt) in &source_counts {
+                source_mix_ratio.insert(
+                    source.clone(),
+                    (*cnt as f64 / ref_ticks_total as f64).clamp(0.0, 1.0),
+                );
+            }
+        }
+        let udp_share_effective = source_mix_ratio.get("binance_udp").copied().unwrap_or(0.0);
+        let udp_local_drop_count = feed_udp::udp_local_drop_count()
+            .saturating_sub(self.udp_local_drop_count_baseline.load(Ordering::Relaxed));
+        let share_cap_drop_count = self.share_cap_drop_count.load(Ordering::Relaxed);
+        let fallback_state = match self.fallback_state_code.load(Ordering::Relaxed) {
+            1 => "armed",
+            2 => "udp_fallback",
+            3 => "cooldown",
+            _ => "ws_primary",
+        }
+        .to_string();
+        let fallback_trigger_reason_distribution =
+            self.fallback_trigger_reasons.read().await.clone();
+        let mut exit_reason_top = exit_reason_counts.into_iter().collect::<Vec<_>>();
+        exit_reason_top.sort_by(|a, b| b.1.cmp(&a.1));
+        exit_reason_top.truncate(8);
+        let lag_half_life_ms = percentile(
+            &book_top_lag_ms
+                .iter()
+                .copied()
+                .filter(|v| v.is_finite() && *v >= 0.0)
+                .collect::<Vec<_>>(),
+            0.50,
+        )
+        .unwrap_or(0.0);
+
+        let book_top_lag_p50_ms = percentile(&book_top_lag_ms, 0.50).unwrap_or(0.0);
+        let book_top_lag_p90_ms = percentile(&book_top_lag_ms, 0.90).unwrap_or(0.0);
+        let book_top_lag_p99_ms = percentile(&book_top_lag_ms, 0.99).unwrap_or(0.0);
+        let mut book_top_lag_by_symbol_p50_ms = HashMap::new();
+        for (sym, samples) in book_top_lag_by_symbol_ms {
+            book_top_lag_by_symbol_p50_ms.insert(sym, percentile(&samples, 0.50).unwrap_or(0.0));
+        }
+
+        let mut survival_10ms_by_symbol = HashMap::new();
+        let mut survival_counts: HashMap<String, (u64, u64)> = HashMap::new();
+        for o in &outcomes_primary_valid {
+            let o = *o;
+            let e = survival_counts.entry(o.symbol.clone()).or_insert((0, 0));
+            e.0 = e.0.saturating_add(1);
+            if o.survived {
+                e.1 = e.1.saturating_add(1);
+            }
+        }
+        for (sym, (n, s)) in survival_counts {
+            survival_10ms_by_symbol.insert(sym, if n == 0 { 0.0 } else { s as f64 / n as f64 });
+        }
+        let mut survival_probe_10ms_by_symbol = HashMap::new();
+        for (sym, c) in survival_probe_by_symbol {
+            survival_probe_10ms_by_symbol.insert(sym, c.ratio(10));
+        }
+
+        let shots_primary_at_ack = shots_primary
+            .iter()
+            .copied()
+            .filter(|s| s.ack_only_ms > 0.0)
+            .collect::<Vec<_>>();
+        let book_top_lag_at_ack_ms = shots_primary_at_ack
+            .iter()
+            .map(|s| s.book_top_lag_ms)
+            .collect::<Vec<_>>();
+
+        let latency = LatencyBreakdown {
+            feed_in_p50_ms: percentile(&feed_in_ms, 0.50).unwrap_or(0.0),
+            feed_in_p90_ms: percentile(&feed_in_ms, 0.90).unwrap_or(0.0),
+            feed_in_p99_ms: percentile(&feed_in_ms, 0.99).unwrap_or(0.0),
+            signal_p50_us: percentile(&signal_us, 0.50).unwrap_or(0.0),
+            signal_p90_us: percentile(&signal_us, 0.90).unwrap_or(0.0),
+            signal_p99_us: percentile(&signal_us, 0.99).unwrap_or(0.0),
+            quote_p50_us: percentile(&quote_us, 0.50).unwrap_or(0.0),
+            quote_p90_us: percentile(&quote_us, 0.90).unwrap_or(0.0),
+            quote_p99_us: percentile(&quote_us, 0.99).unwrap_or(0.0),
+            risk_p50_us: percentile(&risk_us, 0.50).unwrap_or(0.0),
+            risk_p90_us: percentile(&risk_us, 0.90).unwrap_or(0.0),
+            risk_p99_us: percentile(&risk_us, 0.99).unwrap_or(0.0),
+            decision_queue_wait_p50_ms: percentile(&decision_queue_wait_ms, 0.50).unwrap_or(0.0),
+            decision_queue_wait_p90_ms: percentile(&decision_queue_wait_ms, 0.90).unwrap_or(0.0),
+            decision_queue_wait_p99_ms: percentile(&decision_queue_wait_ms, 0.99).unwrap_or(0.0),
+            decision_compute_p50_ms: percentile(&decision_compute_ms, 0.50).unwrap_or(0.0),
+            decision_compute_p90_ms: percentile(&decision_compute_ms, 0.90).unwrap_or(0.0),
+            decision_compute_p99_ms: percentile(&decision_compute_ms, 0.99).unwrap_or(0.0),
+            tick_to_decision_p50_ms: percentile(&tick_to_decision_ms, 0.50).unwrap_or(0.0),
+            tick_to_decision_p90_ms: percentile(&tick_to_decision_ms, 0.90).unwrap_or(0.0),
+            tick_to_decision_p99_ms: percentile(&tick_to_decision_ms, 0.99).unwrap_or(0.0),
+            ack_only_p50_ms: percentile(&ack_only_ms, 0.50).unwrap_or(0.0),
+            ack_only_p90_ms: percentile(&ack_only_ms, 0.90).unwrap_or(0.0),
+            ack_only_p99_ms: percentile(&ack_only_ms, 0.99).unwrap_or(0.0),
+            tick_to_ack_p50_ms: percentile(&tick_to_ack_ms, 0.50).unwrap_or(0.0),
+            tick_to_ack_p90_ms: percentile(&tick_to_ack_ms, 0.90).unwrap_or(0.0),
+            tick_to_ack_p99_ms: tick_to_ack_p99,
+            parse_p99_us: percentile(&parse_us, 0.99).unwrap_or(0.0),
+            io_queue_p99_ms: percentile(&io_queue_depth, 0.99).unwrap_or(0.0),
+            bus_lag_p99_ms: percentile(&event_backlog, 0.99).unwrap_or(0.0),
+            shadow_fill_p50_ms: percentile(&shadow_fill_ms, 0.50).unwrap_or(0.0),
+            shadow_fill_p90_ms: percentile(&shadow_fill_ms, 0.90).unwrap_or(0.0),
+            shadow_fill_p99_ms: percentile(&shadow_fill_ms, 0.99).unwrap_or(0.0),
+            source_latency_p50_ms: percentile(&source_latency_ms, 0.50).unwrap_or(0.0),
+            source_latency_p90_ms: percentile(&source_latency_ms, 0.90).unwrap_or(0.0),
+            source_latency_p99_ms: percentile(&source_latency_ms, 0.99).unwrap_or(0.0),
+            exchange_lag_p50_ms: percentile(&exchange_lag_ms, 0.50).unwrap_or(0.0),
+            exchange_lag_p90_ms: percentile(&exchange_lag_ms, 0.90).unwrap_or(0.0),
+            exchange_lag_p99_ms: percentile(&exchange_lag_ms, 0.99).unwrap_or(0.0),
+            path_lag_p50_ms: percentile(&path_lag_ms, 0.50).unwrap_or(0.0),
+            path_lag_p90_ms: percentile(&path_lag_ms, 0.90).unwrap_or(0.0),
+            path_lag_p99_ms: percentile(&path_lag_ms, 0.99).unwrap_or(0.0),
+            path_lag_coverage_ratio: ratio_u64(
+                path_lag_ms.len() as u64,
+                source_latency_ms.len() as u64,
+            ),
+            book_latency_p50_ms: percentile(&book_latency_ms, 0.50).unwrap_or(0.0),
+            book_latency_p90_ms: percentile(&book_latency_ms, 0.90).unwrap_or(0.0),
+            book_latency_p99_ms: percentile(&book_latency_ms, 0.99).unwrap_or(0.0),
+            local_backlog_p50_ms: percentile(&local_backlog_ms, 0.50).unwrap_or(0.0),
+            local_backlog_p90_ms: percentile(&local_backlog_ms, 0.90).unwrap_or(0.0),
+            local_backlog_p99_ms: percentile(&local_backlog_ms, 0.99).unwrap_or(0.0),
+            ref_decode_p50_ms: percentile(&ref_decode_ms, 0.50).unwrap_or(0.0),
+            ref_decode_p90_ms: percentile(&ref_decode_ms, 0.90).unwrap_or(0.0),
+            ref_decode_p99_ms: percentile(&ref_decode_ms, 0.99).unwrap_or(0.0),
+            book_top_lag_at_ack_p50_ms: percentile(&book_top_lag_at_ack_ms, 0.50).unwrap_or(0.0),
+            book_top_lag_at_ack_p90_ms: percentile(&book_top_lag_at_ack_ms, 0.90).unwrap_or(0.0),
+            book_top_lag_at_ack_p99_ms: percentile(&book_top_lag_at_ack_ms, 0.99).unwrap_or(0.0),
+            book_top_lag_at_ack_n: book_top_lag_at_ack_ms.len() as u64,
+            capturable_window_p50_ms: percentile(&capturable_window_ms, 0.50).unwrap_or(0.0),
+            capturable_window_p75_ms: percentile(&capturable_window_ms, 0.75).unwrap_or(0.0),
+            capturable_window_p90_ms: percentile(&capturable_window_ms, 0.90).unwrap_or(0.0),
+            capturable_window_p99_ms: percentile(&capturable_window_ms, 0.99).unwrap_or(0.0),
+            alpha_window_p50_ms: percentile(&alpha_window_ms, 0.50).unwrap_or(0.0),
+            alpha_window_p90_ms: percentile(&alpha_window_ms, 0.90).unwrap_or(0.0),
+            alpha_window_p99_ms: percentile(&alpha_window_ms, 0.99).unwrap_or(0.0),
+            alpha_window_hit_ratio: if alpha_window_hit.is_empty() {
+                0.0
+            } else {
+                alpha_window_hit.iter().sum::<f64>() / alpha_window_hit.len() as f64
+            },
+            alpha_window_n: alpha_window_ms.len() as u64,
+            profitable_window_ratio: if capturable_window_ms.is_empty() {
+                0.0
+            } else {
+                capturable_window_ms.iter().filter(|v| **v > 0.0).count() as f64
+                    / capturable_window_ms.len() as f64
+            },
+            capturable_window_n: capturable_window_ms.len() as u64,
+            ack_only_n: ack_only_ms.len() as u64,
+            tick_to_ack_n: tick_to_ack_ms.len() as u64,
+        };
+
+        let total_shots = shots_guard.len();
+        let total_outcomes = outcomes_guard.len();
+
+        // IMPORTANT: drop large read-guards before awaiting on other locks below.
+        drop(shots_guard);
+        drop(outcomes_guard);
+
+        let predator_c_enabled = self.predator_c_enabled.load(Ordering::Relaxed);
+        let direction_signals_up = self.predator_dir_up.load(Ordering::Relaxed);
+        let direction_signals_down = self.predator_dir_down.load(Ordering::Relaxed);
+        let direction_signals_neutral = self.predator_dir_neutral.load(Ordering::Relaxed);
+        let taker_sniper_fired = self.predator_taker_fired.load(Ordering::Relaxed);
+        let taker_sniper_skipped = self.predator_taker_skipped.load(Ordering::Relaxed);
+        let predator_regime_active = self.predator_regime_active.load(Ordering::Relaxed);
+        let predator_regime_quiet = self.predator_regime_quiet.load(Ordering::Relaxed);
+        let predator_regime_defend = self.predator_regime_defend.load(Ordering::Relaxed);
+        let predator_cross_symbol_fired = self.predator_cross_symbol_fired.load(Ordering::Relaxed);
+        let last_30s_taker_fallback_count = self
+            .predator_last_30s_taker_fallback_count
+            .load(Ordering::Relaxed);
+        let skip_reasons = self.predator_taker_skip_reasons.read().await.clone();
+        let mut skip_top = skip_reasons.into_iter().collect::<Vec<_>>();
+        skip_top.sort_by(|a, b| b.1.cmp(&a.1));
+        skip_top.truncate(10);
+        let router_locked_by_tf_usdc = self.predator_router_locked_by_tf_usdc.read().await.clone();
+        let capital = self.predator_capital.read().await.clone();
+        let capital_halt = self.predator_capital_halt.load(Ordering::Relaxed);
+
+        let gate_ready_strict = total_outcomes >= Self::GATE_MIN_OUTCOMES;
+        let gate_ready_effective = gate_ready_strict || eligible_count > 0 || executed_count > 0;
+
+        let mut live = ShadowLiveReport {
+            window_id: self.window_id.load(Ordering::Relaxed),
+            window_shots: total_shots,
+            window_outcomes: total_outcomes,
+            gate_ready: gate_ready_strict,
+            gate_ready_strict,
+            gate_ready_effective,
+            gate_fail_reasons: Vec::new(),
+            observe_only: self.observe_only(),
+            started_at_ms: self.started_at_ms.load(Ordering::Relaxed),
+            elapsed_sec: elapsed.as_secs(),
+            total_shots,
+            total_outcomes,
+            data_valid_ratio,
+            seq_gap_rate,
+            ts_inversion_rate,
+            stale_tick_drop_ratio,
+            quote_attempted: attempted,
+            quote_blocked: blocked,
+            policy_blocked,
+            fillability_5ms: fillability_5,
+            fillability_10ms: fillability_10,
+            fillability_25ms: fillability_25,
+            survival_5ms: survival_5,
+            survival_10ms: survival_10,
+            survival_25ms: survival_25,
+            survival_probe_5ms: survival_probe_5,
+            survival_probe_10ms: survival_probe_10,
+            survival_probe_25ms: survival_probe_25,
+            survival_probe_5ms_n: survival_probe_5_n,
+            survival_probe_10ms_n: survival_probe_10_n,
+            survival_probe_25ms_n: survival_probe_25_n,
+            net_edge_p50_bps: net_edge_p50,
+            net_edge_p10_bps: net_edge_p10,
+            pnl_1s_p50_bps: pnl_1s_p50,
+            pnl_5s_p50_bps: pnl_5s_p50,
+            pnl_10s_p50_bps: pnl_10s_p50_raw,
+            pnl_10s_p50_bps_raw: pnl_10s_p50_raw,
+            pnl_10s_p50_bps_robust: pnl_10s_p50_robust,
+            net_markout_10s_usdc_p50,
+            roi_notional_10s_bps_p50,
+            pnl_10s_sample_count,
+            pnl_10s_outlier_ratio,
+            eligible_count,
+            executed_count,
+            executed_over_eligible,
+            ev_net_usdc_p50,
+            ev_net_usdc_p10,
+            ev_positive_ratio,
+            quote_block_ratio,
+            policy_block_ratio: policy_ratio,
+            gate_blocked,
+            gate_block_ratio,
+            queue_depth_p99: percentile(&queue_depth, 0.99).unwrap_or(0.0),
+            event_backlog_p99: percentile(&event_backlog, 0.99).unwrap_or(0.0),
+            tick_to_decision_p50_ms: latency.tick_to_decision_p50_ms,
+            tick_to_decision_p90_ms: latency.tick_to_decision_p90_ms,
+            tick_to_decision_p99_ms: latency.tick_to_decision_p99_ms,
+            decision_queue_wait_p99_ms: latency.decision_queue_wait_p99_ms,
+            decision_compute_p99_ms: latency.decision_compute_p99_ms,
+            source_latency_p99_ms: latency.source_latency_p99_ms,
+            exchange_lag_p99_ms: latency.exchange_lag_p99_ms,
+            path_lag_p99_ms: latency.path_lag_p99_ms,
+            local_backlog_p99_ms: latency.local_backlog_p99_ms,
+            lag_half_life_ms,
+            probability_total,
+            settlement_source_degraded_ratio,
+            settle_fast_delta_p50_bps,
+            settle_fast_delta_p90_bps,
+            probability_confidence_p50,
+            ack_only_p50_ms: latency.ack_only_p50_ms,
+            ack_only_p90_ms: latency.ack_only_p90_ms,
+            ack_only_p99_ms: latency.ack_only_p99_ms,
+            alpha_window_p50_ms: latency.alpha_window_p50_ms,
+            alpha_window_p90_ms: latency.alpha_window_p90_ms,
+            alpha_window_p99_ms: latency.alpha_window_p99_ms,
+            alpha_window_hit_ratio: latency.alpha_window_hit_ratio,
+            alpha_window_n: latency.alpha_window_n,
+            strategy_uptime_pct: uptime_pct,
+            tick_to_ack_p99_ms: tick_to_ack_p99,
+            ref_ticks_total,
+            book_ticks_total,
+            ref_freshness_ms,
+            book_freshness_ms,
+            book_top_lag_p50_ms,
+            book_top_lag_p90_ms,
+            book_top_lag_p99_ms,
+            book_top_lag_by_symbol_p50_ms,
+            survival_10ms_by_symbol,
+            survival_probe_10ms_by_symbol,
+            blocked_reason_counts,
+            policy_block_reason_distribution,
+            gate_block_reason_distribution,
+            source_mix_ratio,
+            udp_share_effective,
+            udp_local_drop_count,
+            share_cap_drop_count,
+            fallback_state,
+            fallback_trigger_reason_distribution,
+            source_health: Vec::new(),
+            exit_reason_top,
+            edge_model_version: "unknown".to_string(),
+            latency,
+            market_scorecard: scorecard,
+            predator_c_enabled,
+            direction_signals_up,
+            direction_signals_down,
+            direction_signals_neutral,
+            taker_sniper_fired,
+            taker_sniper_skipped,
+            predator_regime_active,
+            predator_regime_quiet,
+            predator_regime_defend,
+            predator_cross_symbol_fired,
+            taker_sniper_skip_reasons_top: skip_top,
+            last_30s_taker_fallback_count,
+            router_locked_by_tf_usdc,
+            capital_available_usdc: capital.available_usdc,
+            capital_base_quote_size: capital.base_quote_size,
+            capital_halt,
+        };
+        live.gate_fail_reasons =
+            gate_eval::compute_gate_fail_reasons(&live, Self::GATE_MIN_OUTCOMES);
+        live.gate_ready_strict = live.window_outcomes >= Self::GATE_MIN_OUTCOMES;
+        live.gate_ready_effective =
+            live.gate_ready_strict || live.eligible_count > 0 || live.executed_count > 0;
+        live.gate_ready = live.gate_ready_strict;
+        live
+    }
+
+    pub(crate) async fn build_final_report(&self) -> ShadowFinalReport {
+        let live = self.build_live_report().await;
+        let failed = live.gate_fail_reasons.clone();
+
+        let gate = GateEvaluation {
+            window_id: live.window_id,
+            gate_ready: live.gate_ready_strict,
+            min_outcomes: Self::GATE_MIN_OUTCOMES,
+            pass: failed.is_empty(),
+            data_valid_ratio: live.data_valid_ratio,
+            seq_gap_rate: live.seq_gap_rate,
+            ts_inversion_rate: live.ts_inversion_rate,
+            stale_tick_drop_ratio: live.stale_tick_drop_ratio,
+            fillability_10ms: live.fillability_10ms,
+            net_edge_p50_bps: live.net_edge_p50_bps,
+            net_edge_p10_bps: live.net_edge_p10_bps,
+            net_markout_10s_usdc_p50: live.net_markout_10s_usdc_p50,
+            roi_notional_10s_bps_p50: live.roi_notional_10s_bps_p50,
+            pnl_10s_p50_bps_raw: live.pnl_10s_p50_bps_raw,
+            pnl_10s_p50_bps_robust: live.pnl_10s_p50_bps_robust,
+            pnl_10s_sample_count: live.pnl_10s_sample_count,
+            pnl_10s_outlier_ratio: live.pnl_10s_outlier_ratio,
+            eligible_count: live.eligible_count,
+            executed_count: live.executed_count,
+            executed_over_eligible: live.executed_over_eligible,
+            ev_net_usdc_p50: live.ev_net_usdc_p50,
+            ev_net_usdc_p10: live.ev_net_usdc_p10,
+            ev_positive_ratio: live.ev_positive_ratio,
+            quote_block_ratio: live.quote_block_ratio,
+            policy_block_ratio: live.policy_block_ratio,
+            gate_blocked: live.gate_blocked,
+            gate_block_ratio: live.gate_block_ratio,
+            strategy_uptime_pct: live.strategy_uptime_pct,
+            tick_to_ack_p99_ms: live.tick_to_ack_p99_ms,
+            decision_queue_wait_p99_ms: live.decision_queue_wait_p99_ms,
+            decision_compute_p99_ms: live.decision_compute_p99_ms,
+            source_latency_p99_ms: live.latency.source_latency_p99_ms,
+            exchange_lag_p99_ms: live.latency.exchange_lag_p99_ms,
+            path_lag_p99_ms: live.latency.path_lag_p99_ms,
+            local_backlog_p99_ms: live.latency.local_backlog_p99_ms,
+            failed_reasons: failed,
+        };
+        ShadowFinalReport { live, gate }
+    }
+
+    pub(crate) async fn build_engine_pnl_report(&self) -> EnginePnlReport {
+        const PRIMARY_DELAY_MS: u64 = 10;
+        let shots = self.shots.read().await.clone();
+        let outcomes = self.outcomes.read().await.clone();
+        let mut style_by_shot = HashMap::<String, ExecutionStyle>::new();
+        for shot in shots.iter().filter(|s| s.delay_ms == PRIMARY_DELAY_MS) {
+            style_by_shot.insert(shot.shot_id.clone(), shot.execution_style.clone());
+        }
+
+        let mut maker = Vec::<f64>::new();
+        let mut taker = Vec::<f64>::new();
+        let mut arb = Vec::<f64>::new();
+
+        for outcome in outcomes
+            .iter()
+            .filter(|o| o.delay_ms == PRIMARY_DELAY_MS && !o.is_stale_tick)
+        {
+            let Some(markout) = outcome.net_markout_10s_usdc else {
+                continue;
+            };
+            let style = style_by_shot
+                .get(&outcome.shot_id)
+                .cloned()
+                .unwrap_or_else(|| outcome.execution_style.clone());
+            match style {
+                ExecutionStyle::Maker => maker.push(markout),
+                ExecutionStyle::Taker => taker.push(markout),
+                ExecutionStyle::Arb => arb.push(markout),
+            }
+        }
+
+        let maker_total = maker.iter().sum::<f64>();
+        let taker_total = taker.iter().sum::<f64>();
+        let arb_total = arb.iter().sum::<f64>();
+
+        EnginePnlReport {
+            window_id: self.window_id.load(Ordering::Relaxed),
+            breakdown: EnginePnLBreakdown {
+                maker_usdc: maker_total,
+                taker_usdc: taker_total,
+                arb_usdc: arb_total,
+            },
+            rows: vec![
+                build_engine_pnl_row("maker", &maker),
+                build_engine_pnl_row("taker", &taker),
+                build_engine_pnl_row("arb", &arb),
+            ],
+        }
+    }
+}
+
+pub(crate) fn build_engine_pnl_row(engine: &str, values: &[f64]) -> EnginePnlRow {
+    let samples = values.len();
+    let total_usdc = values.iter().sum::<f64>();
+    let p50_usdc = percentile(values, 0.50).unwrap_or(0.0);
+    let p10_usdc = percentile(values, 0.10).unwrap_or(0.0);
+    let positive_ratio = if values.is_empty() {
+        0.0
+    } else {
+        values.iter().filter(|v| **v > 0.0).count() as f64 / values.len() as f64
+    };
+    EnginePnlRow {
+        engine: engine.to_string(),
+        samples,
+        total_usdc,
+        p50_usdc,
+        p10_usdc,
+        positive_ratio,
+    }
+}
diff --git a/crates/app_runner/src/stats_utils.rs b/crates/app_runner/src/stats_utils.rs
index d7ab368..67f6a22 100644
--- a/crates/app_runner/src/stats_utils.rs
+++ b/crates/app_runner/src/stats_utils.rs
@@ -1,4 +1,5 @@
 use chrono::Utc;
+use std::cmp::Ordering;
 use std::collections::VecDeque;
 
 pub fn push_capped<T>(dst: &mut Vec<T>, value: T, cap: usize) {
@@ -19,15 +20,20 @@ pub fn percentile(values: &[f64], p: f64) -> Option<f64> {
     v.get(idx).copied()
 }
 
-pub fn percentile_deque(values: &VecDeque<f64>, p: f64) -> Option<f64> {
+pub fn percentile_deque_capped(values: &VecDeque<f64>, p: f64, cap: usize) -> Option<f64> {
     if values.is_empty() {
         return None;
     }
-    // Avoid calling `percentile(&vec)` which would clone again internally.
-    let mut v: Vec<f64> = values.iter().copied().collect();
-    v.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
+    let n = values.len().min(cap.max(1));
+    if n == 0 {
+        return None;
+    }
+    // Most recent samples are more relevant; take from the back.
+    let mut v: Vec<f64> = values.iter().rev().take(n).copied().collect();
     let idx = ((v.len() as f64 - 1.0) * p.clamp(0.0, 1.0)).round() as usize;
-    v.get(idx).copied()
+    let (_, nth, _) =
+        v.select_nth_unstable_by(idx, |a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));
+    Some(*nth)
 }
 
 pub fn robust_filter_iqr(values: &[f64]) -> (Vec<f64>, f64) {
diff --git a/crates/app_runner/src/strategy_policy.rs b/crates/app_runner/src/strategy_policy.rs
new file mode 100644
index 0000000..d76e6ad
--- /dev/null
+++ b/crates/app_runner/src/strategy_policy.rs
@@ -0,0 +1,447 @@
+use std::collections::HashMap;
+use std::sync::Arc;
+use std::sync::OnceLock;
+
+use core_types::{
+    BookTop, InventoryState, OrderSide, ShadowShot, TimeframeClass, ToxicDecision, ToxicFeatures,
+    ToxicRegime,
+};
+use portfolio::PortfolioBook;
+use risk_engine::RiskLimits;
+use strategy_maker::MakerConfig;
+
+use crate::state::{EdgeModelConfig, EngineShared, MarketToxicState, ToxicityConfig};
+use crate::stats_utils::{now_ns, percentile, percentile_deque_capped};
+
+pub(super) fn inventory_for_market(portfolio: &PortfolioBook, market_id: &str) -> InventoryState {
+    let positions = portfolio.positions();
+    if let Some(pos) = positions.get(market_id) {
+        InventoryState {
+            market_id: market_id.to_string(),
+            net_yes: pos.yes,
+            net_no: pos.no,
+            exposure_notional: pos.yes.abs() + pos.no.abs(),
+        }
+    } else {
+        InventoryState {
+            market_id: market_id.to_string(),
+            net_yes: 0.0,
+            net_no: 0.0,
+            exposure_notional: 0.0,
+        }
+    }
+}
+pub(super) fn build_toxic_features(
+    book: &BookTop,
+    symbol: &str,
+    stale_ms: f64,
+    fair_yes: f64,
+    attempted: u64,
+    no_quote: u64,
+    markout_1s_p50: f64,
+    markout_5s_p50: f64,
+    markout_10s_p50: f64,
+) -> ToxicFeatures {
+    let mid_yes = ((book.bid_yes + book.ask_yes) * 0.5).max(0.0001);
+    let spread_bps = ((book.ask_yes - book.bid_yes).max(0.0) / mid_yes) * 10_000.0;
+    let microprice_drift = fair_yes - mid_yes;
+    let imbalance_den = (book.bid_yes + book.ask_yes + book.bid_no + book.ask_no).abs();
+    let imbalance = if imbalance_den <= 1e-12 {
+        0.0
+    } else {
+        ((book.bid_yes + book.ask_no) - (book.ask_yes + book.bid_no)) / imbalance_den
+    };
+    let attempted = attempted.max(1);
+    let cancel_burst = (no_quote as f64 / attempted as f64).clamp(0.0, 1.0);
+
+    ToxicFeatures {
+        market_id: book.market_id.clone(),
+        symbol: symbol.to_string(),
+        markout_1s: markout_1s_p50,
+        markout_5s: markout_5s_p50,
+        markout_10s: markout_10s_p50,
+        spread_bps,
+        microprice_drift,
+        stale_ms,
+        imbalance,
+        cancel_burst,
+        ts_ns: now_ns(),
+    }
+}
+
+pub(super) fn evaluate_toxicity(features: &ToxicFeatures, cfg: &ToxicityConfig) -> ToxicDecision {
+    let neg_markout_1s = (-features.markout_1s).max(0.0) / 20.0;
+    let neg_markout_5s = (-features.markout_5s).max(0.0) / 20.0;
+    let neg_markout_10s = (-features.markout_10s).max(0.0) / 20.0;
+    let spread_z = features.spread_bps / 50.0;
+    let microprice_drift_z = (features.microprice_drift.abs() * 10_000.0) / 20.0;
+    let stale_z = features.stale_ms / 1_500.0;
+    let raw = cfg.w1 * neg_markout_1s
+        + cfg.w2 * neg_markout_5s
+        + cfg.w3 * neg_markout_10s
+        + cfg.w4 * spread_z
+        + cfg.w5 * microprice_drift_z
+        + cfg.w6 * stale_z;
+    let markout_1s_danger = features.markout_1s <= cfg.markout_1s_danger_bps;
+    let markout_5s_danger = features.markout_5s <= cfg.markout_5s_danger_bps;
+    let markout_10s_danger = features.markout_10s <= cfg.markout_10s_danger_bps;
+    let markout_1s_caution = features.markout_1s <= cfg.markout_1s_caution_bps;
+    let markout_5s_caution = features.markout_5s <= cfg.markout_5s_caution_bps;
+    let markout_10s_caution = features.markout_10s <= cfg.markout_10s_caution_bps;
+
+    let mut horizon_boost = 0.0;
+    if markout_1s_danger {
+        horizon_boost += 0.30;
+    } else if markout_1s_caution {
+        horizon_boost += 0.15;
+    }
+    if markout_5s_danger {
+        horizon_boost += 0.25;
+    } else if markout_5s_caution {
+        horizon_boost += 0.12;
+    }
+    if markout_10s_danger {
+        horizon_boost += 0.20;
+    } else if markout_10s_caution {
+        horizon_boost += 0.10;
+    }
+    let tox_score = (sigmoid(raw) + horizon_boost).clamp(0.0, 1.0);
+
+    let mut reasons = Vec::new();
+    if markout_1s_danger {
+        reasons.push("markout_1s_danger".to_string());
+    } else if markout_1s_caution {
+        reasons.push("markout_1s_caution".to_string());
+    } else if features.markout_1s < 0.0 {
+        reasons.push("markout_1s_negative".to_string());
+    }
+    if markout_5s_danger {
+        reasons.push("markout_5s_danger".to_string());
+    } else if markout_5s_caution {
+        reasons.push("markout_5s_caution".to_string());
+    } else if features.markout_5s < 0.0 {
+        reasons.push("markout_5s_negative".to_string());
+    }
+    if markout_10s_danger {
+        reasons.push("markout_10s_danger".to_string());
+    } else if markout_10s_caution {
+        reasons.push("markout_10s_caution".to_string());
+    } else if features.markout_10s < 0.0 {
+        reasons.push("markout_10s_negative".to_string());
+    }
+    if features.spread_bps > 60.0 {
+        reasons.push("spread_wide".to_string());
+    }
+    if features.stale_ms > 1_500.0 {
+        reasons.push("stale_feed".to_string());
+    }
+    if reasons.is_empty() {
+        reasons.push("normal".to_string());
+    }
+
+    let regime = if markout_1s_danger || markout_5s_danger || markout_10s_danger {
+        ToxicRegime::Danger
+    } else if markout_1s_caution || markout_5s_caution || markout_10s_caution {
+        ToxicRegime::Caution
+    } else if tox_score >= cfg.caution_threshold {
+        ToxicRegime::Danger
+    } else if tox_score >= cfg.safe_threshold {
+        ToxicRegime::Caution
+    } else {
+        ToxicRegime::Safe
+    };
+
+    ToxicDecision {
+        market_id: features.market_id.clone(),
+        symbol: features.symbol.clone(),
+        tox_score,
+        regime,
+        reason_codes: reasons,
+        ts_ns: now_ns(),
+    }
+}
+
+pub(super) fn compute_market_score(
+    state: &MarketToxicState,
+    tox_score: f64,
+    markout_samples: usize,
+) -> f64 {
+    let attempted = state.attempted.max(1);
+    let no_quote_rate = state.no_quote as f64 / attempted as f64;
+    let symbol_missing_rate = state.symbol_missing as f64 / attempted as f64;
+    let markout_10s = percentile_deque_capped(&state.markout_10s, 0.50, 2048).unwrap_or(0.0);
+    if markout_samples < 20 {
+        let warmup_score = 80.0 - no_quote_rate * 6.0 - symbol_missing_rate * 6.0;
+        return warmup_score.clamp(45.0, 100.0);
+    }
+    let score = 70.0 + (markout_10s * 1.5).clamp(-30.0, 30.0)
+        - no_quote_rate * 25.0
+        - symbol_missing_rate * 30.0
+        - tox_score * 20.0;
+    score.clamp(0.0, 100.0)
+}
+
+pub(super) fn compute_market_score_from_snapshot(
+    attempted: u64,
+    no_quote: u64,
+    symbol_missing: u64,
+    tox_score: f64,
+    markout_samples: usize,
+    markout_10s_p50: f64,
+) -> f64 {
+    let attempted = attempted.max(1);
+    let no_quote_rate = no_quote as f64 / attempted as f64;
+    let symbol_missing_rate = symbol_missing as f64 / attempted as f64;
+    if markout_samples < 20 {
+        let warmup_score = 80.0 - no_quote_rate * 6.0 - symbol_missing_rate * 6.0;
+        return warmup_score.clamp(45.0, 100.0);
+    }
+    let score = 70.0 + (markout_10s_p50 * 1.5).clamp(-30.0, 30.0)
+        - no_quote_rate * 25.0
+        - symbol_missing_rate * 30.0
+        - tox_score * 20.0;
+    score.clamp(0.0, 100.0)
+}
+
+pub(super) fn non_risk_gate_relax_ratio() -> f64 {
+    static RELAX_RATIO: OnceLock<f64> = OnceLock::new();
+    *RELAX_RATIO.get_or_init(|| {
+        std::env::var("POLYEDGE_NON_RISK_GATE_RELAX_RATIO")
+            .ok()
+            .and_then(|v| v.parse::<f64>().ok())
+            .unwrap_or(0.85)
+            .clamp(0.50, 1.0)
+    })
+}
+
+pub(super) fn edge_gate_bps(
+    cfg: &EdgeModelConfig,
+    tox_score: f64,
+    local_backlog_ms: f64,
+    source_latency_ms: f64,
+    no_quote_rate: f64,
+) -> f64 {
+    if !cfg.gate_mode.eq_ignore_ascii_case("dynamic") {
+        return cfg.base_gate_bps.max(0.0);
+    }
+    let congestion = cfg.congestion_penalty_bps * no_quote_rate.clamp(0.0, 1.0);
+    let latency = cfg.latency_penalty_bps
+        * ((local_backlog_ms / 100.0).clamp(0.0, 1.0)
+            + (source_latency_ms / 800.0).clamp(0.0, 1.0));
+    let tox = cfg.fail_cost_bps * tox_score.clamp(0.0, 1.0);
+    (cfg.base_gate_bps + congestion + latency + tox).max(0.0)
+}
+
+pub(super) fn adaptive_max_spread(
+    base_max_spread: f64,
+    tox_score: f64,
+    markout_samples: usize,
+) -> f64 {
+    let relax_ratio = non_risk_gate_relax_ratio();
+    if markout_samples < 20 {
+        return (base_max_spread * (1.2 + (1.0 - relax_ratio) * 0.5)).clamp(0.003, 0.08);
+    }
+    (base_max_spread * (1.0 - tox_score * 0.35 + (1.0 - relax_ratio) * 0.2))
+        .clamp(0.002, base_max_spread * 1.15)
+}
+
+pub(super) async fn timeframe_weight(
+    shared: &Arc<EngineShared>,
+    timeframe: &TimeframeClass,
+) -> f64 {
+    let baseline = match timeframe {
+        TimeframeClass::Tf5m | TimeframeClass::Tf15m => 1.0,
+        TimeframeClass::Tf1h => 0.35,
+        TimeframeClass::Tf1d => 0.20,
+    };
+    if matches!(timeframe, TimeframeClass::Tf5m | TimeframeClass::Tf15m) {
+        return baseline;
+    }
+
+    let outcomes = shared.shadow_stats.outcomes.read().await;
+    if outcomes.is_empty() {
+        return baseline;
+    }
+    let market_tf = shared.market_to_timeframe.read().await;
+    let mut markouts = Vec::new();
+    for o in outcomes.iter().rev() {
+        if o.delay_ms != 10 || !o.fillable {
+            continue;
+        }
+        let Some(tf) = market_tf.get(&o.market_id) else {
+            continue;
+        };
+        if tf != timeframe {
+            continue;
+        }
+        if let Some(v) = o.net_markout_10s_bps {
+            markouts.push(v);
+        }
+        if markouts.len() >= 200 {
+            break;
+        }
+    }
+
+    if markouts.len() < 30 {
+        return baseline;
+    }
+    let p50 = percentile(&markouts, 0.50).unwrap_or(0.0);
+    if p50 <= -8.0 {
+        0.05
+    } else if p50 <= -2.0 {
+        0.12
+    } else if p50 <= 0.0 {
+        0.20
+    } else if p50 <= 3.0 {
+        baseline
+    } else {
+        (baseline * 1.4).clamp(0.0, 1.0)
+    }
+}
+
+pub(super) fn should_observe_only_symbol(
+    symbol: &str,
+    cfg: &MakerConfig,
+    tox: &ToxicDecision,
+    stale_ms: f64,
+    spread_yes: f64,
+    book_top_lag_ms: f64,
+) -> bool {
+    if !symbol.eq_ignore_ascii_case("SOLUSDT") {
+        return false;
+    }
+    let profile = cfg.market_tier_profile.to_ascii_lowercase();
+    if !(profile.contains("sol_guard") || profile.contains("balanced")) {
+        return false;
+    }
+
+    // Keep SOL observe-only unless the local "ref lead vs book" lag is within a tight bound.
+    // This avoids letting one slow/volatile venue degrade the overall engine quality.
+    let relax = (1.0 - non_risk_gate_relax_ratio()).clamp(0.0, 0.5);
+    let lag_guard_ms = 130.0 + 80.0 * relax;
+    let stale_guard_ms = 250.0 + 120.0 * relax;
+    let spread_guard = 0.020 + 0.006 * relax;
+    book_top_lag_ms > lag_guard_ms
+        || matches!(tox.regime, ToxicRegime::Danger)
+        || stale_ms > stale_guard_ms
+        || spread_yes > spread_guard
+}
+
+pub(super) fn estimate_queue_fill_proxy(tox_score: f64, spread_yes: f64, stale_ms: f64) -> f64 {
+    let spread_pen = (spread_yes / 0.03).clamp(0.0, 1.0);
+    let latency_pen = (stale_ms / 800.0).clamp(0.0, 1.0);
+    (1.0 - (tox_score * 0.45 + spread_pen * 0.35 + latency_pen * 0.20)).clamp(0.0, 1.0)
+}
+
+pub(super) fn estimate_queue_fill_prob(shot: &ShadowShot, book: &BookTop, latency_ms: f64) -> f64 {
+    let spread = match shot.side {
+        OrderSide::BuyYes | OrderSide::SellYes => (book.ask_yes - book.bid_yes).max(0.0),
+        OrderSide::BuyNo | OrderSide::SellNo => (book.ask_no - book.bid_no).max(0.0),
+    };
+    let spread_pen = (spread / 0.03).clamp(0.0, 1.0);
+    // P3: Ë∞ÉÊï¥ delay_pen ÂàÜÊØç‰ªé 25 Âà∞ 50ÔºåÂáèÂ∞ëÂª∂ËøüÊÉ©ÁΩöÊùÉÈáç
+    let delay_pen = (shot.delay_ms as f64 / 50.0).clamp(0.0, 1.0);
+    let latency_pen = (latency_ms / 100.0).clamp(0.0, 1.0);
+    (1.0 - (shot.tox_score * 0.35 + spread_pen * 0.30 + delay_pen * 0.20 + latency_pen * 0.15))
+        .clamp(0.0, 1.0)
+}
+
+pub(super) fn is_market_in_top_n(
+    states: &HashMap<String, MarketToxicState>,
+    market_id: &str,
+    top_n: usize,
+) -> bool {
+    if top_n == 0 {
+        return true;
+    }
+    if states.is_empty() {
+        return true;
+    }
+    let Some(target) = states.get(market_id) else {
+        return false;
+    };
+    let target_score = target.market_score;
+
+    // O(n) rank check without heap allocations/sorting.
+    let better = states
+        .iter()
+        .filter(|(id, st)| {
+            st.market_score > target_score
+                || (st.market_score == target_score && id.as_str() < market_id)
+        })
+        .count();
+    better < top_n.max(1)
+}
+
+pub(super) fn cooldown_secs_for_score(tox_score: f64, cfg: &ToxicityConfig) -> u64 {
+    let t = tox_score.clamp(0.0, 1.0);
+    ((cfg.cooldown_min_sec as f64)
+        + ((cfg.cooldown_max_sec as f64) - (cfg.cooldown_min_sec as f64)) * t)
+        .round() as u64
+}
+
+pub(super) fn adaptive_size_scale(
+    drawdown_pct: f64,
+    market_notional: f64,
+    asset_notional: f64,
+    limits: &RiskLimits,
+    tox_score: f64,
+    tox_regime: &ToxicRegime,
+) -> f64 {
+    let dd_cap = limits.max_drawdown_pct.abs().max(0.01);
+    let dd_ratio = (drawdown_pct.abs() / dd_cap).clamp(0.0, 1.0);
+    let drawdown_scale = (1.0 - 0.75 * dd_ratio).clamp(0.25, 1.0);
+
+    let market_util = if limits.max_market_notional > 0.0 {
+        (market_notional.max(0.0) / limits.max_market_notional).clamp(0.0, 2.0)
+    } else {
+        1.0
+    };
+    let asset_util = if limits.max_asset_notional > 0.0 {
+        (asset_notional.max(0.0) / limits.max_asset_notional).clamp(0.0, 2.0)
+    } else {
+        1.0
+    };
+    let util = market_util.max(asset_util);
+    let exposure_scale = (1.0 - 0.80 * util).clamp(0.20, 1.0);
+
+    let regime_scale = match tox_regime {
+        ToxicRegime::Safe => 1.0,
+        ToxicRegime::Caution => 0.70,
+        ToxicRegime::Danger => 0.40,
+    };
+    let tox_scale = (regime_scale * (1.0 - 0.35 * tox_score.clamp(0.0, 1.0))).clamp(0.20, 1.0);
+
+    (drawdown_scale * exposure_scale * tox_scale).clamp(0.05, 1.0)
+}
+
+pub(super) fn net_markout(markout_bps: Option<f64>, shot: &ShadowShot) -> Option<f64> {
+    markout_bps.map(|v| v - shot.fee_paid_bps + shot.rebate_est_bps)
+}
+
+pub(super) fn estimate_entry_notional_usdc(shot: &ShadowShot) -> f64 {
+    (shot.intended_price.max(0.0) * shot.size.max(0.0)).max(0.0)
+}
+
+pub(super) fn bps_to_usdc(bps: Option<f64>, notional_usdc: f64) -> Option<f64> {
+    if notional_usdc <= 0.0 {
+        return None;
+    }
+    bps.map(|v| (v / 10_000.0) * notional_usdc)
+}
+
+pub(super) fn roi_bps_from_usdc(markout_usdc: Option<f64>, notional_usdc: f64) -> Option<f64> {
+    if notional_usdc <= 0.0 {
+        return None;
+    }
+    markout_usdc.map(|v| (v / notional_usdc) * 10_000.0)
+}
+
+pub(super) fn sigmoid(x: f64) -> f64 {
+    if x >= 0.0 {
+        1.0 / (1.0 + (-x).exp())
+    } else {
+        let ex = x.exp();
+        ex / (1.0 + ex)
+    }
+}
diff --git a/crates/app_runner/src/strategy_runtime.rs b/crates/app_runner/src/strategy_runtime.rs
new file mode 100644
index 0000000..237bb1c
--- /dev/null
+++ b/crates/app_runner/src/strategy_runtime.rs
@@ -0,0 +1,1950 @@
+use std::collections::HashMap;
+use std::sync::Arc;
+use std::time::{Duration, Instant};
+
+use core_types::{
+    new_id, BookTop, Direction, DirectionSignal, EngineEvent, ExecutionStyle, ExecutionVenue,
+    OrderAck, OrderIntentV2, OrderSide, OrderTimeInForce, PaperAction, QuoteIntent, Regime,
+    RiskContext, RiskManager, ShadowShot, SourceHealth, Stage, TimeframeClass, TimeframeOpp,
+    ToxicRegime,
+};
+use execution_clob::ClobExecution;
+use exit_manager::PositionLifecycle;
+use infra_bus::RingBus;
+use paper_executor::ShadowExecutor;
+use portfolio::PortfolioBook;
+use risk_engine::RiskLimits;
+use strategy_maker::MakerConfig;
+use taker_sniper::{FirePlan, TakerAction};
+
+use crate::engine_core::{classify_execution_error_reason, normalize_reject_code};
+use crate::paper_runtime::{global_paper_runtime, PaperIntentCtx};
+use crate::execution_eval::{
+    aggressive_price_for_side, edge_gross_bps_for_side, get_fee_rate_bps_cached,
+    get_rebate_bps_cached, mid_for_side, prebuild_order_payload, spread_for_side,
+};
+use crate::feed_runtime::settlement_prob_yes_for_symbol;
+use crate::fusion_engine::TokenBucket;
+use crate::state::{
+    EngineShared, PredatorCConfig, PredatorCPriority, PredatorRegimeConfig, SourceHealthConfig,
+    V52DualArbConfig, V52ExecutionConfig, V52TimePhaseConfig,
+};
+use crate::stats_utils::{freshness_ms, now_ns};
+use crate::strategy_policy::{
+    adaptive_size_scale, edge_gate_bps, inventory_for_market, timeframe_weight,
+};
+use crate::{
+    publish_if_telemetry_subscribers, spawn_predator_exit_lifecycle, spawn_detached,
+    spawn_shadow_outcome_task, PredatorExecResult,
+};
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub(crate) enum TimePhase {
+    Early,
+    Maturity,
+    Late,
+}
+
+pub(crate) fn timeframe_total_ms(timeframe: TimeframeClass) -> Option<i64> {
+    match timeframe {
+        TimeframeClass::Tf5m => Some(300_000),
+        TimeframeClass::Tf15m => Some(900_000),
+        _ => None,
+    }
+}
+
+fn timeframe_tag(timeframe: TimeframeClass) -> &'static str {
+    match timeframe {
+        TimeframeClass::Tf5m => "5m",
+        TimeframeClass::Tf15m => "15m",
+        TimeframeClass::Tf1h => "1h",
+        TimeframeClass::Tf1d => "1d",
+    }
+}
+
+pub(crate) fn classify_time_phase(remaining_ratio: f64, cfg: &V52TimePhaseConfig) -> TimePhase {
+    if remaining_ratio <= cfg.late_max_ratio {
+        TimePhase::Late
+    } else if remaining_ratio <= cfg.early_min_ratio {
+        TimePhase::Maturity
+    } else {
+        TimePhase::Early
+    }
+}
+
+pub(crate) fn time_phase_size_scale(phase: TimePhase, cfg: &V52TimePhaseConfig) -> f64 {
+    let scale = match phase {
+        TimePhase::Early => cfg.early_size_scale,
+        TimePhase::Maturity => cfg.maturity_size_scale,
+        TimePhase::Late => cfg.late_size_scale,
+    };
+    scale.clamp(0.10, 5.0)
+}
+
+pub(crate) fn stage_for_phase(phase: TimePhase, momentum: bool) -> Stage {
+    match phase {
+        TimePhase::Early => Stage::Early,
+        TimePhase::Late => Stage::Late,
+        TimePhase::Maturity => {
+            if momentum {
+                Stage::Momentum
+            } else {
+                Stage::Maturity
+            }
+        }
+    }
+}
+
+pub(crate) fn allow_dual_side_arb(
+    yes_price: f64,
+    no_price: f64,
+    fee_rate_bps: f64,
+    cfg: &V52DualArbConfig,
+) -> bool {
+    if !cfg.enabled {
+        return false;
+    }
+    let fee_buffer = (fee_rate_bps.max(0.0) / 10_000.0).max(0.0);
+    let safety_margin = (cfg.safety_margin_bps.max(0.0) / 10_000.0).max(0.0);
+    yes_price + no_price + fee_buffer + safety_margin < cfg.threshold
+}
+
+fn side_to_direction(side: &OrderSide) -> Direction {
+    match side {
+        OrderSide::BuyYes | OrderSide::SellNo => Direction::Up,
+        OrderSide::BuyNo | OrderSide::SellYes => Direction::Down,
+    }
+}
+
+fn direction_signal_for_side(base: &DirectionSignal, side: &OrderSide) -> DirectionSignal {
+    let mut out = base.clone();
+    out.direction = side_to_direction(side);
+    out
+}
+
+pub(crate) fn should_force_taker_fallback(
+    phase: TimePhase,
+    time_to_expiry_ms: i64,
+    cfg: &V52ExecutionConfig,
+) -> bool {
+    let force_in_phase = match phase {
+        TimePhase::Early => false,
+        TimePhase::Maturity => cfg.apply_force_taker_in_maturity,
+        TimePhase::Late => cfg.apply_force_taker_in_late,
+    };
+    force_in_phase && time_to_expiry_ms <= cfg.late_force_taker_remaining_ms as i64
+}
+
+fn spawn_force_taker_fallback_for_maker(
+    shared: Arc<EngineShared>,
+    execution: Arc<ClobExecution>,
+    shadow: Arc<ShadowExecutor>,
+    market_id: String,
+    token_id: String,
+    side: OrderSide,
+    size: f64,
+    ttl_ms: u64,
+    maker_order_id: String,
+    fee_rate_bps: f64,
+    expected_edge_net_bps: f64,
+    timeframe: TimeframeClass,
+    force_remaining_ms: u64,
+    maker_wait_ms: u64,
+    taker_max_slippage_bps: f64,
+) {
+    spawn_detached("v52_force_taker_fallback", false, async move {
+        if maker_wait_ms > 0 {
+            tokio::time::sleep(Duration::from_millis(maker_wait_ms)).await;
+        }
+        let Some(frame_total_ms) = timeframe_total_ms(timeframe) else {
+            return;
+        };
+        let threshold = force_remaining_ms as i64;
+        loop {
+            if !execution.has_open_order(&maker_order_id) {
+                return;
+            }
+            let now_ms = chrono::Utc::now().timestamp_millis();
+            let remain_ms = (frame_total_ms - now_ms.rem_euclid(frame_total_ms)).max(0);
+            if remain_ms <= threshold {
+                break;
+            }
+            let sleep_ms = (remain_ms - threshold).clamp(25, 250) as u64;
+            tokio::time::sleep(Duration::from_millis(sleep_ms)).await;
+        }
+        if !execution.has_open_order(&maker_order_id) {
+            return;
+        }
+        if execution.cancel_order(&maker_order_id, &market_id).await.is_err() {
+            return;
+        }
+        shadow.cancel(&maker_order_id);
+        let book = shared.latest_books.read().await.get(&market_id).cloned();
+        let Some(book) = book else {
+            return;
+        };
+        let taker_price = aggressive_price_for_side(&book, &side);
+        if !taker_price.is_finite() || taker_price <= 0.0 {
+            return;
+        }
+        let order = OrderIntentV2 {
+            market_id: market_id.clone(),
+            token_id: Some(token_id),
+            side: side.clone(),
+            price: taker_price,
+            size: size.max(0.01),
+            ttl_ms: ttl_ms.min(150),
+            style: ExecutionStyle::Taker,
+            tif: OrderTimeInForce::Fak,
+            max_slippage_bps: taker_max_slippage_bps.max(0.0),
+            fee_rate_bps,
+            expected_edge_net_bps,
+            client_order_id: Some(new_id()),
+            hold_to_resolution: false,
+            prebuilt_payload: None,
+        };
+        match execution.place_order_v2(order).await {
+            Ok(ack) if ack.accepted => {
+                shared.shadow_stats.mark_predator_last_30s_taker_fallback();
+                shared.shadow_stats.mark_executed();
+                let ack_event = OrderAck {
+                    order_id: ack.order_id,
+                    market_id: ack.market_id,
+                    accepted: true,
+                    ts_ms: ack.ts_ms,
+                };
+                shadow.register_order(
+                    &ack_event,
+                    QuoteIntent {
+                        market_id,
+                        side,
+                        price: taker_price,
+                        size: size.max(0.01),
+                        ttl_ms: ttl_ms.min(150),
+                    },
+                    ExecutionStyle::Taker,
+                    ((book.bid_yes + book.ask_yes) * 0.5).max(0.0),
+                    fee_rate_bps.max(0.0),
+                );
+            }
+            _ => {}
+        }
+    });
+}
+
+fn spawn_alpha_window_probe(
+    shared: Arc<EngineShared>,
+    market_id: String,
+    side: OrderSide,
+    anchor_price: f64,
+    move_bps: f64,
+    poll_ms: u64,
+    max_wait_ms: u64,
+) {
+    if !anchor_price.is_finite() || anchor_price <= 0.0 {
+        return;
+    }
+    let move_abs = (anchor_price * (move_bps.max(0.0) / 10_000.0)).max(1e-6);
+    let poll_ms = poll_ms.clamp(1, 200);
+    let max_wait_ms = max_wait_ms.clamp(50, 5_000);
+
+    spawn_detached("v52_alpha_window_probe", false, async move {
+        let started = Instant::now();
+        loop {
+            let elapsed_ms = started.elapsed().as_secs_f64() * 1_000.0;
+            let current_price = shared
+                .latest_books
+                .read()
+                .await
+                .get(&market_id)
+                .map(|book| aggressive_price_for_side(book, &side))
+                .unwrap_or(0.0);
+            if current_price.is_finite() && current_price > 0.0 {
+                let delta = (current_price - anchor_price).abs();
+                if delta >= move_abs {
+                    shared
+                        .shadow_stats
+                        .push_alpha_window_sample(elapsed_ms, true)
+                        .await;
+                    metrics::histogram!("latency.alpha_window_ms").record(elapsed_ms);
+                    return;
+                }
+            }
+            if elapsed_ms >= max_wait_ms as f64 {
+                let capped = max_wait_ms as f64;
+                shared
+                    .shadow_stats
+                    .push_alpha_window_sample(capped, false)
+                    .await;
+                metrics::histogram!("latency.alpha_window_ms").record(capped);
+                return;
+            }
+            tokio::time::sleep(Duration::from_millis(poll_ms)).await;
+        }
+    });
+}
+
+pub(super) async fn evaluate_and_route_v52(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    predator_cfg: &PredatorCConfig,
+    symbol: &str,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+    direction_override: Option<DirectionSignal>,
+) -> PredatorExecResult {
+    let mut total = run_predator_c_for_symbol(
+        shared,
+        bus,
+        portfolio,
+        execution,
+        shadow,
+        market_rate_budget,
+        global_rate_budget,
+        predator_cfg,
+        symbol,
+        tick_fast_recv_ts_ms,
+        tick_fast_recv_ts_local_ns,
+        now_ms,
+        direction_override.clone(),
+    )
+    .await;
+
+    let leader_direction = if let Some(sig) = direction_override {
+        Some(sig)
+    } else {
+        shared
+            .predator_latest_direction
+            .read()
+            .await
+            .get(symbol)
+            .cloned()
+    };
+    if let Some(leader_direction) = leader_direction {
+        let cross_res = run_predator_c_cross_symbol(
+            shared,
+            bus,
+            portfolio,
+            execution,
+            shadow,
+            market_rate_budget,
+            global_rate_budget,
+            predator_cfg,
+            &leader_direction,
+            tick_fast_recv_ts_ms,
+            tick_fast_recv_ts_local_ns,
+            now_ms,
+        )
+        .await;
+        total.attempted = total.attempted.saturating_add(cross_res.attempted);
+        total.executed = total.executed.saturating_add(cross_res.executed);
+    }
+    if predator_cfg.strategy_d.enabled {
+        let d_res = run_predator_d_for_symbol(
+            shared,
+            bus,
+            portfolio,
+            execution,
+            shadow,
+            market_rate_budget,
+            global_rate_budget,
+            predator_cfg,
+            symbol,
+            tick_fast_recv_ts_ms,
+            tick_fast_recv_ts_local_ns,
+            now_ms,
+        )
+        .await;
+        total.attempted = total.attempted.saturating_add(d_res.attempted);
+        total.executed = total.executed.saturating_add(d_res.executed);
+    }
+    total
+}
+
+pub(super) async fn run_predator_c_for_symbol(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    predator_cfg: &PredatorCConfig,
+    symbol: &str,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+    direction_override: Option<DirectionSignal>,
+) -> PredatorExecResult {
+    shared
+        .shadow_stats
+        .set_predator_enabled(predator_cfg.enabled);
+    if !predator_cfg.enabled {
+        return PredatorExecResult::default();
+    }
+    let live_armed = std::env::var("POLYEDGE_LIVE_ARMED")
+        .ok()
+        .map(|v| v.eq_ignore_ascii_case("true") || v == "1")
+        .unwrap_or(false);
+    if live_armed
+        && predator_cfg.v52.execution.require_compounder_when_live
+        && !predator_cfg.compounder.enabled
+    {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("compounder_required_when_live")
+            .await;
+        return PredatorExecResult::default();
+    }
+    let source_health_cfg = shared.source_health_cfg.read().await.clone();
+    let primary_fast_source = shared
+        .latest_fast_ticks
+        .get(symbol)
+        .map(|tick| tick.source.clone());
+    let primary_source_health = {
+        let map = shared.source_health_latest.read().await;
+        let from_fast = primary_fast_source
+            .as_ref()
+            .and_then(|source| map.get(source.as_str()).cloned());
+        let best_binance = map
+            .values()
+            .filter(|h| h.source.to_ascii_lowercase().contains("binance"))
+            .max_by(|a, b| {
+                a.score
+                    .partial_cmp(&b.score)
+                    .unwrap_or(std::cmp::Ordering::Equal)
+            })
+            .cloned();
+        match (from_fast, best_binance) {
+            (Some(a), Some(b)) => Some(if b.score > a.score { b } else { a }),
+            (Some(a), None) => Some(a),
+            (None, Some(b)) => Some(b),
+            (None, None) => None,
+        }
+    };
+
+    let direction_signal = if let Some(sig) = direction_override {
+        sig
+    } else {
+        let mut direction_signal = {
+            let det = shared.predator_direction_detector.read().await;
+            det.evaluate(symbol, now_ms)
+        };
+        if direction_signal.is_none() {
+            let fallback_signal = shared
+                .predator_latest_direction
+                .read()
+                .await
+                .get(symbol)
+                .cloned();
+            if let Some(cached) = fallback_signal {
+                let cached_ms = cached.ts_ns.div_euclid(1_000_000);
+                let age_ms = now_ms.saturating_sub(cached_ms);
+                if age_ms <= 2_500 {
+                    direction_signal = Some(cached);
+                }
+            }
+        }
+        let Some(direction_signal) = direction_signal else {
+            shared
+                .shadow_stats
+                .mark_predator_taker_skipped("no_direction_signal")
+                .await;
+            return PredatorExecResult::default();
+        };
+        direction_signal
+    };
+
+    shared
+        .shadow_stats
+        .mark_predator_direction(&direction_signal.direction);
+    {
+        let mut map = shared.predator_latest_direction.write().await;
+        map.insert(symbol.to_string(), direction_signal.clone());
+    }
+    publish_if_telemetry_subscribers(bus, EngineEvent::DirectionSignal(direction_signal.clone()));
+
+    if matches!(direction_signal.direction, Direction::Neutral) {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped("neutral_direction")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    let market_ids = shared
+        .symbol_to_markets
+        .read()
+        .await
+        .get(symbol)
+        .cloned()
+        .unwrap_or_default();
+    if market_ids.is_empty() {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped("no_symbol_markets")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    let (symbol_tox_score, symbol_tox_regime) = symbol_toxic_snapshot(shared, &market_ids).await;
+    let regime = classify_predator_regime(
+        &predator_cfg.regime,
+        &direction_signal,
+        symbol_tox_score,
+        &symbol_tox_regime,
+        primary_source_health.as_ref(),
+        &source_health_cfg,
+    );
+    shared.shadow_stats.mark_predator_regime(&regime);
+    if matches!(regime, Regime::Defend) {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped("predator_regime_defend")
+            .await;
+        return PredatorExecResult::default();
+    }
+    if matches!(regime, Regime::Quiet)
+        && matches!(predator_cfg.priority, PredatorCPriority::MakerFirst)
+    {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped("predator_regime_quiet")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    let maker_cfg = shared.strategy_cfg.read().await.clone();
+    let edge_model_cfg = shared.edge_model_cfg.read().await.clone();
+    let tf_weights = HashMap::from([
+        (
+            TimeframeClass::Tf5m,
+            timeframe_weight(shared, &TimeframeClass::Tf5m).await,
+        ),
+        (
+            TimeframeClass::Tf15m,
+            timeframe_weight(shared, &TimeframeClass::Tf15m).await,
+        ),
+        (
+            TimeframeClass::Tf1h,
+            timeframe_weight(shared, &TimeframeClass::Tf1h).await,
+        ),
+        (
+            TimeframeClass::Tf1d,
+            timeframe_weight(shared, &TimeframeClass::Tf1d).await,
+        ),
+    ]);
+
+    let static_quote_notional_usdc = (predator_cfg.compounder.initial_capital_usdc.max(0.0)
+        * predator_cfg.compounder.position_fraction.clamp(0.0, 1.0))
+    .max(predator_cfg.compounder.min_quote_size.max(0.01));
+    let (quote_notional_usdc, total_capital_usdc) = if predator_cfg.compounder.enabled {
+        let c = shared.predator_compounder.read().await;
+        (c.recommended_quote_notional_usdc(), c.available())
+    } else {
+        (
+            static_quote_notional_usdc,
+            predator_cfg.compounder.initial_capital_usdc.max(0.0),
+        )
+    };
+
+    #[derive(Debug, Clone)]
+    struct PredatorCandIn {
+        market_id: String,
+        timeframe: TimeframeClass,
+        side: OrderSide,
+        entry_price: f64,
+        spread: f64,
+        fee_bps: f64,
+        edge_gross_bps: f64,
+        edge_net_bps: f64,
+        size: f64,
+        dual_pair: bool,
+    }
+
+    let market_ids = market_ids.into_iter().take(32).collect::<Vec<_>>();
+    let tf_by_market = {
+        let map = shared.market_to_timeframe.read().await;
+        market_ids
+            .iter()
+            .filter_map(|id| map.get(id).cloned().map(|tf| (id.clone(), tf)))
+            .collect::<HashMap<String, TimeframeClass>>()
+    };
+    let book_by_market = {
+        let map = shared.latest_books.read().await;
+        market_ids
+            .iter()
+            .filter_map(|id| map.get(id).cloned().map(|b| (id.clone(), b)))
+            .collect::<HashMap<String, BookTop>>()
+    };
+
+    let mut cand_inputs_by_market: HashMap<String, Vec<PredatorCandIn>> = HashMap::new();
+    for market_id in market_ids {
+        let Some(timeframe) = tf_by_market.get(&market_id).cloned() else {
+            continue;
+        };
+        let Some(frame_total_ms) = timeframe_total_ms(timeframe.clone()) else {
+            shared
+                .shadow_stats
+                .mark_blocked_with_reason("v52_blocked_timeframe")
+                .await;
+            continue;
+        };
+        if !predator_cfg
+            .v52
+            .time_phase
+            .allow_timeframes
+            .iter()
+            .any(|v| v == timeframe_tag(timeframe.clone()))
+        {
+            shared
+                .shadow_stats
+                .mark_blocked_with_reason("v52_timeframe_not_allowed")
+                .await;
+            continue;
+        }
+        let Some(book) = book_by_market.get(&market_id).cloned() else {
+            continue;
+        };
+        let sig_entry = shared
+            .latest_signals
+            .get(&market_id)
+            .map(|v| v.value().clone());
+        let Some(sig_entry) = sig_entry else {
+            continue;
+        };
+        if now_ms.saturating_sub(sig_entry.ts_ms) > 5_000 {
+            continue;
+        }
+
+        let time_to_expiry_ms = (frame_total_ms - now_ms.rem_euclid(frame_total_ms)).max(0);
+        let remaining_ratio = (time_to_expiry_ms as f64 / frame_total_ms as f64).clamp(0.0, 1.0);
+        let time_phase = classify_time_phase(remaining_ratio, &predator_cfg.v52.time_phase);
+
+        let fee_bps = get_fee_rate_bps_cached(shared, &market_id).await;
+        let rebate_est_bps = get_rebate_bps_cached(shared, &market_id, fee_bps).await;
+        let yes_price = aggressive_price_for_side(&book, &OrderSide::BuyYes);
+        let no_price = aggressive_price_for_side(&book, &OrderSide::BuyNo);
+        let dual_arb_ok = allow_dual_side_arb(yes_price, no_price, fee_bps, &predator_cfg.v52.dual_arb);
+        let book_top_lag_ms = if tick_fast_recv_ts_local_ns > 0 && book.recv_ts_local_ns > 0 {
+            ((book.recv_ts_local_ns - tick_fast_recv_ts_local_ns).max(0) as f64) / 1_000_000.0
+        } else {
+            0.0
+        };
+        let settlement_prob_yes =
+            settlement_prob_yes_for_symbol(shared, symbol, sig_entry.signal.fair_yes, now_ms).await;
+        let probability = {
+            let engine = shared.predator_probability_engine.read().await;
+            engine.estimate(
+                &sig_entry.signal,
+                &direction_signal,
+                settlement_prob_yes,
+                book_top_lag_ms,
+                now_ms,
+            )
+        };
+        {
+            let mut map = shared.predator_latest_probability.write().await;
+            map.insert(market_id.clone(), probability.clone());
+        }
+        shared
+            .shadow_stats
+            .push_probability_sample(&probability)
+            .await;
+        let yes_edge_gross = edge_gross_bps_for_side(probability.p_settle, &OrderSide::BuyYes, yes_price);
+        let no_edge_gross = edge_gross_bps_for_side(probability.p_settle, &OrderSide::BuyNo, no_price);
+        let yes_edge_net = yes_edge_gross - fee_bps + rebate_est_bps - edge_model_cfg.fail_cost_bps;
+        let no_edge_net = no_edge_gross - fee_bps + rebate_est_bps - edge_model_cfg.fail_cost_bps;
+        if yes_edge_net > 0.0 && no_edge_net > 0.0 && !dual_arb_ok {
+            shared
+                .shadow_stats
+                .mark_blocked_with_reason("dual_arb_gate_blocked")
+                .await;
+        }
+        let tf_weight = tf_weights
+            .get(&timeframe)
+            .copied()
+            .unwrap_or(1.0)
+            .clamp(0.0, 1.0);
+        if tf_weight <= 0.0 {
+            continue;
+        }
+        let phase_size_scale = time_phase_size_scale(time_phase, &predator_cfg.v52.time_phase);
+        let side_size_scale = (tf_weight * phase_size_scale).max(0.0);
+        let mk_size = |entry_price: f64| {
+            let base_size = if quote_notional_usdc > 0.0 {
+                (quote_notional_usdc / entry_price.max(1e-6)).max(0.01)
+            } else {
+                maker_cfg.base_quote_size.max(0.01)
+            };
+            (base_size * side_size_scale).max(0.01)
+        };
+        let push_candidate = |bucket: &mut Vec<PredatorCandIn>,
+                              side: OrderSide,
+                              entry_price: f64,
+                              spread: f64,
+                              edge_gross_bps: f64,
+                              edge_net_bps: f64,
+                              dual_pair: bool| {
+            bucket.push(PredatorCandIn {
+                market_id: market_id.clone(),
+                timeframe: timeframe.clone(),
+                side,
+                entry_price,
+                spread,
+                fee_bps,
+                edge_gross_bps,
+                edge_net_bps,
+                size: mk_size(entry_price),
+                dual_pair,
+            });
+        };
+        let bucket = cand_inputs_by_market.entry(market_id.clone()).or_default();
+        if dual_arb_ok && yes_edge_net > 0.0 && no_edge_net > 0.0 {
+            push_candidate(
+                bucket,
+                OrderSide::BuyYes,
+                yes_price,
+                spread_for_side(&book, &OrderSide::BuyYes),
+                yes_edge_gross,
+                yes_edge_net,
+                true,
+            );
+            push_candidate(
+                bucket,
+                OrderSide::BuyNo,
+                no_price,
+                spread_for_side(&book, &OrderSide::BuyNo),
+                no_edge_gross,
+                no_edge_net,
+                true,
+            );
+        } else {
+            let (side, entry_price, edge_gross_bps, edge_net_bps) = if no_edge_net > yes_edge_net {
+                (OrderSide::BuyNo, no_price, no_edge_gross, no_edge_net)
+            } else {
+                (OrderSide::BuyYes, yes_price, yes_edge_gross, yes_edge_net)
+            };
+            push_candidate(
+                bucket,
+                side.clone(),
+                entry_price,
+                spread_for_side(&book, &side),
+                edge_gross_bps,
+                edge_net_bps,
+                false,
+            );
+        }
+    }
+
+    let mut fire_plans_by_market: HashMap<String, FirePlan> = HashMap::new();
+    let mut dual_fire_pairs: Vec<(FirePlan, FirePlan)> = Vec::new();
+    let mut skip_reasons: Vec<String> = Vec::new();
+    {
+        let mut sniper = shared.predator_taker_sniper.write().await;
+        let normalize_plan = |mut plan: FirePlan, cin: &PredatorCandIn| {
+            plan.opportunity.side = cin.side.clone();
+            plan.opportunity.direction = side_to_direction(&cin.side);
+            plan.opportunity.entry_price = cin.entry_price;
+            plan.opportunity.edge_gross_bps = cin.edge_gross_bps;
+            plan.opportunity.edge_net_bps = cin.edge_net_bps;
+            plan.opportunity.ts_ms = now_ms;
+            plan
+        };
+        let evaluate = |sn: &mut taker_sniper::TakerSniper,
+                        cin: &PredatorCandIn,
+                        sig: &DirectionSignal| {
+            sn.evaluate(&taker_sniper::EvaluateCtx {
+                market_id: &cin.market_id,
+                symbol,
+                timeframe: cin.timeframe.clone(),
+                direction_signal: sig,
+                entry_price: cin.entry_price,
+                spread: cin.spread,
+                fee_bps: cin.fee_bps,
+                edge_gross_bps: cin.edge_gross_bps,
+                edge_net_bps: cin.edge_net_bps,
+                size: cin.size,
+                now_ms,
+            })
+        };
+        for (_, mut cands) in cand_inputs_by_market {
+            if cands.is_empty() {
+                continue;
+            }
+            cands.sort_by(|a, b| {
+                b.edge_net_bps
+                    .partial_cmp(&a.edge_net_bps)
+                    .unwrap_or(std::cmp::Ordering::Equal)
+            });
+            let dual_eligible = cands.len() == 2 && cands.iter().all(|c| c.dual_pair);
+            if dual_eligible {
+                let mut dry_cfg = sniper.cfg().clone();
+                dry_cfg.cooldown_ms_per_market = 0;
+                let mut dry_sniper = taker_sniper::TakerSniper::new(dry_cfg);
+
+                let primary = &cands[0];
+                let hedge = &cands[1];
+                let primary_sig = direction_signal_for_side(&direction_signal, &primary.side);
+                let hedge_sig = direction_signal_for_side(&direction_signal, &hedge.side);
+
+                let primary_probe = evaluate(&mut dry_sniper, primary, &primary_sig);
+                let hedge_probe = evaluate(&mut dry_sniper, hedge, &hedge_sig);
+                if matches!(primary_probe.action, TakerAction::Fire)
+                    && matches!(hedge_probe.action, TakerAction::Fire)
+                {
+                    let primary_live = evaluate(&mut sniper, primary, &primary_sig);
+                    match primary_live.action {
+                        TakerAction::Fire => {
+                            if let (Some(primary_plan), Some(hedge_plan)) =
+                                (primary_live.fire_plan, hedge_probe.fire_plan)
+                            {
+                                dual_fire_pairs.push((
+                                    normalize_plan(primary_plan, primary),
+                                    normalize_plan(hedge_plan, hedge),
+                                ));
+                                continue;
+                            }
+                            skip_reasons.push("dual_arb_plan_missing".to_string());
+                        }
+                        TakerAction::Skip => {
+                            skip_reasons.push(primary_live.reason);
+                        }
+                    }
+                } else {
+                    if matches!(primary_probe.action, TakerAction::Skip) {
+                        skip_reasons.push(primary_probe.reason);
+                    }
+                    if matches!(hedge_probe.action, TakerAction::Skip) {
+                        skip_reasons.push(hedge_probe.reason);
+                    }
+                }
+            }
+
+            let best = &cands[0];
+            let best_sig = direction_signal_for_side(&direction_signal, &best.side);
+            let decision = evaluate(&mut sniper, best, &best_sig);
+            match decision.action {
+                TakerAction::Fire => {
+                    if let Some(plan) = decision.fire_plan {
+                        let plan = normalize_plan(plan, best);
+                        fire_plans_by_market.insert(plan.opportunity.market_id.clone(), plan);
+                    }
+                }
+                TakerAction::Skip => skip_reasons.push(decision.reason),
+            }
+        }
+    }
+    for reason in skip_reasons {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped(reason.as_str())
+            .await;
+    }
+
+    if matches!(regime, Regime::Quiet) {
+        let quiet_min_edge = predator_cfg.taker_sniper.min_edge_net_bps.max(0.0)
+            * predator_cfg.regime.quiet_min_edge_multiplier.max(1.0);
+        fire_plans_by_market.retain(|_, plan| plan.opportunity.edge_net_bps >= quiet_min_edge);
+        dual_fire_pairs.retain(|(a, b)| {
+            a.opportunity.edge_net_bps >= quiet_min_edge && b.opportunity.edge_net_bps >= quiet_min_edge
+        });
+        let chunk_scale = predator_cfg.regime.quiet_chunk_scale.clamp(0.05, 1.0);
+        for plan in fire_plans_by_market.values_mut() {
+            let len = plan.chunks.len();
+            if len <= 1 {
+                continue;
+            }
+            let keep = ((len as f64) * chunk_scale).ceil() as usize;
+            let keep = keep.clamp(1, len);
+            plan.chunks.truncate(keep);
+            if let Some(first) = plan.chunks.first_mut() {
+                first.send_delay_ms = 0;
+            }
+        }
+        for (plan_a, plan_b) in dual_fire_pairs.iter_mut() {
+            for plan in [plan_a, plan_b] {
+                let len = plan.chunks.len();
+                if len <= 1 {
+                    continue;
+                }
+                let keep = ((len as f64) * chunk_scale).ceil() as usize;
+                let keep = keep.clamp(1, len);
+                plan.chunks.truncate(keep);
+                if let Some(first) = plan.chunks.first_mut() {
+                    first.send_delay_ms = 0;
+                }
+            }
+        }
+    }
+
+    if fire_plans_by_market.is_empty() && dual_fire_pairs.is_empty() {
+        return PredatorExecResult::default();
+    }
+
+    let mut locked_plans: Vec<FirePlan> = Vec::new();
+    let mut locked_dual_pairs: Vec<(FirePlan, FirePlan)> = Vec::new();
+    let mut locked_by_tf_usdc: HashMap<String, f64> = HashMap::new();
+    let mut router_skip_reasons: Vec<String> = Vec::new();
+    {
+        let mut router = shared.predator_router.write().await;
+        let selected = router.route(
+            fire_plans_by_market
+                .values()
+                .map(|plan| plan.opportunity.clone())
+                .collect::<Vec<_>>(),
+            total_capital_usdc.max(0.0),
+            now_ms,
+        );
+        for opp in selected {
+            if router.lock(&opp, now_ms) {
+                if let Some(plan) = fire_plans_by_market.remove(&opp.market_id) {
+                    locked_plans.push(plan);
+                }
+            }
+        }
+        for (plan_a, plan_b) in dual_fire_pairs {
+            let notional = (plan_a.opportunity.entry_price.max(0.0) * plan_a.opportunity.size.max(0.0))
+                + (plan_b.opportunity.entry_price.max(0.0) * plan_b.opportunity.size.max(0.0));
+            if notional <= 0.0 {
+                continue;
+            }
+            let mut lock_opp = if plan_a.opportunity.edge_net_bps >= plan_b.opportunity.edge_net_bps {
+                plan_a.opportunity.clone()
+            } else {
+                plan_b.opportunity.clone()
+            };
+            lock_opp.entry_price = 1.0;
+            lock_opp.size = notional.max(0.01);
+            if router.lock(&lock_opp, now_ms) {
+                locked_dual_pairs.push((plan_a, plan_b));
+            } else {
+                router_skip_reasons.push("dual_arb_router_lock_blocked".to_string());
+            }
+        }
+        for (tf, v) in router.locked_by_tf_usdc(now_ms) {
+            locked_by_tf_usdc.insert(tf.to_string(), v);
+        }
+    }
+    for reason in router_skip_reasons {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped(reason.as_str())
+            .await;
+    }
+    shared
+        .shadow_stats
+        .set_predator_router_locked_by_tf_usdc(locked_by_tf_usdc)
+        .await;
+
+    if locked_plans.is_empty() && locked_dual_pairs.is_empty() {
+        return PredatorExecResult::default();
+    }
+
+    let single_futures: Vec<_> = locked_plans
+        .into_iter()
+        .map(|plan| {
+            let shared = shared.clone();
+            let bus = bus.clone();
+            let portfolio = portfolio.clone();
+            let execution = execution.clone();
+            let shadow = shadow.clone();
+            let maker_cfg = maker_cfg.clone();
+            let direction_signal = direction_signal_for_side(&direction_signal, &plan.opportunity.side);
+            let mut market_rate_budget_local = market_rate_budget.clone();
+            let mut global_rate_budget_local = global_rate_budget.clone();
+            async move {
+                execute_fire_plan(
+                    &shared,
+                    &bus,
+                    &portfolio,
+                    &execution,
+                    &shadow,
+                    &mut market_rate_budget_local,
+                    &mut global_rate_budget_local,
+                    &maker_cfg,
+                    predator_cfg,
+                    &direction_signal,
+                    &plan,
+                    tick_fast_recv_ts_ms,
+                    tick_fast_recv_ts_local_ns,
+                    now_ms,
+                )
+                .await
+            }
+        })
+        .collect();
+
+    let mut out = PredatorExecResult::default();
+    for r in futures::future::join_all(single_futures).await {
+        out.attempted = out.attempted.saturating_add(r.attempted);
+        out.executed = out.executed.saturating_add(r.executed);
+    }
+
+    let dual_futures: Vec<_> = locked_dual_pairs
+        .into_iter()
+        .map(|(plan_a, plan_b)| {
+            let shared = shared.clone();
+            let bus = bus.clone();
+            let portfolio = portfolio.clone();
+            let execution = execution.clone();
+            let shadow = shadow.clone();
+            let maker_cfg = maker_cfg.clone();
+            let dir_a = direction_signal_for_side(&direction_signal, &plan_a.opportunity.side);
+            let dir_b = direction_signal_for_side(&direction_signal, &plan_b.opportunity.side);
+            let mut market_rate_budget_local_a = market_rate_budget.clone();
+            let mut global_rate_budget_local_a = global_rate_budget.clone();
+            let mut market_rate_budget_local_b = market_rate_budget.clone();
+            let mut global_rate_budget_local_b = global_rate_budget.clone();
+            async move {
+                let leg_a = execute_fire_plan(
+                    &shared,
+                    &bus,
+                    &portfolio,
+                    &execution,
+                    &shadow,
+                    &mut market_rate_budget_local_a,
+                    &mut global_rate_budget_local_a,
+                    &maker_cfg,
+                    predator_cfg,
+                    &dir_a,
+                    &plan_a,
+                    tick_fast_recv_ts_ms,
+                    tick_fast_recv_ts_local_ns,
+                    now_ms,
+                );
+                let leg_b = execute_fire_plan(
+                    &shared,
+                    &bus,
+                    &portfolio,
+                    &execution,
+                    &shadow,
+                    &mut market_rate_budget_local_b,
+                    &mut global_rate_budget_local_b,
+                    &maker_cfg,
+                    predator_cfg,
+                    &dir_b,
+                    &plan_b,
+                    tick_fast_recv_ts_ms,
+                    tick_fast_recv_ts_local_ns,
+                    now_ms,
+                );
+                let (res_a, res_b) = tokio::join!(leg_a, leg_b);
+                PredatorExecResult {
+                    attempted: res_a.attempted.saturating_add(res_b.attempted),
+                    executed: res_a.executed.saturating_add(res_b.executed),
+                    stop_firing: res_a.stop_firing || res_b.stop_firing,
+                }
+            }
+        })
+        .collect();
+
+    for r in futures::future::join_all(dual_futures).await {
+        out.attempted = out.attempted.saturating_add(r.attempted);
+        out.executed = out.executed.saturating_add(r.executed);
+    }
+    out
+}
+
+async fn execute_fire_plan(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    maker_cfg: &MakerConfig,
+    predator_cfg: &PredatorCConfig,
+    direction_signal: &DirectionSignal,
+    plan: &FirePlan,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+) -> PredatorExecResult {
+    let mut plan_result = PredatorExecResult::default();
+    let opp = &plan.opportunity;
+    for (idx, chunk) in plan.chunks.iter().enumerate() {
+        if chunk.size <= 0.0 {
+            continue;
+        }
+        if idx > 0 && chunk.send_delay_ms > 0 {
+            tokio::time::sleep(Duration::from_millis(chunk.send_delay_ms)).await;
+        }
+        shared.shadow_stats.mark_predator_taker_fired();
+        let res = predator_execute_opportunity(
+            shared,
+            bus,
+            portfolio,
+            execution,
+            shadow,
+            market_rate_budget,
+            global_rate_budget,
+            maker_cfg,
+            predator_cfg,
+            direction_signal,
+            opp,
+            chunk.size,
+            tick_fast_recv_ts_ms,
+            tick_fast_recv_ts_local_ns,
+            now_ms,
+        )
+        .await;
+        plan_result.attempted = plan_result.attempted.saturating_add(res.attempted);
+        plan_result.executed = plan_result.executed.saturating_add(res.executed);
+        if plan.stop_on_reject && res.stop_firing {
+            break;
+        }
+    }
+    plan_result
+}
+
+pub(super) async fn run_predator_d_for_symbol(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    predator_cfg: &PredatorCConfig,
+    symbol: &str,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+) -> PredatorExecResult {
+    let d_cfg = &predator_cfg.strategy_d;
+    if !predator_cfg.enabled || !d_cfg.enabled {
+        return PredatorExecResult::default();
+    }
+
+    let direction_signal = {
+        let mut direction_signal = {
+            let det = shared.predator_direction_detector.read().await;
+            det.evaluate(symbol, now_ms)
+        };
+        if direction_signal.is_none() {
+            let fallback_signal = shared
+                .predator_latest_direction
+                .read()
+                .await
+                .get(symbol)
+                .cloned();
+            if let Some(cached) = fallback_signal {
+                let cached_ms = cached.ts_ns.div_euclid(1_000_000);
+                let age_ms = now_ms.saturating_sub(cached_ms);
+                if age_ms <= 2_500 {
+                    direction_signal = Some(cached);
+                }
+            }
+        }
+        let Some(sig) = direction_signal else {
+            return PredatorExecResult::default();
+        };
+        sig
+    };
+    if matches!(direction_signal.direction, Direction::Neutral) {
+        return PredatorExecResult::default();
+    }
+
+    let side = match direction_signal.direction {
+        Direction::Up => OrderSide::BuyYes,
+        Direction::Down => OrderSide::BuyNo,
+        Direction::Neutral => OrderSide::BuyYes,
+    };
+    let maker_cfg = shared.strategy_cfg.read().await.clone();
+    let edge_model_cfg = shared.edge_model_cfg.read().await.clone();
+    let market_ids = shared
+        .symbol_to_markets
+        .read()
+        .await
+        .get(symbol)
+        .cloned()
+        .unwrap_or_default();
+    if market_ids.is_empty() {
+        return PredatorExecResult::default();
+    }
+
+    let mut out = PredatorExecResult::default();
+    for market_id in market_ids.into_iter().take(32) {
+        if d_cfg.cooldown_ms_per_market > 0 {
+            let last_fire = shared
+                .predator_d_last_fire_ms
+                .read()
+                .await
+                .get(&market_id)
+                .copied()
+                .unwrap_or(0);
+            if now_ms.saturating_sub(last_fire) < d_cfg.cooldown_ms_per_market as i64 {
+                continue;
+            }
+        }
+
+        let book = shared.latest_books.read().await.get(&market_id).cloned();
+        let Some(book) = book else {
+            continue;
+        };
+        let entry_price = aggressive_price_for_side(&book, &side);
+        if entry_price <= 0.0 {
+            continue;
+        }
+        let spread = spread_for_side(&book, &side);
+        let mid_px = mid_for_side(&book, &side).max(1e-6);
+        let spread_bps = (spread / mid_px) * 10_000.0;
+        if spread_bps < d_cfg.min_gap_bps {
+            continue;
+        }
+
+        let sig_entry = shared
+            .latest_signals
+            .get(&market_id)
+            .map(|v| v.value().clone());
+        let Some(sig_entry) = sig_entry else {
+            continue;
+        };
+        if now_ms.saturating_sub(sig_entry.ts_ms) > 5_000 {
+            continue;
+        }
+
+        let book_top_lag_ms = if tick_fast_recv_ts_local_ns > 0 && book.recv_ts_local_ns > 0 {
+            ((book.recv_ts_local_ns - tick_fast_recv_ts_local_ns).max(0) as f64) / 1_000_000.0
+        } else {
+            0.0
+        };
+        let settlement_prob_yes =
+            settlement_prob_yes_for_symbol(shared, symbol, sig_entry.signal.fair_yes, now_ms).await;
+        let probability = {
+            let engine = shared.predator_probability_engine.read().await;
+            engine.estimate(
+                &sig_entry.signal,
+                &direction_signal,
+                settlement_prob_yes,
+                book_top_lag_ms,
+                now_ms,
+            )
+        };
+        if probability.confidence < d_cfg.min_confidence {
+            continue;
+        }
+        let fee_bps = get_fee_rate_bps_cached(shared, &market_id).await;
+        let rebate_est_bps = get_rebate_bps_cached(shared, &market_id, fee_bps).await;
+        let edge_gross_bps = edge_gross_bps_for_side(probability.p_settle, &side, entry_price);
+        let edge_net_bps = edge_gross_bps - fee_bps + rebate_est_bps - edge_model_cfg.fail_cost_bps;
+        if edge_net_bps < d_cfg.min_edge_net_bps {
+            continue;
+        }
+        let timeframe = shared
+            .market_to_timeframe
+            .read()
+            .await
+            .get(&market_id)
+            .cloned()
+            .unwrap_or(TimeframeClass::Tf5m);
+        let max_notional = d_cfg.max_notional_usdc.max(maker_cfg.base_quote_size);
+        let size = (max_notional / entry_price.max(1e-6)).max(0.01);
+        let lock_minutes = match timeframe {
+            TimeframeClass::Tf5m => 5.0,
+            TimeframeClass::Tf15m => 15.0,
+            TimeframeClass::Tf1h => 60.0,
+            TimeframeClass::Tf1d => 1440.0,
+        };
+        let notional_usdc = (entry_price.max(0.0) * size.max(0.0)).max(0.0);
+        let edge_net_usdc = (edge_net_bps / 10_000.0) * notional_usdc;
+        let density = if lock_minutes <= 0.0 {
+            0.0
+        } else {
+            edge_net_usdc / lock_minutes
+        };
+        let opp = TimeframeOpp {
+            timeframe,
+            market_id: market_id.clone(),
+            symbol: symbol.to_string(),
+            direction: direction_signal.direction.clone(),
+            side: side.clone(),
+            entry_price,
+            size,
+            edge_gross_bps,
+            edge_net_bps,
+            edge_net_usdc,
+            fee_bps,
+            lock_minutes,
+            density,
+            confidence: probability.confidence,
+            ts_ms: now_ms,
+        };
+        let res = predator_execute_opportunity(
+            shared,
+            bus,
+            portfolio,
+            execution,
+            shadow,
+            market_rate_budget,
+            global_rate_budget,
+            &maker_cfg,
+            predator_cfg,
+            &direction_signal,
+            &opp,
+            size,
+            tick_fast_recv_ts_ms,
+            tick_fast_recv_ts_local_ns,
+            now_ms,
+        )
+        .await;
+        if res.attempted > 0 {
+            shared
+                .predator_d_last_fire_ms
+                .write()
+                .await
+                .insert(market_id, now_ms);
+        }
+        out.attempted = out.attempted.saturating_add(res.attempted);
+        out.executed = out.executed.saturating_add(res.executed);
+    }
+    out
+}
+
+pub(super) async fn run_predator_c_cross_symbol(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    predator_cfg: &PredatorCConfig,
+    leader_direction: &DirectionSignal,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+) -> PredatorExecResult {
+    let cross_cfg = &predator_cfg.cross_symbol;
+    if !cross_cfg.enabled {
+        return PredatorExecResult::default();
+    }
+    if !leader_direction
+        .symbol
+        .eq_ignore_ascii_case(&cross_cfg.leader_symbol)
+    {
+        return PredatorExecResult::default();
+    }
+    if matches!(leader_direction.direction, Direction::Neutral) {
+        return PredatorExecResult::default();
+    }
+    if leader_direction.confidence < cross_cfg.min_leader_confidence
+        || leader_direction.magnitude_pct.abs() < cross_cfg.min_leader_magnitude_pct
+    {
+        return PredatorExecResult::default();
+    }
+    let follower_symbols = cross_cfg
+        .follower_symbols
+        .iter()
+        .filter(|s| !s.eq_ignore_ascii_case(&leader_direction.symbol))
+        .cloned()
+        .collect::<Vec<_>>();
+    if follower_symbols.is_empty() {
+        return PredatorExecResult::default();
+    }
+
+    let correlated_used =
+        correlated_locked_positions_for_symbols(shared, &follower_symbols, now_ms).await;
+    let mut slots_left = cross_cfg
+        .max_correlated_positions
+        .saturating_sub(correlated_used);
+    if slots_left == 0 {
+        return PredatorExecResult::default();
+    }
+
+    let mut out = PredatorExecResult::default();
+    for follower in follower_symbols {
+        if slots_left == 0 {
+            break;
+        }
+        let follower_sig = {
+            let det = shared.predator_direction_detector.read().await;
+            det.evaluate(&follower, now_ms)
+        };
+        if let Some(sig) = follower_sig {
+            let same_dir = sig.direction == leader_direction.direction;
+            if same_dir && sig.confidence > cross_cfg.follower_stale_confidence_max {
+                continue;
+            }
+        }
+
+        let mut forced = leader_direction.clone();
+        forced.symbol = follower.clone();
+        let res = run_predator_c_for_symbol(
+            shared,
+            bus,
+            portfolio,
+            execution,
+            shadow,
+            market_rate_budget,
+            global_rate_budget,
+            predator_cfg,
+            &follower,
+            tick_fast_recv_ts_ms,
+            tick_fast_recv_ts_local_ns,
+            now_ms,
+            Some(forced),
+        )
+        .await;
+        if res.attempted > 0 {
+            slots_left = slots_left.saturating_sub(1);
+            shared.shadow_stats.mark_predator_cross_symbol_fired();
+        }
+        out.attempted = out.attempted.saturating_add(res.attempted);
+        out.executed = out.executed.saturating_add(res.executed);
+    }
+    out
+}
+
+pub(super) async fn correlated_locked_positions_for_symbols(
+    shared: &Arc<EngineShared>,
+    symbols: &[String],
+    now_ms: i64,
+) -> usize {
+    if symbols.is_empty() {
+        return 0;
+    }
+    let locks = {
+        let mut router = shared.predator_router.write().await;
+        router.snapshot_locks(now_ms)
+    };
+    if locks.is_empty() {
+        return 0;
+    }
+    let symbol_set = symbols
+        .iter()
+        .map(|s| s.to_ascii_uppercase())
+        .collect::<std::collections::HashSet<_>>();
+    let market_to_symbol = shared.market_to_symbol.read().await.clone();
+    locks
+        .iter()
+        .filter(|lock| {
+            market_to_symbol
+                .get(&lock.market_id)
+                .map(|s| symbol_set.contains(&s.to_ascii_uppercase()))
+                .unwrap_or(false)
+        })
+        .count()
+}
+
+pub(super) async fn symbol_toxic_snapshot(
+    shared: &Arc<EngineShared>,
+    market_ids: &[String],
+) -> (f64, ToxicRegime) {
+    if market_ids.is_empty() {
+        return (0.0, ToxicRegime::Safe);
+    }
+    let states = shared.tox_state.read().await;
+    let mut max_score = 0.0_f64;
+    let mut has_caution = false;
+    let mut has_danger = false;
+    for market_id in market_ids {
+        if let Some(st) = states.get(market_id) {
+            max_score = max_score.max(st.last_tox_score);
+            match st.last_regime {
+                ToxicRegime::Danger => has_danger = true,
+                ToxicRegime::Caution => has_caution = true,
+                ToxicRegime::Safe => {}
+            }
+        }
+    }
+    let regime = if has_danger {
+        ToxicRegime::Danger
+    } else if has_caution {
+        ToxicRegime::Caution
+    } else {
+        ToxicRegime::Safe
+    };
+    (max_score, regime)
+}
+
+pub(super) fn classify_predator_regime(
+    cfg: &PredatorRegimeConfig,
+    direction_signal: &DirectionSignal,
+    tox_score: f64,
+    tox_regime: &ToxicRegime,
+    source_health: Option<&SourceHealth>,
+    source_health_cfg: &SourceHealthConfig,
+) -> Regime {
+    if !cfg.enabled {
+        return Regime::Active;
+    }
+    let source_low = source_health
+        .map(|h| {
+            h.sample_count >= source_health_cfg.min_samples
+                && h.score
+                    < cfg
+                        .defend_min_source_health
+                        .max(source_health_cfg.min_score_for_trading)
+                || (h.sample_count >= source_health_cfg.min_samples && h.freshness_score < 0.25)
+        })
+        .unwrap_or(false);
+    if source_low {
+        return Regime::Defend;
+    }
+    if tox_score >= cfg.defend_tox_score {
+        return Regime::Defend;
+    }
+    if cfg.defend_on_toxic_danger && matches!(tox_regime, ToxicRegime::Danger) {
+        return Regime::Defend;
+    }
+    if direction_signal.confidence >= cfg.active_min_confidence
+        && direction_signal.magnitude_pct.abs() >= cfg.active_min_magnitude_pct
+    {
+        Regime::Active
+    } else {
+        Regime::Quiet
+    }
+}
+
+pub(super) async fn predator_execute_opportunity(
+    shared: &Arc<EngineShared>,
+    bus: &RingBus<EngineEvent>,
+    portfolio: &Arc<PortfolioBook>,
+    execution: &Arc<ClobExecution>,
+    shadow: &Arc<ShadowExecutor>,
+    market_rate_budget: &mut HashMap<String, TokenBucket>,
+    global_rate_budget: &mut TokenBucket,
+    maker_cfg: &MakerConfig,
+    predator_cfg: &PredatorCConfig,
+    direction_signal: &DirectionSignal,
+    opp: &TimeframeOpp,
+    chunk_size: f64,
+    tick_fast_recv_ts_ms: i64,
+    tick_fast_recv_ts_local_ns: i64,
+    now_ms: i64,
+) -> PredatorExecResult {
+    let mut intent = QuoteIntent {
+        market_id: opp.market_id.clone(),
+        side: opp.side.clone(),
+        price: opp.entry_price,
+        size: chunk_size,
+        ttl_ms: maker_cfg.ttl_ms,
+    };
+
+    let book = shared
+        .latest_books
+        .read()
+        .await
+        .get(&intent.market_id)
+        .cloned();
+    let Some(book) = book else {
+        shared
+            .shadow_stats
+            .mark_predator_taker_skipped("book_missing")
+            .await;
+        return PredatorExecResult::default();
+    };
+    let Some(frame_total_ms) = timeframe_total_ms(opp.timeframe.clone()) else {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("v52_blocked_timeframe")
+            .await;
+        return PredatorExecResult::default();
+    };
+    let time_to_expiry_ms = (frame_total_ms - now_ms.rem_euclid(frame_total_ms)).max(0);
+    let remaining_ratio = (time_to_expiry_ms as f64 / frame_total_ms as f64).clamp(0.0, 1.0);
+    let time_phase = classify_time_phase(remaining_ratio, &predator_cfg.v52.time_phase);
+    let force_taker_now =
+        should_force_taker_fallback(time_phase, time_to_expiry_ms, &predator_cfg.v52.execution);
+    let apply_force_taker_for_phase = match time_phase {
+        TimePhase::Early => false,
+        TimePhase::Maturity => predator_cfg.v52.execution.apply_force_taker_in_maturity,
+        TimePhase::Late => predator_cfg.v52.execution.apply_force_taker_in_late,
+    };
+    if force_taker_now {
+        shared.shadow_stats.mark_predator_last_30s_taker_fallback();
+    }
+
+    // Same interpretation as the maker path: positive means our fast ref tick arrived earlier
+    // than the Polymarket book update. For Predator, the ref tick is per-symbol while the book
+    // is per-market, so this is still a useful (if approximate) window estimate.
+    let tick_age_ms = freshness_ms(now_ms, tick_fast_recv_ts_ms);
+    let book_top_lag_ms =
+        if tick_age_ms <= 1_500 && tick_fast_recv_ts_local_ns > 0 && book.recv_ts_local_ns > 0 {
+            ((book.recv_ts_local_ns - tick_fast_recv_ts_local_ns).max(0) as f64) / 1_000_000.0
+        } else {
+            0.0
+        };
+
+    let inventory = inventory_for_market(portfolio, &intent.market_id);
+    let pending_market_exposure = execution.open_order_notional_for_market(&intent.market_id);
+    let pending_total_exposure = execution.open_order_notional_total();
+    let drawdown = portfolio.snapshot().max_drawdown_pct;
+    let risk_limits_snapshot = shared
+        .risk_limits
+        .read()
+        .map(|g| g.clone())
+        .unwrap_or_else(|_| RiskLimits::default());
+    let open_orders_now = execution.open_orders_count();
+    let risk_open_orders_soft_cap = risk_limits_snapshot.max_open_orders.saturating_sub(1);
+    if open_orders_now >= risk_open_orders_soft_cap.max(1) {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("open_orders_pressure_precheck")
+            .await;
+        return PredatorExecResult::default();
+    }
+    shared.shadow_stats.mark_attempted();
+    let (tox_score, tox_regime) = {
+        let map = shared.tox_state.read().await;
+        map.get(&intent.market_id)
+            .map(|st| (st.last_tox_score, st.last_regime.clone()))
+            .unwrap_or((0.0, ToxicRegime::Safe))
+    };
+    let pre_scale = adaptive_size_scale(
+        drawdown,
+        inventory.exposure_notional + pending_market_exposure,
+        inventory.exposure_notional + pending_total_exposure,
+        &risk_limits_snapshot,
+        tox_score,
+        &tox_regime,
+    );
+    intent.size = (intent.size * pre_scale).max(0.01);
+    let proposed_notional_usdc = (intent.price.max(0.0) * intent.size.max(0.0)).max(0.0);
+    let ctx = RiskContext {
+        market_id: intent.market_id.clone(),
+        symbol: opp.symbol.clone(),
+        order_count: execution.open_orders_count(),
+        proposed_size: intent.size,
+        proposed_notional_usdc,
+        market_notional: inventory.exposure_notional + pending_market_exposure,
+        asset_notional: inventory.exposure_notional + pending_total_exposure,
+        drawdown_pct: drawdown,
+        loss_streak: shared.shadow_stats.loss_streak(),
+        now_ms,
+    };
+    let decision = shared.risk_manager.evaluate(&ctx);
+    if !decision.allow {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason(&format!("risk:{}", decision.reason))
+            .await;
+        return PredatorExecResult::default();
+    }
+    if decision.capped_size <= 0.0 {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("risk_capped_zero")
+            .await;
+        return PredatorExecResult::default();
+    }
+    intent.size = intent.size.min(decision.capped_size);
+
+    let intended_notional_usdc = (intent.price.max(0.0) * intent.size.max(0.0)).max(0.0);
+    if intended_notional_usdc < maker_cfg.min_eval_notional_usdc {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("tiny_notional")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    let edge_net_usdc = (opp.edge_net_bps / 10_000.0) * intended_notional_usdc;
+    let edge_model_cfg = shared.edge_model_cfg.read().await.clone();
+    let dynamic_gate_bps = edge_gate_bps(
+        &edge_model_cfg,
+        0.0,
+        tick_age_ms as f64,
+        book_top_lag_ms,
+        0.0,
+    );
+    if opp.edge_net_bps < maker_cfg.min_edge_bps + dynamic_gate_bps {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("edge_below_dynamic_gate")
+            .await;
+        return PredatorExecResult::default();
+    }
+    if edge_net_usdc < maker_cfg.min_expected_edge_usdc {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("edge_notional_too_small")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    let per_market_rps = (shared.rate_limit_rps / 8.0).max(0.5);
+    let market_bucket = market_rate_budget
+        .entry(intent.market_id.clone())
+        .or_insert_with(|| TokenBucket::new(per_market_rps, (per_market_rps * 2.0).max(1.0)));
+    if !global_rate_budget.try_take(1.0) {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("rate_budget_global")
+            .await;
+        return PredatorExecResult::default();
+    }
+    if !market_bucket.try_take(1.0) {
+        shared
+            .shadow_stats
+            .mark_blocked_with_reason("rate_budget_market")
+            .await;
+        return PredatorExecResult::default();
+    }
+
+    shared.shadow_stats.mark_eligible();
+    let order_build_start = Instant::now();
+    let token_id = match intent.side {
+        OrderSide::BuyYes | OrderSide::SellYes => book.token_id_yes.clone(),
+        OrderSide::BuyNo | OrderSide::SellNo => book.token_id_no.clone(),
+    };
+    let execution_style = if force_taker_now {
+        ExecutionStyle::Taker
+    } else {
+        ExecutionStyle::Maker
+    };
+    let v2_intent = OrderIntentV2 {
+        market_id: intent.market_id.clone(),
+        token_id: Some(token_id.clone()),
+        side: intent.side.clone(),
+        price: intent.price,
+        size: intent.size,
+        ttl_ms: intent.ttl_ms,
+        style: execution_style.clone(),
+        tif: if execution_style == ExecutionStyle::Maker {
+            OrderTimeInForce::PostOnly
+        } else {
+            OrderTimeInForce::Fak
+        },
+        max_slippage_bps: if execution_style == ExecutionStyle::Maker {
+            0.0
+        } else {
+            maker_cfg.taker_max_slippage_bps
+        },
+        fee_rate_bps: opp.fee_bps,
+        expected_edge_net_bps: opp.edge_net_bps,
+        client_order_id: Some(new_id()),
+        hold_to_resolution: false,
+        prebuilt_payload: None,
+    };
+    let mut v2_intent = v2_intent;
+    if execution.is_live() {
+        v2_intent.prebuilt_payload = prebuild_order_payload(&v2_intent);
+    }
+    let order_build_ms = order_build_start.elapsed().as_secs_f64() * 1_000.0;
+    let place_start = Instant::now();
+
+    let mut out = PredatorExecResult::default();
+    out.attempted = out.attempted.saturating_add(1);
+
+    match execution.place_order_v2(v2_intent).await {
+        Ok(ack_v2) if ack_v2.accepted => {
+            let accepted_size = ack_v2.accepted_size.max(0.0).min(intent.size);
+            if accepted_size <= 0.0 {
+                shared
+                    .shadow_stats
+                    .mark_blocked_with_reason("exchange_reject_zero_size")
+                    .await;
+                return out;
+            }
+            intent.size = accepted_size;
+            shared.shadow_stats.mark_executed();
+            out.executed = out.executed.saturating_add(1);
+            let accepted_notional_usdc = (intent.price.max(0.0) * intent.size.max(0.0)).max(0.0);
+            let entry_edge_usdc = (opp.edge_net_bps / 10_000.0) * accepted_notional_usdc;
+            {
+                let mut exit_mgr = shared.predator_exit_manager.write().await;
+                exit_mgr.register(PositionLifecycle {
+                    position_id: ack_v2.order_id.clone(),
+                    market_id: intent.market_id.clone(),
+                    symbol: opp.symbol.clone(),
+                    opened_at_ms: now_ms,
+                    entry_edge_usdc,
+                    entry_notional_usdc: accepted_notional_usdc,
+                });
+            }
+            spawn_predator_exit_lifecycle(
+                shared.clone(),
+                bus.clone(),
+                execution.clone(),
+                shadow.clone(),
+                ack_v2.order_id.clone(),
+                intent.market_id.clone(),
+                opp.symbol.clone(),
+                intent.side.clone(),
+                intent.price,
+                intent.size,
+                maker_cfg.ttl_ms,
+                intent.price + opp.edge_gross_bps / 10_000.0,
+            );
+
+            let ack_only_ms = if ack_v2.exchange_latency_ms > 0.0 {
+                ack_v2.exchange_latency_ms
+            } else {
+                // Keep latency visibility in non-live mode via local order path RTT.
+                place_start.elapsed().as_secs_f64() * 1_000.0
+            };
+            let tick_to_ack_ms = order_build_ms + ack_only_ms;
+            let capturable_window_ms = if ack_only_ms > 0.0 {
+                book_top_lag_ms - tick_to_ack_ms
+            } else {
+                0.0
+            };
+            if ack_only_ms > 0.0 {
+                shared.shadow_stats.push_ack_only_ms(ack_only_ms).await;
+                shared
+                    .shadow_stats
+                    .push_tick_to_ack_ms(tick_to_ack_ms)
+                    .await;
+                shared
+                    .shadow_stats
+                    .push_capturable_window_ms(capturable_window_ms)
+                    .await;
+                metrics::histogram!("latency.ack_only_ms").record(ack_only_ms);
+                metrics::histogram!("latency.tick_to_ack_ms").record(tick_to_ack_ms);
+                metrics::histogram!("latency.capturable_window_ms").record(capturable_window_ms);
+            }
+
+            let ack = OrderAck {
+                order_id: ack_v2.order_id,
+                market_id: ack_v2.market_id,
+                accepted: true,
+                ts_ms: ack_v2.ts_ms,
+            };
+            publish_if_telemetry_subscribers(bus, EngineEvent::OrderAck(ack.clone()));
+            let effective_fee_bps = if execution_style == ExecutionStyle::Maker {
+                -get_rebate_bps_cached(shared, &intent.market_id, opp.fee_bps)
+                    .await
+                    .max(0.0)
+            } else {
+                opp.fee_bps.max(0.0)
+            };
+            shadow.register_order(
+                &ack,
+                intent.clone(),
+                execution_style.clone(),
+                mid_for_side(&book, &intent.side).max(0.0),
+                effective_fee_bps,
+            );
+            if predator_cfg.v52.execution.alpha_window_enabled {
+                let anchor_price = aggressive_price_for_side(&book, &intent.side);
+                spawn_alpha_window_probe(
+                    shared.clone(),
+                    intent.market_id.clone(),
+                    intent.side.clone(),
+                    anchor_price,
+                    predator_cfg.v52.execution.alpha_window_move_bps,
+                    predator_cfg.v52.execution.alpha_window_poll_ms,
+                    predator_cfg.v52.execution.alpha_window_max_wait_ms,
+                );
+            }
+            if execution_style == ExecutionStyle::Maker && apply_force_taker_for_phase {
+                spawn_force_taker_fallback_for_maker(
+                    shared.clone(),
+                    execution.clone(),
+                    shadow.clone(),
+                    intent.market_id.clone(),
+                    token_id.clone(),
+                    intent.side.clone(),
+                    intent.size,
+                    intent.ttl_ms,
+                    ack.order_id.clone(),
+                    opp.fee_bps,
+                    opp.edge_net_bps,
+                    opp.timeframe.clone(),
+                    predator_cfg.v52.execution.late_force_taker_remaining_ms,
+                    predator_cfg.v52.execution.maker_wait_ms_before_force,
+                    maker_cfg.taker_max_slippage_bps,
+                );
+            }
+            if let Some(paper) = global_paper_runtime() {
+                let momentum_overlay = matches!(time_phase, TimePhase::Maturity)
+                    && direction_signal.velocity_bps_per_sec.abs()
+                        >= predator_cfg.direction_detector.min_velocity_bps_per_sec;
+                let stage = stage_for_phase(time_phase, momentum_overlay);
+                let (prob_fast, prob_settle) = shared
+                    .predator_latest_probability
+                    .read()
+                    .await
+                    .get(intent.market_id.as_str())
+                    .map(|p| (p.p_fast, p.p_settle))
+                    .unwrap_or((0.5, 0.5));
+                paper
+                    .register_order_intent(
+                        &ack,
+                        PaperIntentCtx {
+                            market_id: intent.market_id.clone(),
+                            symbol: opp.symbol.clone(),
+                            timeframe: opp.timeframe.to_string(),
+                            stage,
+                            direction: direction_signal.direction.clone(),
+                            velocity_bps_per_sec: direction_signal.velocity_bps_per_sec,
+                            edge_bps: opp.edge_net_bps,
+                            prob_fast,
+                            prob_settle,
+                            confidence: opp.confidence,
+                            action: PaperAction::Enter,
+                            intent: execution_style.clone(),
+                            requested_size_usdc: (intent.price * intent.size).max(0.0),
+                            requested_size_contracts: intent.size,
+                            entry_price: intent.price,
+                        },
+                    )
+                    .await;
+            }
+
+            for delay_ms in [5_u64, 10_u64, 25_u64] {
+                let shot = ShadowShot {
+                    shot_id: new_id(),
+                    market_id: intent.market_id.clone(),
+                    symbol: opp.symbol.clone(),
+                    side: intent.side.clone(),
+                    execution_style: execution_style.clone(),
+                    book_top_lag_ms,
+                    ack_only_ms,
+                    tick_to_ack_ms,
+                    capturable_window_ms,
+                    survival_probe_price: aggressive_price_for_side(&book, &intent.side),
+                    intended_price: intent.price,
+                    size: intent.size,
+                    edge_gross_bps: opp.edge_gross_bps,
+                    edge_net_bps: opp.edge_net_bps,
+                    fee_paid_bps: opp.fee_bps,
+                    rebate_est_bps: if execution_style == ExecutionStyle::Maker {
+                        get_rebate_bps_cached(shared, &intent.market_id, opp.fee_bps).await
+                    } else {
+                        0.0
+                    },
+                    delay_ms,
+                    t0_ns: now_ns(),
+                    min_edge_bps: predator_cfg.taker_sniper.min_edge_net_bps,
+                    tox_score: 0.0,
+                    ttl_ms: intent.ttl_ms,
+                };
+                shared.shadow_stats.push_shot(shot.clone()).await;
+                publish_if_telemetry_subscribers(bus, EngineEvent::ShadowShot(shot.clone()));
+                spawn_shadow_outcome_task(shared.clone(), bus.clone(), shot);
+            }
+        }
+        Ok(ack_v2) => {
+            let reject_code = ack_v2
+                .reject_code
+                .as_deref()
+                .map(normalize_reject_code)
+                .unwrap_or_else(|| "unknown".to_string());
+            shared
+                .shadow_stats
+                .mark_blocked_with_reason(&format!("exchange_reject_{reject_code}"))
+                .await;
+            metrics::counter!("execution.place_rejected").increment(1);
+            out.stop_firing = true;
+        }
+        Err(err) => {
+            let reason = classify_execution_error_reason(&err);
+            shared.shadow_stats.mark_blocked_with_reason(reason).await;
+            tracing::warn!(?err, "predator place_order failed");
+            metrics::counter!("execution.place_error").increment(1);
+        }
+    }
+
+    out
+}
diff --git a/crates/app_runner/src/tests.rs b/crates/app_runner/src/tests.rs
new file mode 100644
index 0000000..a16fc03
--- /dev/null
+++ b/crates/app_runner/src/tests.rs
@@ -0,0 +1,941 @@
+use std::collections::HashMap;
+use std::sync::atomic::{AtomicBool, Ordering};
+use std::sync::{Arc, RwLock as StdRwLock};
+use std::time::{Duration, Instant};
+
+use chrono::Utc;
+use core_types::{
+    new_id, BookTop, ControlCommand, Direction, DirectionSignal, EngineEvent, ExecutionStyle,
+    ExecutionVenue, OrderIntentV2, OrderSide, OrderTimeInForce, RefTick, Regime,
+    Stage,
+    Signal, SourceHealth, TimeframeClass, ToxicDecision, ToxicRegime,
+};
+use dashmap::DashMap;
+use direction_detector::DirectionDetector;
+use exit_manager::{ExitManager, PositionLifecycle};
+use fair_value::BasisMrConfig;
+use execution_clob::{wss_user_feed::WssFillEvent, ClobExecution, ExecutionMode};
+use infra_bus::RingBus;
+use paper_executor::ShadowExecutor;
+use probability_engine::ProbabilityEngine;
+use reqwest::Client;
+use risk_engine::{DefaultRiskManager, RiskLimits};
+use settlement_compounder::SettlementCompounder;
+use strategy_maker::MakerConfig;
+use taker_sniper::TakerSniper;
+use timeframe_router::TimeframeRouter;
+use tokio::sync::RwLock;
+use tokio::time::{sleep, timeout};
+
+use crate::config_loader::parse_toml_array_for_key;
+use crate::engine_core::normalize_reject_code;
+use crate::execution_eval::prebuild_order_payload;
+use crate::spawn_predator_exit_lifecycle;
+use crate::feed_runtime::{blend_settlement_probability, build_source_health_snapshot, SourceRuntimeStats};
+use crate::fusion_engine::{
+    compute_coalesce_policy, estimate_feed_latency, fast_tick_allowed_in_fusion_mode,
+    is_ref_tick_duplicate, reset_path_lag_calib_for_tests, should_arm_ws_primary_fallback,
+    should_enforce_udp_share_cap, should_replace_ref_tick, upsert_latest_tick_slot,
+};
+use crate::state::{
+    to_exit_manager_config, EdgeModelConfig, EngineShared, ExitConfig, FusionConfig,
+    MarketToxicState, PredatorCConfig, PredatorRegimeConfig, SettlementConfig, ShadowStats,
+    SignalCacheEntry, SourceHealthConfig, ToxicityConfig, V52DualArbConfig,
+    V52ExecutionConfig, V52TimePhaseConfig,
+};
+use crate::stats_utils::{now_ns, percentile, policy_block_ratio, quote_block_ratio, robust_filter_iqr};
+use crate::strategy_policy::{is_market_in_top_n, should_observe_only_symbol};
+use crate::strategy_runtime::{
+    allow_dual_side_arb, classify_predator_regime, classify_time_phase, should_force_taker_fallback,
+    stage_for_phase, time_phase_size_scale, timeframe_total_ms, TimePhase,
+};
+use crate::engine_loop::build_reversal_reentry_order;
+
+fn test_engine_shared_with_wss() -> (
+    Arc<EngineShared>,
+    Arc<tokio::sync::broadcast::Sender<WssFillEvent>>,
+) {
+    let strategy_cfg = Arc::new(RwLock::new(Arc::new(MakerConfig::default())));
+    let settlement_cfg = Arc::new(RwLock::new(SettlementConfig::default()));
+    let source_health_cfg = Arc::new(RwLock::new(SourceHealthConfig::default()));
+    let fusion_cfg = Arc::new(RwLock::new(FusionConfig::default()));
+    let edge_model_cfg = Arc::new(RwLock::new(EdgeModelConfig::default()));
+    let exit_cfg_value = ExitConfig {
+        enabled: true,
+        flatten_on_trigger: true,
+        ..ExitConfig::default()
+    };
+    let exit_cfg = Arc::new(RwLock::new(exit_cfg_value.clone()));
+    let fair_value_cfg = Arc::new(StdRwLock::new(BasisMrConfig::default()));
+    let toxicity_cfg = Arc::new(RwLock::new(Arc::new(ToxicityConfig::default())));
+    let risk_limits = Arc::new(StdRwLock::new(RiskLimits::default()));
+    let risk_manager = Arc::new(DefaultRiskManager::new(risk_limits.clone()));
+    let predator_cfg_value = PredatorCConfig::default();
+    let predator_cfg = Arc::new(RwLock::new(predator_cfg_value.clone()));
+    let predator_direction_detector = Arc::new(RwLock::new(DirectionDetector::new(
+        predator_cfg_value.direction_detector.clone(),
+    )));
+    let predator_probability_engine = Arc::new(RwLock::new(ProbabilityEngine::new(
+        predator_cfg_value.probability_engine.clone(),
+    )));
+    let predator_taker_sniper = Arc::new(RwLock::new(TakerSniper::new(
+        predator_cfg_value.taker_sniper.clone(),
+    )));
+    let predator_router = Arc::new(RwLock::new(TimeframeRouter::new(
+        predator_cfg_value.router.clone(),
+    )));
+    let predator_compounder = Arc::new(RwLock::new(SettlementCompounder::new(
+        predator_cfg_value.compounder.clone(),
+    )));
+    let predator_exit_manager = Arc::new(RwLock::new(ExitManager::new(to_exit_manager_config(
+        &exit_cfg_value,
+    ))));
+    let (wss_tx, _rx) = tokio::sync::broadcast::channel(64);
+    let wss_tx = Arc::new(wss_tx);
+
+    let shared = Arc::new(EngineShared {
+        latest_books: Arc::new(RwLock::new(HashMap::new())),
+        latest_signals: Arc::new(DashMap::new()),
+        latest_fast_ticks: Arc::new(DashMap::new()),
+        latest_anchor_ticks: Arc::new(DashMap::new()),
+        market_to_symbol: Arc::new(RwLock::new(HashMap::new())),
+        token_to_symbol: Arc::new(RwLock::new(HashMap::new())),
+        market_to_timeframe: Arc::new(RwLock::new(HashMap::new())),
+        symbol_to_markets: Arc::new(RwLock::new(HashMap::new())),
+        fee_cache: Arc::new(RwLock::new(HashMap::new())),
+        fee_refresh_inflight: Arc::new(RwLock::new(HashMap::new())),
+        scoring_cache: Arc::new(RwLock::new(HashMap::new())),
+        http: Client::new(),
+        clob_endpoint: "http://127.0.0.1:0".to_string(),
+        strategy_cfg,
+        settlement_cfg,
+        source_health_cfg,
+        source_health_latest: Arc::new(RwLock::new(HashMap::new())),
+        settlement_prices: Arc::new(RwLock::new(HashMap::new())),
+        fusion_cfg,
+        edge_model_cfg,
+        exit_cfg,
+        fair_value_cfg,
+        toxicity_cfg,
+        risk_manager,
+        risk_limits,
+        universe_symbols: Arc::new(vec!["BTCUSDT".to_string()]),
+        universe_market_types: Arc::new(vec!["updown".to_string()]),
+        universe_timeframes: Arc::new(vec!["5m".to_string(), "15m".to_string()]),
+        rate_limit_rps: 20.0,
+        tox_state: Arc::new(RwLock::new(HashMap::new())),
+        shadow_stats: Arc::new(ShadowStats::new()),
+        predator_cfg,
+        predator_direction_detector,
+        predator_latest_direction: Arc::new(RwLock::new(HashMap::new())),
+        predator_latest_probability: Arc::new(RwLock::new(HashMap::new())),
+        predator_probability_engine,
+        predator_taker_sniper,
+        predator_d_last_fire_ms: Arc::new(RwLock::new(HashMap::new())),
+        predator_router,
+        predator_compounder,
+        predator_exit_manager,
+        wss_fill_tx: Some(wss_tx.clone()),
+    });
+
+    (shared, wss_tx)
+}
+
+#[test]
+fn robust_filter_marks_outliers() {
+    let values = vec![1.0, 1.1, 1.2, 1.3, 99.0];
+    let (filtered, outlier_ratio) = robust_filter_iqr(&values);
+    assert!(filtered.len() < values.len());
+    assert!(outlier_ratio > 0.0);
+}
+
+#[test]
+fn robust_filter_small_sample_passthrough() {
+    let values = vec![1.0, 2.0, 3.0, 4.0];
+    let (filtered, outlier_ratio) = robust_filter_iqr(&values);
+    assert_eq!(filtered, values);
+    assert_eq!(outlier_ratio, 0.0);
+}
+
+#[test]
+fn percentile_basic_behavior() {
+    let values = vec![1.0, 5.0, 3.0, 2.0, 4.0];
+    assert_eq!(percentile(&values, 0.50), Some(3.0));
+    assert_eq!(percentile(&values, 0.0), Some(1.0));
+    assert_eq!(percentile(&values, 1.0), Some(5.0));
+}
+
+#[test]
+fn ref_tick_dedupe_uses_relative_bps_and_window() {
+    let cfg = FusionConfig {
+        dedupe_window_ms: 120,
+        dedupe_price_bps: 0.2,
+        ..FusionConfig::default()
+    };
+    assert!(is_ref_tick_duplicate(1_000, 100.001, 980, 100.0, &cfg));
+    assert!(!is_ref_tick_duplicate(1_500, 100.001, 980, 100.0, &cfg));
+    assert!(!is_ref_tick_duplicate(1_000, 100.005, 980, 100.0, &cfg));
+}
+
+#[test]
+fn websocket_primary_mode_keeps_dual_fast_sources() {
+    assert!(fast_tick_allowed_in_fusion_mode(
+        "binance_ws",
+        "websocket_primary"
+    ));
+    assert!(fast_tick_allowed_in_fusion_mode(
+        "binance_udp",
+        "websocket_primary"
+    ));
+    assert!(!fast_tick_allowed_in_fusion_mode(
+        "binance_udp",
+        "direct_only"
+    ));
+}
+
+#[test]
+fn websocket_primary_fallback_arms_only_when_ws_unavailable() {
+    assert!(should_arm_ws_primary_fallback(
+        "websocket_primary",
+        false,
+        true,
+        false
+    ));
+    assert!(!should_arm_ws_primary_fallback(
+        "websocket_primary",
+        true,
+        true,
+        false
+    ));
+    assert!(!should_arm_ws_primary_fallback(
+        "websocket_primary",
+        false,
+        true,
+        true
+    ));
+    assert!(!should_arm_ws_primary_fallback(
+        "active_active",
+        false,
+        true,
+        false
+    ));
+    assert!(!should_arm_ws_primary_fallback(
+        "websocket_primary",
+        false,
+        false,
+        false
+    ));
+}
+
+#[test]
+fn udp_share_cap_enforced_when_not_in_fallback() {
+    assert!(should_enforce_udp_share_cap(
+        "websocket_primary",
+        false,
+        true
+    ));
+    assert!(should_enforce_udp_share_cap("active_active", false, true));
+    assert!(!should_enforce_udp_share_cap(
+        "websocket_primary",
+        true,
+        true
+    ));
+    assert!(!should_enforce_udp_share_cap(
+        "websocket_primary",
+        false,
+        false
+    ));
+}
+
+#[test]
+fn fusion_default_stays_safe_baseline() {
+    let cfg = FusionConfig::default();
+    assert_eq!(cfg.mode, "direct_only");
+    assert!(cfg.enable_udp);
+    assert!(cfg.udp_share_cap > 0.0 && cfg.udp_share_cap <= 1.0);
+    assert!(cfg.jitter_threshold_ms >= 1.0);
+}
+
+#[test]
+fn reversal_taker_flatten_then_opposite_maker_reentry_order_shape() {
+    let book = BookTop {
+        market_id: "m".to_string(),
+        token_id_yes: "yes".to_string(),
+        token_id_no: "no".to_string(),
+        bid_yes: 0.48,
+        ask_yes: 0.52,
+        bid_no: 0.47,
+        ask_no: 0.53,
+        ts_ms: 1,
+        recv_ts_local_ns: 1_000_000,
+    };
+    let order = build_reversal_reentry_order("m", &OrderSide::BuyYes, &book, 2.0, 400, 2.5)
+        .expect("reentry order");
+    assert_eq!(order.side, OrderSide::BuyNo);
+    assert_eq!(order.token_id.as_deref(), Some("no"));
+    assert_eq!(order.price, book.bid_no);
+    assert_eq!(order.style, ExecutionStyle::Maker);
+    assert_eq!(order.tif, OrderTimeInForce::PostOnly);
+    assert!(order.size > 0.0);
+}
+
+#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
+async fn reversal_taker_to_opposite_maker_reentry_end_to_end_records_report() {
+    let (shared, wss_tx) = test_engine_shared_with_wss();
+    let bus = RingBus::new(256);
+    let execution = Arc::new(ClobExecution::new(
+        ExecutionMode::Paper,
+        "http://127.0.0.1:0".to_string(),
+    ));
+    let shadow = Arc::new(ShadowExecutor::default());
+    let market_id = "m_reversal".to_string();
+    let symbol = "BTCUSDT".to_string();
+    let now_ms = Utc::now().timestamp_millis();
+
+    shared.latest_books.write().await.insert(
+        market_id.clone(),
+        BookTop {
+            market_id: market_id.clone(),
+            token_id_yes: "yes_token".to_string(),
+            token_id_no: "no_token".to_string(),
+            bid_yes: 0.45,
+            ask_yes: 0.46,
+            bid_no: 0.54,
+            ask_no: 0.55,
+            ts_ms: now_ms,
+            recv_ts_local_ns: now_ns(),
+        },
+    );
+    shared.latest_signals.insert(
+        market_id.clone(),
+        SignalCacheEntry {
+            signal: Signal {
+                market_id: market_id.clone(),
+                fair_yes: 0.20,
+                edge_bps_bid: 12.0,
+                edge_bps_ask: -12.0,
+                confidence: 0.92,
+            },
+            ts_ms: now_ms,
+        },
+    );
+
+    let seen_direction_signal = Arc::new(AtomicBool::new(false));
+    let seen_flatten = Arc::new(AtomicBool::new(false));
+    let mut rx = bus.subscribe();
+    let execution_for_listener = execution.clone();
+    let seen_direction_signal_l = seen_direction_signal.clone();
+    let seen_flatten_l = seen_flatten.clone();
+    let listener = tokio::spawn(async move {
+        let deadline = Instant::now() + Duration::from_secs(3);
+        while Instant::now() < deadline {
+            match timeout(Duration::from_millis(250), rx.recv()).await {
+                Ok(Ok(EngineEvent::DirectionSignal(_))) => {
+                    seen_direction_signal_l.store(true, Ordering::Relaxed);
+                }
+                Ok(Ok(EngineEvent::Control(ControlCommand::Flatten))) => {
+                    seen_flatten_l.store(true, Ordering::Relaxed);
+                    let _ = execution_for_listener.flatten_all().await;
+                }
+                _ => {}
+            }
+        }
+    });
+
+    let _ = bus.publish(EngineEvent::DirectionSignal(DirectionSignal {
+        symbol: symbol.clone(),
+        direction: Direction::Up,
+        magnitude_pct: 0.32,
+        confidence: 0.93,
+        recommended_tf: TimeframeClass::Tf5m,
+        velocity_bps_per_sec: 12.0,
+        acceleration: 3.0,
+        tick_consistency: 4,
+        triple_confirm: true,
+        momentum_spike: true,
+        ts_ns: now_ns(),
+    }));
+
+    let entry_ack = execution
+        .place_order_v2(OrderIntentV2 {
+            market_id: market_id.clone(),
+            token_id: Some("yes_token".to_string()),
+            side: OrderSide::BuyYes,
+            price: 0.52,
+            size: 2.0,
+            ttl_ms: 500,
+            style: ExecutionStyle::Taker,
+            tif: OrderTimeInForce::Fak,
+            max_slippage_bps: 10.0,
+            fee_rate_bps: 2.0,
+            expected_edge_net_bps: 15.0,
+            client_order_id: Some(new_id()),
+            hold_to_resolution: false,
+            prebuilt_payload: None,
+        })
+        .await
+        .expect("paper entry ack");
+    assert!(entry_ack.accepted);
+
+    {
+        let mut manager = shared.predator_exit_manager.write().await;
+        manager.register(PositionLifecycle {
+            position_id: entry_ack.order_id.clone(),
+            market_id: market_id.clone(),
+            symbol: symbol.clone(),
+            opened_at_ms: now_ms,
+            entry_edge_usdc: 0.20,
+            entry_notional_usdc: 1.04,
+        });
+    }
+
+    spawn_predator_exit_lifecycle(
+        shared.clone(),
+        bus.clone(),
+        execution.clone(),
+        shadow,
+        entry_ack.order_id.clone(),
+        market_id.clone(),
+        symbol.clone(),
+        OrderSide::BuyYes,
+        0.52,
+        2.0,
+        500,
+        0.70,
+    );
+
+    sleep(Duration::from_millis(120)).await;
+    let _ = wss_tx.send(WssFillEvent {
+        order_id: entry_ack.order_id.clone(),
+        market_id: market_id.clone(),
+        price: 0.45,
+        size: 2.0,
+        event_type: "trade",
+        ts_ms: Utc::now().timestamp_millis(),
+    });
+    sleep(Duration::from_millis(900)).await;
+    let _ = listener.await;
+
+    let report = shared.shadow_stats.build_live_report().await;
+    let has_reversal_reason = report.exit_reason_top.iter().any(|(reason, count)| {
+        *count > 0 && (reason == "t_plus_100ms_reversal" || reason == "t_plus_300ms_reversal")
+    });
+
+    assert!(
+        seen_direction_signal.load(Ordering::Relaxed),
+        "direction signal stage must be observed"
+    );
+    assert!(
+        seen_flatten.load(Ordering::Relaxed),
+        "reversal path must publish flatten control"
+    );
+    assert!(
+        has_reversal_reason,
+        "live report must record reversal exit reason"
+    );
+    assert!(
+        report.executed_count >= 1,
+        "live report must include executed re-entry orders"
+    );
+}
+
+#[test]
+fn normalize_reject_code_sanitizes_non_alnum() {
+    let normalized = normalize_reject_code("HTTP 429/Too Many Requests");
+    assert_eq!(normalized, "http_429_too_many_requests");
+}
+
+#[test]
+fn estimate_feed_latency_separates_source_and_backlog() {
+    reset_path_lag_calib_for_tests();
+    let now = now_ns();
+    let now_ms = now / 1_000_000;
+    let tick = RefTick {
+        source: "binance_ws".to_string().into(),
+        symbol: "BTCUSDT".to_string(),
+        source_seq: now_ms as u64,
+        event_ts_ms: now_ms - 300,
+        recv_ts_ms: now_ms - 200,
+        event_ts_exchange_ms: now_ms - 300,
+        recv_ts_local_ns: now - 200_000_000,
+        ingest_ts_local_ns: now - 198_000_000,
+        ts_first_hop_ms: None,
+        price: 70_000.0,
+    };
+    let book = BookTop {
+        market_id: "m".to_string(),
+        token_id_yes: "yes".to_string(),
+        token_id_no: "no".to_string(),
+        bid_yes: 0.49,
+        ask_yes: 0.51,
+        bid_no: 0.49,
+        ask_no: 0.51,
+        ts_ms: now_ms - 40,
+        recv_ts_local_ns: now - 20_000_000,
+    };
+
+    let sample = estimate_feed_latency(&tick, &book);
+    assert!(sample.source_latency_ms >= 95.0);
+    assert!(sample.source_latency_ms <= 110.0);
+    assert!(sample.local_backlog_ms >= 10.0);
+    assert!(sample.local_backlog_ms <= 40.0);
+    assert!(sample.feed_in_ms >= 1.0);
+    assert!(sample.feed_in_ms <= 4.0);
+    assert!((sample.feed_in_ms - sample.ref_decode_ms).abs() < 0.0001);
+}
+
+#[test]
+fn estimate_feed_latency_calibrates_path_lag_with_clock_offset() {
+    reset_path_lag_calib_for_tests();
+    let now = now_ns();
+    let now_ms = now / 1_000_000;
+    let book = BookTop {
+        market_id: "m".to_string(),
+        token_id_yes: "yes".to_string(),
+        token_id_no: "no".to_string(),
+        bid_yes: 0.49,
+        ask_yes: 0.51,
+        bid_no: 0.49,
+        ask_no: 0.51,
+        ts_ms: now_ms - 10,
+        recv_ts_local_ns: now - 5_000_000,
+    };
+
+    // First sample establishes floor with a negative raw delta (clock skew baseline).
+    let tick_floor = RefTick {
+        source: "binance_udp_calib".to_string().into(),
+        symbol: "BTCUSDT".to_string(),
+        source_seq: 1,
+        event_ts_ms: now_ms - 120,
+        recv_ts_ms: now_ms - 100,
+        event_ts_exchange_ms: now_ms - 120,
+        recv_ts_local_ns: now - 100_000_000,
+        ingest_ts_local_ns: now - 99_000_000,
+        ts_first_hop_ms: Some(now_ms - 90),
+        price: 70_000.0,
+    };
+    let first = estimate_feed_latency(&tick_floor, &book);
+    assert!(first.path_lag_ms <= 0.01);
+
+    // Second sample has larger delta and should show positive path lag after calibration.
+    let tick_next = RefTick {
+        source_seq: 2,
+        recv_ts_ms: now_ms - 80,
+        ts_first_hop_ms: Some(now_ms - 95),
+        ..tick_floor.clone()
+    };
+    let second = estimate_feed_latency(&tick_next, &book);
+    assert!(second.path_lag_ms >= 20.0);
+    assert!(second.path_lag_ms <= 35.0);
+}
+
+#[test]
+fn should_replace_ref_tick_respects_staleness_budget_for_same_event() {
+    let current = RefTick {
+        source: "binance_ws".to_string().into(),
+        symbol: "BTCUSDT".to_string(),
+        source_seq: 10,
+        event_ts_ms: 1_000,
+        recv_ts_ms: 1_010,
+        event_ts_exchange_ms: 1_000,
+        recv_ts_local_ns: 1_000_000_000,
+        ingest_ts_local_ns: 1_000_100_000,
+        ts_first_hop_ms: None,
+        price: 100.0,
+    };
+    let mut next = current.clone();
+    next.source = "binance_udp".to_string().into();
+    next.recv_ts_local_ns = current.recv_ts_local_ns + 2_000_000;
+    next.recv_ts_ms = current.recv_ts_ms + 2;
+
+    assert!(!should_replace_ref_tick(&current, &next));
+}
+
+#[test]
+fn upsert_latest_tick_slot_reports_source_switch_delta() {
+    let ticks = DashMap::<String, RefTick>::new();
+    let first = RefTick {
+        source: "binance_ws".to_string().into(),
+        symbol: "BTCUSDT".to_string(),
+        source_seq: 1,
+        event_ts_ms: 1_000,
+        recv_ts_ms: 1_010,
+        event_ts_exchange_ms: 1_000,
+        recv_ts_local_ns: 1_000_000_000,
+        ingest_ts_local_ns: 1_000_050_000,
+        ts_first_hop_ms: None,
+        price: 100.0,
+    };
+    let mut second = first.clone();
+    second.source = "binance_udp".to_string().into();
+    second.event_ts_exchange_ms += 2;
+    second.recv_ts_ms += 1;
+    second.recv_ts_local_ns += 400_000;
+    second.price = 100.2;
+
+    let first_delta = upsert_latest_tick_slot(&ticks, first, should_replace_ref_tick);
+    assert!(first_delta.is_none());
+    let second_delta = upsert_latest_tick_slot(&ticks, second, should_replace_ref_tick);
+    assert_eq!(second_delta, Some(400_000));
+}
+
+#[test]
+fn sol_guard_observe_only_for_high_latency_or_spread() {
+    let mut cfg = MakerConfig::default();
+    cfg.market_tier_profile = "balanced_sol_guard".to_string();
+    let tox = ToxicDecision {
+        market_id: "m".to_string(),
+        symbol: "SOLUSDT".to_string(),
+        tox_score: 0.2,
+        regime: ToxicRegime::Safe,
+        reason_codes: vec![],
+        ts_ns: 1,
+    };
+    assert!(should_observe_only_symbol(
+        "SOLUSDT", &cfg, &tox, 120.0, 0.01, 180.0
+    ));
+    assert!(should_observe_only_symbol(
+        "SOLUSDT", &cfg, &tox, 320.0, 0.01, 80.0
+    ));
+    assert!(should_observe_only_symbol(
+        "SOLUSDT", &cfg, &tox, 120.0, 0.03, 80.0
+    ));
+    assert!(!should_observe_only_symbol(
+        "SOLUSDT", &cfg, &tox, 120.0, 0.01, 80.0
+    ));
+    assert!(!should_observe_only_symbol(
+        "BTCUSDT", &cfg, &tox, 260.0, 0.03, 999.0
+    ));
+}
+
+#[test]
+fn quote_block_ratio_matches_contract_and_is_bounded() {
+    assert_eq!(quote_block_ratio(0, 0), 0.0);
+    assert_eq!(quote_block_ratio(10, 0), 0.0);
+    assert_eq!(quote_block_ratio(0, 10), 1.0);
+
+    let r = quote_block_ratio(10, 2);
+    assert!(r > 0.0 && r < 1.0);
+}
+
+#[test]
+fn policy_block_ratio_matches_contract_and_is_bounded() {
+    assert_eq!(policy_block_ratio(0, 0), 0.0);
+    assert_eq!(policy_block_ratio(10, 0), 0.0);
+    assert_eq!(policy_block_ratio(0, 10), 1.0);
+
+    let r = policy_block_ratio(10, 2);
+    assert!(r > 0.0 && r < 1.0);
+}
+
+#[test]
+fn uptime_pct_is_bounded() {
+    let stats = ShadowStats::new();
+    let u = stats.uptime_pct(Duration::from_secs(1));
+    assert!((0.0..=100.0).contains(&u));
+}
+
+#[test]
+fn parse_toml_array_for_key_handles_multiline_arrays() {
+    let raw = r#"
+assets = [
+  "BTCUSDT",
+  "ETHUSDT",
+  "XRPUSDT",
+]
+market_types = ["updown", "range"]
+timeframes = ["5m", "15m", "1h", "1d"]
+"#;
+    let assets = parse_toml_array_for_key(raw, "assets").unwrap_or_default();
+    assert_eq!(
+        assets,
+        vec![
+            "BTCUSDT".to_string(),
+            "ETHUSDT".to_string(),
+            "XRPUSDT".to_string()
+        ]
+    );
+    let market_types = parse_toml_array_for_key(raw, "market_types").unwrap_or_default();
+    assert_eq!(
+        market_types,
+        vec!["updown".to_string(), "range".to_string()]
+    );
+    let timeframes = parse_toml_array_for_key(raw, "timeframes").unwrap_or_default();
+    assert_eq!(
+        timeframes,
+        vec![
+            "5m".to_string(),
+            "15m".to_string(),
+            "1h".to_string(),
+            "1d".to_string()
+        ]
+    );
+}
+
+#[test]
+fn parse_toml_array_for_key_returns_none_for_missing_or_empty() {
+    let raw = "foo = 1\nassets = []\n";
+    assert!(parse_toml_array_for_key(raw, "missing").is_none());
+    assert!(parse_toml_array_for_key(raw, "assets").is_none());
+}
+
+#[test]
+fn blend_settlement_probability_moves_toward_half_when_gap_widens() {
+    let p_small_gap = blend_settlement_probability(0.80, 100.0, 99.9);
+    let p_large_gap = blend_settlement_probability(0.80, 100.0, 97.5);
+    assert!(p_small_gap > 0.70);
+    assert!(p_large_gap < p_small_gap);
+    assert!(p_large_gap > 0.50);
+}
+
+#[test]
+fn blend_settlement_probability_is_stable_when_prices_match() {
+    let p = blend_settlement_probability(0.63, 100.0, 100.0);
+    assert!((p - 0.63).abs() < 1e-9);
+}
+
+#[test]
+fn source_health_snapshot_penalizes_bad_stream() {
+    let cfg = SourceHealthConfig::default();
+    let stats = SourceRuntimeStats {
+        sample_count: 256,
+        latency_sum_ms: 256.0 * 24.0,
+        latency_sq_sum_ms: 256.0 * (24.0f64.powi(2) + 18.0f64.powi(2)),
+        out_of_order_count: 12,
+        gap_count: 16,
+        last_event_ts_ms: 1_699_999_994_900,
+        last_recv_ts_ms: 1_699_999_995_000,
+        deviation_ema_bps: 80.0,
+    };
+    let row = build_source_health_snapshot("binance", &stats, &cfg, 1_700_000_000_000);
+    assert!(row.score < 0.45);
+    assert!(row.gap_rate > 0.01);
+    assert!(row.out_of_order_rate > 0.01);
+    assert!(row.jitter_ms > cfg.jitter_limit_ms);
+    assert!(row.freshness_score < 0.5);
+}
+
+#[test]
+fn source_health_snapshot_stays_high_for_clean_stream() {
+    let cfg = SourceHealthConfig::default();
+    let stats = SourceRuntimeStats {
+        sample_count: 512,
+        latency_sum_ms: 512.0 * 4.0,
+        latency_sq_sum_ms: 512.0 * (4.0f64.powi(2) + 0.8f64.powi(2)),
+        out_of_order_count: 0,
+        gap_count: 0,
+        last_event_ts_ms: 1_699_999_999_996,
+        last_recv_ts_ms: 1_699_999_999_998,
+        deviation_ema_bps: 3.0,
+    };
+    let row = build_source_health_snapshot("coinbase", &stats, &cfg, 1_700_000_000_000);
+    assert!(row.score > 0.75);
+    assert!(row.jitter_ms < cfg.jitter_limit_ms);
+    assert!(row.price_deviation_bps < cfg.deviation_limit_bps);
+    assert!(row.freshness_score > 0.9);
+}
+
+#[test]
+fn classify_predator_regime_defend_on_toxicity_or_source_health() {
+    let cfg = PredatorRegimeConfig::default();
+    let source_cfg = SourceHealthConfig::default();
+    let signal = DirectionSignal {
+        symbol: "BTCUSDT".to_string(),
+        direction: Direction::Up,
+        magnitude_pct: 0.25,
+        confidence: 0.92,
+        recommended_tf: TimeframeClass::Tf15m,
+        velocity_bps_per_sec: 10.0,
+        acceleration: 1.0,
+        tick_consistency: 3,
+        triple_confirm: true,
+        momentum_spike: false,
+        ts_ns: 1,
+    };
+
+    let regime_tox =
+        classify_predator_regime(&cfg, &signal, 0.95, &ToxicRegime::Danger, None, &source_cfg);
+    assert_eq!(regime_tox, Regime::Defend);
+
+    let source_low = SourceHealth {
+        source: "binance_udp".to_string(),
+        latency_ms: 20.0,
+        jitter_ms: 5.0,
+        out_of_order_rate: 0.0,
+        gap_rate: 0.0,
+        price_deviation_bps: 0.0,
+        freshness_score: 1.0,
+        score: 0.10,
+        sample_count: source_cfg.min_samples,
+        ts_ms: 1,
+    };
+    let regime_source = classify_predator_regime(
+        &cfg,
+        &signal,
+        0.10,
+        &ToxicRegime::Safe,
+        Some(&source_low),
+        &source_cfg,
+    );
+    assert_eq!(regime_source, Regime::Defend);
+}
+
+#[test]
+fn classify_predator_regime_switches_between_active_and_quiet() {
+    let cfg = PredatorRegimeConfig::default();
+    let source_cfg = SourceHealthConfig::default();
+    let mut active_signal = DirectionSignal {
+        symbol: "BTCUSDT".to_string(),
+        direction: Direction::Up,
+        magnitude_pct: 0.20,
+        confidence: 0.85,
+        recommended_tf: TimeframeClass::Tf5m,
+        velocity_bps_per_sec: 8.0,
+        acceleration: 1.2,
+        tick_consistency: 3,
+        triple_confirm: true,
+        momentum_spike: false,
+        ts_ns: 1,
+    };
+
+    let active = classify_predator_regime(
+        &cfg,
+        &active_signal,
+        0.15,
+        &ToxicRegime::Safe,
+        None,
+        &source_cfg,
+    );
+    assert_eq!(active, Regime::Active);
+
+    active_signal.confidence = 0.45;
+    active_signal.magnitude_pct = 0.02;
+    let quiet = classify_predator_regime(
+        &cfg,
+        &active_signal,
+        0.10,
+        &ToxicRegime::Safe,
+        None,
+        &source_cfg,
+    );
+    assert_eq!(quiet, Regime::Quiet);
+}
+
+#[test]
+fn is_market_in_top_n_matches_score_order_without_sorting() {
+    let mut states = HashMap::<String, MarketToxicState>::new();
+    let mut s1 = MarketToxicState::default();
+    s1.market_score = 95.0;
+    states.insert("m1".to_string(), s1);
+    let mut s2 = MarketToxicState::default();
+    s2.market_score = 88.0;
+    states.insert("m2".to_string(), s2);
+    let mut s3 = MarketToxicState::default();
+    s3.market_score = 70.0;
+    states.insert("m3".to_string(), s3);
+
+    assert!(is_market_in_top_n(&states, "m1", 1));
+    assert!(!is_market_in_top_n(&states, "m2", 1));
+    assert!(is_market_in_top_n(&states, "m2", 2));
+    assert!(!is_market_in_top_n(&states, "m3", 2));
+}
+
+#[test]
+fn prebuild_order_payload_uses_intent_tif_and_style() {
+    let intent = OrderIntentV2 {
+        market_id: "m1".to_string(),
+        side: OrderSide::BuyYes,
+        token_id: Some("t1".to_string()),
+        price: 0.52,
+        size: 5.0,
+        ttl_ms: 120,
+        style: ExecutionStyle::Maker,
+        tif: OrderTimeInForce::PostOnly,
+        client_order_id: Some("cid1".to_string()),
+        max_slippage_bps: 12.0,
+        fee_rate_bps: 2.0,
+        expected_edge_net_bps: 8.0,
+        hold_to_resolution: false,
+        prebuilt_payload: None,
+    };
+    let bytes = prebuild_order_payload(&intent).expect("payload");
+    let value: serde_json::Value = serde_json::from_slice(&bytes).expect("json");
+    assert_eq!(value["style"], "maker");
+    assert_eq!(value["tif"], "POST_ONLY");
+    assert_eq!(value["token_id"], "t1");
+}
+
+#[test]
+fn compute_coalesce_policy_skips_for_shallow_queue() {
+    let p = compute_coalesce_policy(3, Some(10.0), 96, 4, 200);
+    assert_eq!(p.max_events, 0);
+    assert_eq!(p.budget_us, 0);
+}
+
+#[test]
+fn compute_coalesce_policy_scales_for_deep_queue() {
+    let p = compute_coalesce_policy(40, Some(50.0), 96, 4, 200);
+    assert!(p.max_events >= 24);
+    assert!(p.max_events <= 40);
+    assert_eq!(p.budget_us, 160);
+
+    let fast = compute_coalesce_policy(40, Some(10.0), 96, 4, 200);
+    assert_eq!(fast.budget_us, 40);
+}
+
+#[test]
+fn compute_coalesce_policy_uses_drain_mode_for_very_deep_queue() {
+    let p = compute_coalesce_policy(200, Some(60.0), 256, 4, 120);
+    assert_eq!(p.max_events, 200);
+    assert_eq!(p.budget_us, 800);
+}
+
+#[test]
+fn v52_time_phase_boundaries_for_5m_and_15m() {
+    let cfg = V52TimePhaseConfig::default();
+    let tf_5m_total = timeframe_total_ms(TimeframeClass::Tf5m).expect("5m total");
+    let tf_15m_total = timeframe_total_ms(TimeframeClass::Tf15m).expect("15m total");
+    assert_eq!(tf_5m_total, 300_000);
+    assert_eq!(tf_15m_total, 900_000);
+
+    assert_eq!(classify_time_phase(0.56, &cfg), TimePhase::Early);
+    assert_eq!(classify_time_phase(0.55, &cfg), TimePhase::Maturity);
+    assert_eq!(classify_time_phase(0.11, &cfg), TimePhase::Maturity);
+    assert_eq!(classify_time_phase(0.10, &cfg), TimePhase::Late);
+    assert_eq!(classify_time_phase(0.01, &cfg), TimePhase::Late);
+}
+
+#[test]
+fn v52_momentum_overlay_only_in_maturity() {
+    assert_eq!(stage_for_phase(TimePhase::Early, true), Stage::Early);
+    assert_eq!(stage_for_phase(TimePhase::Late, true), Stage::Late);
+    assert_eq!(stage_for_phase(TimePhase::Maturity, false), Stage::Maturity);
+    assert_eq!(stage_for_phase(TimePhase::Maturity, true), Stage::Momentum);
+}
+
+#[test]
+fn v52_phase_size_scale_is_configurable() {
+    let mut cfg = V52TimePhaseConfig::default();
+    cfg.early_size_scale = 0.7;
+    cfg.maturity_size_scale = 1.1;
+    cfg.late_size_scale = 1.4;
+    assert!((time_phase_size_scale(TimePhase::Early, &cfg) - 0.7).abs() < 1e-9);
+    assert!((time_phase_size_scale(TimePhase::Maturity, &cfg) - 1.1).abs() < 1e-9);
+    assert!((time_phase_size_scale(TimePhase::Late, &cfg) - 1.4).abs() < 1e-9);
+}
+
+#[test]
+fn v52_force_taker_rule_applies_to_maturity_and_late() {
+    let cfg = V52ExecutionConfig::default();
+    assert!(!should_force_taker_fallback(TimePhase::Early, 29_000, &cfg));
+    assert!(should_force_taker_fallback(TimePhase::Maturity, 29_000, &cfg));
+    assert!(should_force_taker_fallback(TimePhase::Late, 29_000, &cfg));
+    assert!(!should_force_taker_fallback(TimePhase::Maturity, 31_000, &cfg));
+}
+
+#[test]
+fn v52_dual_arb_threshold_formula() {
+    let cfg = V52DualArbConfig::default();
+    assert!(allow_dual_side_arb(0.40, 0.40, 2.0, &cfg));
+    assert!(!allow_dual_side_arb(0.50, 0.49, 2.0, &cfg));
+}
diff --git a/crates/app_runner/src/toxicity_report.rs b/crates/app_runner/src/toxicity_report.rs
new file mode 100644
index 0000000..cbb376a
--- /dev/null
+++ b/crates/app_runner/src/toxicity_report.rs
@@ -0,0 +1,106 @@
+use std::collections::HashMap;
+use std::sync::Arc;
+
+use chrono::Utc;
+use core_types::ToxicRegime;
+use execution_clob::ClobExecution;
+use tokio::sync::RwLock;
+
+use crate::state::{
+    MarketToxicState, ShadowStats, ToxicityConfig, ToxicityLiveReport, ToxicityMarketRow,
+};
+use crate::stats_utils::percentile_deque_capped;
+use crate::strategy_policy::compute_market_score;
+
+pub(super) async fn build_toxicity_live_report(
+    tox_state: Arc<RwLock<HashMap<String, MarketToxicState>>>,
+    shadow_stats: Arc<ShadowStats>,
+    execution: Arc<ClobExecution>,
+    toxicity_cfg: Arc<RwLock<Arc<ToxicityConfig>>>,
+) -> ToxicityLiveReport {
+    let cfg = toxicity_cfg.read().await.clone();
+    let states = tox_state.read().await.clone();
+    let shots = shadow_stats.shots.read().await.clone();
+    let outcomes = shadow_stats.outcomes.read().await.clone();
+
+    let mut rows = Vec::<ToxicityMarketRow>::new();
+    let mut safe = 0usize;
+    let mut caution = 0usize;
+    let mut danger = 0usize;
+    let mut tox_sum = 0.0;
+
+    for (market_id, st) in states {
+        let symbol = if !st.symbol.is_empty() {
+            st.symbol.clone()
+        } else {
+            shots
+                .iter()
+                .find(|s| s.market_id == market_id)
+                .map(|s| s.symbol.clone())
+                .or_else(|| {
+                    outcomes
+                        .iter()
+                        .find(|o| o.market_id == market_id)
+                        .map(|o| o.symbol.clone())
+                })
+                .unwrap_or_else(|| "UNKNOWN".to_string())
+        };
+        let attempted = st.attempted.max(1);
+        let no_quote_rate = st.no_quote as f64 / attempted as f64;
+        let symbol_missing_rate = st.symbol_missing as f64 / attempted as f64;
+        let markout_10s_bps = percentile_deque_capped(&st.markout_10s, 0.50, 2048).unwrap_or(0.0);
+        let markout_samples = st
+            .markout_1s
+            .len()
+            .max(st.markout_5s.len())
+            .max(st.markout_10s.len());
+        let market_score = if st.market_score > 0.0 {
+            st.market_score
+        } else {
+            compute_market_score(&st, st.last_tox_score, markout_samples)
+        };
+        let pending_exposure = execution.open_order_notional_for_market(&market_id);
+
+        tox_sum += st.last_tox_score;
+        match st.last_regime {
+            ToxicRegime::Safe => safe += 1,
+            ToxicRegime::Caution => caution += 1,
+            ToxicRegime::Danger => danger += 1,
+        }
+
+        rows.push(ToxicityMarketRow {
+            market_rank: 0,
+            market_id,
+            symbol,
+            tox_score: st.last_tox_score,
+            regime: st.last_regime,
+            market_score,
+            markout_10s_bps,
+            no_quote_rate,
+            symbol_missing_rate,
+            pending_exposure,
+            active_for_quoting: false,
+        });
+    }
+
+    rows.sort_by(|a, b| b.market_score.total_cmp(&a.market_score));
+    let top_n = cfg.active_top_n_markets;
+    for (idx, row) in rows.iter_mut().enumerate() {
+        row.market_rank = idx + 1;
+        row.active_for_quoting = top_n == 0 || (idx < top_n);
+    }
+    let avg = if rows.is_empty() {
+        0.0
+    } else {
+        tox_sum / (rows.len() as f64)
+    };
+
+    ToxicityLiveReport {
+        ts_ms: Utc::now().timestamp_millis(),
+        average_tox_score: avg,
+        safe_count: safe,
+        caution_count: caution,
+        danger_count: danger,
+        rows,
+    }
+}
diff --git a/crates/app_runner/src/toxicity_runtime.rs b/crates/app_runner/src/toxicity_runtime.rs
new file mode 100644
index 0000000..268f4e6
--- /dev/null
+++ b/crates/app_runner/src/toxicity_runtime.rs
@@ -0,0 +1,39 @@
+use std::collections::VecDeque;
+
+use core_types::ShadowOutcome;
+
+use crate::state::EngineShared;
+use crate::strategy_policy::compute_market_score;
+
+pub(super) async fn update_toxic_state_from_outcome(
+    shared: &EngineShared,
+    outcome: &ShadowOutcome,
+) {
+    if !outcome.fillable || outcome.delay_ms != 10 {
+        return;
+    }
+    let mut states = shared.tox_state.write().await;
+    let st = states.entry(outcome.market_id.clone()).or_default();
+    if let Some(v) = outcome.net_markout_1s_bps.or(outcome.pnl_1s_bps) {
+        push_rolling(&mut st.markout_1s, v, 2048);
+    }
+    if let Some(v) = outcome.net_markout_5s_bps.or(outcome.pnl_5s_bps) {
+        push_rolling(&mut st.markout_5s, v, 2048);
+    }
+    if let Some(v) = outcome.net_markout_10s_bps.or(outcome.pnl_10s_bps) {
+        push_rolling(&mut st.markout_10s, v, 2048);
+    }
+    let samples = st
+        .markout_1s
+        .len()
+        .max(st.markout_5s.len())
+        .max(st.markout_10s.len());
+    st.market_score = compute_market_score(st, st.last_tox_score, samples);
+}
+
+pub(super) fn push_rolling(dst: &mut VecDeque<f64>, value: f64, cap: usize) {
+    dst.push_back(value);
+    while dst.len() > cap {
+        dst.pop_front();
+    }
+}
diff --git a/crates/core_types/Cargo.toml b/crates/core_types/Cargo.toml
index 8103336..c788fb7 100644
--- a/crates/core_types/Cargo.toml
+++ b/crates/core_types/Cargo.toml
@@ -11,5 +11,6 @@ chrono.workspace = true
 futures.workspace = true
 serde.workspace = true
 serde_json.workspace = true
+smol_str.workspace = true
 thiserror.workspace = true
 uuid.workspace = true
diff --git a/crates/core_types/src/lib.rs b/crates/core_types/src/lib.rs
index cb13499..37d9708 100644
--- a/crates/core_types/src/lib.rs
+++ b/crates/core_types/src/lib.rs
@@ -5,19 +5,30 @@ use async_trait::async_trait;
 use chrono::{DateTime, Utc};
 use futures::stream::BoxStream;
 use serde::{Deserialize, Serialize};
+use smol_str::SmolStr;
 use thiserror::Error;
 use uuid::Uuid;
 
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
 pub struct RefTick {
-    pub source: String,
+    pub source: SmolStr,
     pub symbol: String,
     pub event_ts_ms: i64,
     pub recv_ts_ms: i64,
     #[serde(default)]
+    pub source_seq: u64,
+    #[serde(default)]
     pub event_ts_exchange_ms: i64,
     #[serde(default)]
     pub recv_ts_local_ns: i64,
+    /// Local timestamp taken after decoding/parsing and right before enqueueing/publishing.
+    /// This enables measuring pure local decode/ingest latency independent of exchange clocks.
+    #[serde(default)]
+    pub ingest_ts_local_ns: i64,
+    /// First-hop local timestamp recorded at Tokyo relay ingress.
+    /// Used to split exchange-lag vs private-path-lag in reports.
+    #[serde(default)]
+    pub ts_first_hop_ms: Option<i64>,
     pub price: f64,
 }
 
@@ -99,6 +110,136 @@ pub struct Signal {
     pub confidence: f64,
 }
 
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
+pub enum TimeframeClass {
+    Tf5m,
+    Tf15m,
+    Tf1h,
+    Tf1d,
+}
+
+impl fmt::Display for TimeframeClass {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let value = match self {
+            Self::Tf5m => "5m",
+            Self::Tf15m => "15m",
+            Self::Tf1h => "1h",
+            Self::Tf1d => "1d",
+        };
+        f.write_str(value)
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
+pub enum Direction {
+    Up,
+    Down,
+    Neutral,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct DirectionSignal {
+    pub symbol: String,
+    pub direction: Direction,
+    /// Price move magnitude in percentage points, e.g. 0.35 means +0.35%.
+    pub magnitude_pct: f64,
+    /// Confidence in [0,1], derived from multi-source consistency.
+    pub confidence: f64,
+    pub recommended_tf: TimeframeClass,
+    /// First derivative of price move in bps/s.
+    #[serde(default)]
+    pub velocity_bps_per_sec: f64,
+    /// Second derivative in (bps/s)/s.
+    #[serde(default)]
+    pub acceleration: f64,
+    /// Count of consecutive same-direction ticks used by the triple-confirm gate.
+    #[serde(default)]
+    pub tick_consistency: u8,
+    /// Whether the triple-confirm gate passed (velocity + acceleration/volume + consecutive ticks).
+    /// Used by downstream scorers (e.g. WinRateScore) to assess signal quality.
+    #[serde(default)]
+    pub triple_confirm: bool,
+    /// Whether the velocity exceeded the momentum-spike multiplier threshold.
+    #[serde(default)]
+    pub momentum_spike: bool,
+    pub ts_ns: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct CapitalUpdate {
+    pub available_usdc: f64,
+    /// "Base quote size" used by Predator C+ sizing logic. Interpreted as USDC notional.
+    pub base_quote_size: f64,
+    pub ts_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ProbabilityEstimate {
+    pub p_fast: f64,
+    pub p_settle: f64,
+    pub confidence: f64,
+    #[serde(default)]
+    pub settlement_source_degraded: bool,
+    pub ts_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
+#[serde(rename_all = "snake_case")]
+pub enum Stage {
+    Early,
+    Momentum,
+    Maturity,
+    Late,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ExecutionIntent {
+    pub market_id: String,
+    pub symbol: String,
+    pub side: OrderSide,
+    pub style: ExecutionStyle,
+    pub stage: Stage,
+    pub edge_net_bps: f64,
+    pub confidence: f64,
+    pub ts_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct SourceHealth {
+    pub source: String,
+    pub latency_ms: f64,
+    pub jitter_ms: f64,
+    pub out_of_order_rate: f64,
+    pub gap_rate: f64,
+    pub price_deviation_bps: f64,
+    #[serde(default)]
+    pub freshness_score: f64,
+    pub score: f64,
+    #[serde(default)]
+    pub sample_count: u64,
+    #[serde(default)]
+    pub ts_ms: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct TimeframeOpp {
+    pub timeframe: TimeframeClass,
+    pub market_id: String,
+    pub symbol: String,
+    pub direction: Direction,
+    pub side: OrderSide,
+    pub entry_price: f64,
+    pub size: f64,
+    pub edge_gross_bps: f64,
+    pub edge_net_bps: f64,
+    pub edge_net_usdc: f64,
+    pub fee_bps: f64,
+    pub lock_minutes: f64,
+    pub density: f64,
+    pub confidence: f64,
+    pub ts_ms: i64,
+}
+
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
 pub enum OrderSide {
     BuyYes,
@@ -188,6 +329,8 @@ pub struct OrderAck {
 pub struct OrderIntentV2 {
     pub market_id: String,
     pub side: OrderSide,
+    #[serde(default)]
+    pub token_id: Option<String>,
     pub price: f64,
     pub size: f64,
     pub ttl_ms: u64,
@@ -196,6 +339,8 @@ pub struct OrderIntentV2 {
     #[serde(default = "default_order_tif")]
     pub tif: OrderTimeInForce,
     #[serde(default)]
+    pub client_order_id: Option<String>,
+    #[serde(default)]
     pub max_slippage_bps: f64,
     #[serde(default)]
     pub fee_rate_bps: f64,
@@ -203,6 +348,11 @@ pub struct OrderIntentV2 {
     pub expected_edge_net_bps: f64,
     #[serde(default)]
     pub hold_to_resolution: bool,
+    /// B: È¢ÑÂ∫èÂàóÂåñ JSON payload ‚Äî Âú®‰ø°Âè∑Á°ÆËÆ§ÂêéÁ´ãÂç≥ÊûÑÂª∫ÔºåË∑≥Ëøá place_order_v2 ÈáåÁöÑ serde ÂºÄÈîÄ„ÄÇ
+    /// ËÆæÁΩÆÂêé execution_clob Áõ¥Êé•Áî®Ê≠§Â≠óËäÇ‰∏≤‰Ωú‰∏∫ HTTP bodyÔºå‰∏çÂÜçÈáçÊñ∞Â∫èÂàóÂåñ„ÄÇ
+    /// `None` Êó∂ÂõûÈÄÄÂà∞ÂéüÂßãÂ∫èÂàóÂåñË∑ØÂæÑÔºå‰øùËØÅÂêëÂêéÂÖºÂÆπ„ÄÇ
+    #[serde(skip)]
+    pub prebuilt_payload: Option<Vec<u8>>,
 }
 
 impl From<QuoteIntent> for OrderIntentV2 {
@@ -210,15 +360,18 @@ impl From<QuoteIntent> for OrderIntentV2 {
         Self {
             market_id: value.market_id,
             side: value.side,
+            token_id: None,
             price: value.price,
             size: value.size,
             ttl_ms: value.ttl_ms,
             style: ExecutionStyle::Maker,
             tif: OrderTimeInForce::PostOnly,
+            client_order_id: None,
             max_slippage_bps: 0.0,
             fee_rate_bps: 0.0,
             expected_edge_net_bps: 0.0,
             hold_to_resolution: false,
+            prebuilt_payload: None,
         }
     }
 }
@@ -242,12 +395,142 @@ pub struct FillEvent {
     pub order_id: String,
     pub market_id: String,
     pub side: OrderSide,
+    #[serde(default = "default_execution_style")]
+    pub style: ExecutionStyle,
     pub price: f64,
     pub size: f64,
     pub fee: f64,
+    #[serde(default)]
+    pub mid_price: Option<f64>,
+    #[serde(default)]
+    pub slippage_bps: Option<f64>,
     pub ts_ms: i64,
 }
 
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
+#[serde(rename_all = "snake_case")]
+pub enum PaperAction {
+    Enter,
+    Add,
+    ReversalExit,
+    LateHeavy,
+    DoubleSide,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PaperIntent {
+    pub ts_ms: i64,
+    pub order_id: String,
+    pub market_id: String,
+    pub symbol: String,
+    pub timeframe: String,
+    pub stage: Stage,
+    pub direction: Direction,
+    pub velocity_bps_per_sec: f64,
+    pub edge_bps: f64,
+    pub prob_fast: f64,
+    pub prob_settle: f64,
+    pub confidence: f64,
+    pub action: PaperAction,
+    pub intent: ExecutionStyle,
+    pub requested_size_usdc: f64,
+    pub requested_size_contracts: f64,
+    pub entry_price: f64,
+    pub seat_layer: Option<String>,
+    pub tuned_params_before: Option<serde_json::Value>,
+    pub tuned_params_after: Option<serde_json::Value>,
+    pub rollback_triggered: Option<String>,
+    pub shadow_pnl_comparison: Option<f64>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PaperFill {
+    pub ts_ms: i64,
+    pub order_id: String,
+    pub market_id: String,
+    pub side: OrderSide,
+    pub style: ExecutionStyle,
+    pub requested_size_usdc: f64,
+    pub executed_size_usdc: f64,
+    pub entry_price: f64,
+    pub fill_price: f64,
+    pub mid_price: f64,
+    pub slippage_bps: f64,
+    pub fee_usdc: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PaperTradeRecord {
+    pub ts_ms: i64,
+    pub paper_mode: String,
+    pub market_id: String,
+    pub symbol: String,
+    pub timeframe: String,
+    pub stage: Stage,
+    pub direction: Direction,
+    pub velocity_bps_per_sec: f64,
+    pub edge_bps: f64,
+    pub prob_fast: f64,
+    pub prob_settle: f64,
+    pub confidence: f64,
+    pub action: PaperAction,
+    pub intent: ExecutionStyle,
+    pub requested_size_usdc: f64,
+    pub executed_size_usdc: f64,
+    pub entry_price: f64,
+    pub fill_price: f64,
+    pub slippage_bps: f64,
+    pub fee_usdc: f64,
+    pub realized_pnl_usdc: f64,
+    pub bankroll_before: f64,
+    pub bankroll_after: f64,
+    pub settlement_price: f64,
+    pub chainlink_settlement_price: Option<f64>,
+    pub settlement_source: String,
+    pub forced_settlement: bool,
+    pub trade_duration_ms: i64,
+    pub seat_layer: Option<String>,
+    pub tuned_params_before: Option<serde_json::Value>,
+    pub tuned_params_after: Option<serde_json::Value>,
+    pub rollback_triggered: Option<String>,
+    pub shadow_pnl_comparison: Option<f64>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PaperDailySummary {
+    pub utc_day: String,
+    pub starting_bankroll: f64,
+    pub ending_bankroll: f64,
+    pub daily_roi_pct: f64,
+    pub trades: u64,
+    pub win_rate: f64,
+    pub fee_total_usdc: f64,
+    pub pnl_total_usdc: f64,
+    pub avg_trade_duration_ms: f64,
+    pub median_trade_duration_ms: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PaperLiveReport {
+    pub ts_ms: i64,
+    pub run_id: String,
+    pub initial_capital: f64,
+    pub bankroll: f64,
+    pub trades: u64,
+    pub wins: u64,
+    pub losses: u64,
+    pub win_rate: f64,
+    pub roi_pct: f64,
+    pub max_drawdown_pct: f64,
+    pub fee_total_usdc: f64,
+    pub pnl_total_usdc: f64,
+    pub fee_ratio: f64,
+    pub avg_trade_duration_ms: f64,
+    pub median_trade_duration_ms: f64,
+    pub trade_count_source: String,
+    pub open_positions_count: usize,
+}
+
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
 pub struct RiskDecision {
     pub allow: bool,
@@ -293,6 +576,14 @@ pub enum ToxicRegime {
     Danger,
 }
 
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
+#[serde(rename_all = "snake_case")]
+pub enum Regime {
+    Active,
+    Quiet,
+    Defend,
+}
+
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
 pub struct ToxicFeatures {
     pub market_id: String,
@@ -424,6 +715,19 @@ pub struct ShadowShot {
     pub side: OrderSide,
     #[serde(default = "default_execution_style")]
     pub execution_style: ExecutionStyle,
+    /// Positive means: our fast reference tick arrived earlier than the Polymarket book update.
+    /// See docs/metrics_contract.md for the contract definition.
+    #[serde(default)]
+    pub book_top_lag_ms: f64,
+    /// Execution venue request/ack duration only (real in live mode).
+    #[serde(default)]
+    pub ack_only_ms: f64,
+    /// End-to-end decision+execution latency (see app_runner for definition).
+    #[serde(default)]
+    pub tick_to_ack_ms: f64,
+    /// `book_top_lag_ms - tick_to_ack_ms`; positive means we likely had time to capture.
+    #[serde(default)]
+    pub capturable_window_ms: f64,
     #[serde(default)]
     pub survival_probe_price: f64,
     pub intended_price: f64,
@@ -498,6 +802,7 @@ pub enum EngineEvent {
     BookDelta(BookDelta),
     BookDigest(OrderbookStateDigest),
     Signal(Signal),
+    DirectionSignal(DirectionSignal),
     ToxicFeatures(ToxicFeatures),
     ToxicDecision(ToxicDecision),
     QuoteIntent(QuoteIntent),
@@ -506,6 +811,7 @@ pub enum EngineEvent {
     Fill(FillEvent),
     ShadowShot(ShadowShot),
     ShadowOutcome(ShadowOutcome),
+    CapitalUpdate(CapitalUpdate),
     Pnl(PnLSnapshot),
     Control(ControlCommand),
 }
@@ -624,8 +930,11 @@ mod tests {
             symbol: "BTCUSDT".to_string(),
             event_ts_ms: 1,
             recv_ts_ms: 2,
+            source_seq: 0,
             event_ts_exchange_ms: 1,
             recv_ts_local_ns: 2,
+            ingest_ts_local_ns: 2,
+            ts_first_hop_ms: None,
             price: 50000.0,
         });
 
diff --git a/crates/direction_detector/Cargo.toml b/crates/direction_detector/Cargo.toml
new file mode 100644
index 0000000..582fa67
--- /dev/null
+++ b/crates/direction_detector/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "direction_detector"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+core_types = { path = "../core_types" }
+serde.workspace = true
+
diff --git a/crates/direction_detector/src/lib.rs b/crates/direction_detector/src/lib.rs
new file mode 100644
index 0000000..dcda1e4
--- /dev/null
+++ b/crates/direction_detector/src/lib.rs
@@ -0,0 +1,784 @@
+use std::collections::{HashMap, VecDeque};
+
+use core_types::{Direction, DirectionSignal, RefTick, TimeframeClass};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct DirectionConfig {
+    /// Maximum window length for stored ticks (seconds).
+    pub window_max_sec: u64,
+    /// Thresholds in percent (e.g. 0.10 means 0.10%).
+    pub threshold_5m_pct: f64,
+    pub threshold_15m_pct: f64,
+    pub threshold_1h_pct: f64,
+    pub threshold_1d_pct: f64,
+    /// Lookback windows (seconds).
+    pub lookback_short_sec: u64,
+    pub lookback_long_sec: u64,
+    /// Multi-source consistency.
+    pub min_sources_for_high_confidence: usize,
+    /// Cold-start guard.
+    pub min_ticks_for_signal: usize,
+    /// Triple-confirm gate: minimum consecutive same-direction ticks.
+    pub min_consecutive_ticks: u8,
+    /// Triple-confirm gate: minimum absolute velocity in bps/s.
+    pub min_velocity_bps_per_sec: f64,
+    /// Triple-confirm gate: minimum directional acceleration.
+    pub min_acceleration: f64,
+    /// If abs(velocity) is above this multiple of min_velocity, treat as momentum spike.
+    pub momentum_spike_multiplier: f64,
+    /// Triple-confirm gate: minimum short/long tick-rate ratio treated as volume spike proxy.
+    pub min_tick_rate_spike_ratio: f64,
+    /// Window for short-horizon tick-rate in ms.
+    pub tick_rate_short_ms: i64,
+    /// Window for long-horizon tick-rate in ms.
+    pub tick_rate_long_ms: i64,
+    /// Enable source vote gate: Binance confirmation is mandatory.
+    pub enable_source_vote_gate: bool,
+    /// Require Chainlink secondary source confirmation when available.
+    pub require_secondary_confirmation: bool,
+    /// Ignore source snapshots older than this window when voting.
+    pub source_vote_max_age_ms: i64,
+    /// Âø´ÈÄüÁ°ÆËÆ§ÈÄüÂ∫¶ÈòàÂÄº (bps/s)„ÄÇ
+    /// ÂΩì velocity Ë∂ÖËøáÊ≠§ÂÄºÊó∂ÔºåÂè™ÈúÄ 1 ‰∏™ÂêåÂêë Tick Âç≥ÂèØËß¶ÂèëÔºà‰∏çÁ≠â min_consecutive_ticksÔºâ„ÄÇ
+    /// ËÆæËÆ°Âì≤Â≠¶: ÊûÅÂº∫Âä®ÈáèÊú¨Ë∫´Â∞±ÊòØÈ´òÁΩÆ‰ø°Â∫¶‰ø°Âè∑ÔºåÁ≠âÂæÖÁ¨¨ 2 ‰∏™ Tick ‰ºöÊçüÂ§± 10-50ms Á™óÂè£„ÄÇ
+    pub fast_confirm_velocity_bps_per_sec: f64,
+}
+
+impl Default for DirectionConfig {
+    fn default() -> Self {
+        Self {
+            window_max_sec: 120,
+            // 5min Â∏ÇÂú∫Ê≥¢Âä®Êõ¥Â∞èÔºåÈòàÂÄºÊõ¥‰ΩéÊâçËÉΩÊçïËé∑‰ø°Âè∑
+            threshold_5m_pct: 0.02,
+            threshold_15m_pct: 0.05,
+            threshold_1h_pct: 0.20,
+            threshold_1d_pct: 0.50,
+            lookback_short_sec: 15,
+            lookback_long_sec: 60,
+            min_sources_for_high_confidence: 2,
+            min_ticks_for_signal: 3,
+            min_consecutive_ticks: 2,
+            min_velocity_bps_per_sec: 3.0,
+            min_acceleration: 0.0,
+            momentum_spike_multiplier: 1.8,
+            min_tick_rate_spike_ratio: 1.8,
+            tick_rate_short_ms: 300,
+            tick_rate_long_ms: 3_000,
+            enable_source_vote_gate: true,
+            require_secondary_confirmation: true,
+            source_vote_max_age_ms: 2_000,
+            // ÊûÅÂº∫Âä®Èáè: velocity > 30 bps/s ‚Üí Âçï Tick Ëß¶ÂèëÔºå‰∏çÁ≠âÁ¨¨ 2 ‰∏™
+            fast_confirm_velocity_bps_per_sec: 30.0,
+        }
+    }
+}
+
+// ============================================================
+// SymbolWindow ‚Äî ÊØè‰∏™ symbol ÁöÑÊªëÂä®Á™óÂè£Áä∂ÊÄÅ
+// ËÆæËÆ°ÂéüÂàô: on_tick Êó∂Â¢ûÈáèÁª¥Êä§Ôºåevaluate Êó∂ O(1) ËØªÂèñÁºìÂ≠ò
+// Ê∂àÈô§ evaluate Ë∑ØÂæÑ‰∏äÁöÑÊâÄÊúâ O(n) Êâ´Êèè
+// ============================================================
+#[derive(Debug, Default)]
+struct SymbolWindow {
+    // (recv_ts_ms, price) ‚Äî ÊåâÊó∂Èó¥Êà≥ÂçáÂ∫è
+    ticks: VecDeque<(i64, f64)>,
+    // ÂêÑÊï∞ÊçÆÊ∫êÊúÄÊñ∞‰ª∑Ê†ºÂíåÊó∂Èó¥Êà≥
+    latest_by_source: HashMap<String, f64>,
+    latest_ts_by_source: HashMap<String, i64>,
+
+    // --------------------------------------------------------
+    // Â¢ûÈáèÁª¥Êä§ÁöÑÊªëÂä®Á™óÂè£ËÆ°Êï∞Âô® (on_tick O(1) Êõ¥Êñ∞)
+    // Ê∂àÈô§ evaluate Èáå‰∏§Ê¨° O(n) ÂÖ®ÈáèÊâ´Êèè
+    // --------------------------------------------------------
+    /// ÊúÄËøë tick_rate_short_ms ÂÜÖÁöÑ tick Êï∞
+    short_window_count: u32,
+    /// ÊúÄËøë tick_rate_long_ms ÂÜÖÁöÑ tick Êï∞
+    long_window_count: u32,
+    /// ËøûÁª≠ÂêåÂêë tick ËÆ°Êï∞ (Â¢ûÈáèÁª¥Êä§)
+    consecutive_dir_count: u8,
+    /// ÊúÄÂêé‰∏Ä‰∏™ tick ÁöÑÊñπÂêëÁ¨¶Âè∑: -1/0/1
+    last_dir_sign: i8,
+
+    // --------------------------------------------------------
+    // Ê∫êÁ±ªÂûãÁºìÂ≠ò ‚Äî ÈÅøÂÖçÊØèÊ¨° is_binance/chainlink ÂàÜÈÖç String
+    // --------------------------------------------------------
+    /// Â∑≤ËßÅËøáÁöÑ Binance Ê∫ê key (Á¨¨‰∏ÄÊ¨°ËßÅÂà∞Êó∂ÁºìÂ≠ò)
+    binance_source_key: Option<String>,
+    /// Â∑≤ËßÅËøáÁöÑ Chainlink Ê∫ê key (Á¨¨‰∏ÄÊ¨°ËßÅÂà∞Êó∂ÁºìÂ≠ò)
+    chainlink_source_key: Option<String>,
+}
+
+#[derive(Debug)]
+pub struct DirectionDetector {
+    windows: HashMap<String, SymbolWindow>,
+    cfg: DirectionConfig,
+    /// Tick counter for lazy pruning - only prune every N ticks
+    tick_counter: usize,
+    /// Cached tick_rate_short_ms as i64 for hot-path use
+    cfg_tick_rate_short_ms: i64,
+    /// Cached tick_rate_long_ms as i64 for hot-path use
+    cfg_tick_rate_long_ms: i64,
+}
+
+impl DirectionDetector {
+    pub fn new(cfg: DirectionConfig) -> Self {
+        let short = cfg.tick_rate_short_ms;
+        let long = cfg.tick_rate_long_ms;
+        Self {
+            windows: HashMap::new(),
+            cfg,
+            tick_counter: 0,
+            cfg_tick_rate_short_ms: short,
+            cfg_tick_rate_long_ms: long,
+        }
+    }
+
+    pub fn cfg(&self) -> &DirectionConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, cfg: DirectionConfig) {
+        self.cfg_tick_rate_short_ms = cfg.tick_rate_short_ms;
+        self.cfg_tick_rate_long_ms = cfg.tick_rate_long_ms;
+        self.cfg = cfg;
+        // Keep windows; pruning will happen on next tick/evaluate.
+    }
+
+    pub fn on_tick(&mut self, tick: &RefTick) {
+        let w = self.windows.entry(tick.symbol.clone()).or_default();
+
+        // --------------------------------------------------------
+        // Ê∫êÁ±ªÂûãÁºìÂ≠ò: Á¨¨‰∏ÄÊ¨°ËßÅÂà∞ binance/chainlink Ê∫êÊó∂ËÆ∞ÂΩï key
+        // ÂêéÁª≠ source_vote Áõ¥Êé•ÊØîËæÉ keyÔºå‰∏çÂÜç to_ascii_lowercase()
+        // --------------------------------------------------------
+        if w.binance_source_key.is_none() && is_binance_source(&tick.source) {
+            w.binance_source_key = Some(tick.source.to_string());
+        }
+        if w.chainlink_source_key.is_none() && is_chainlink_source(&tick.source) {
+            w.chainlink_source_key = Some(tick.source.to_string());
+        }
+
+        w.latest_by_source
+            .insert(tick.source.to_string(), tick.price);
+        w.latest_ts_by_source
+            .insert(tick.source.to_string(), tick.recv_ts_ms);
+
+        // --------------------------------------------------------
+        // Â¢ûÈáèÁª¥Êä§ËøûÁª≠ÊñπÂêëËÆ°Êï∞
+        // Âè™ÁúãÊúÄÊñ∞ tick ‰∏é‰∏ä‰∏Ä‰∏™ tick ÁöÑÊñπÂêëÂÖ≥Á≥ªÔºåO(1)
+        // --------------------------------------------------------
+        if let Some(&(_, prev_price)) = w.ticks.back() {
+            if prev_price > 0.0 && tick.price > 0.0 {
+                let delta = tick.price - prev_price;
+                let sign: i8 = if delta > 0.0 {
+                    1
+                } else if delta < 0.0 {
+                    -1
+                } else {
+                    0
+                };
+                if sign == 0 {
+                    w.consecutive_dir_count = 0;
+                    w.last_dir_sign = 0;
+                } else if sign == w.last_dir_sign {
+                    w.consecutive_dir_count = w.consecutive_dir_count.saturating_add(1);
+                } else {
+                    w.consecutive_dir_count = 1;
+                    w.last_dir_sign = sign;
+                }
+            }
+        }
+
+        w.ticks.push_back((tick.recv_ts_ms, tick.price));
+
+        // --------------------------------------------------------
+        // Â¢ûÈáèÁª¥Êä§ÊªëÂä®Á™óÂè£ËÆ°Êï∞Âô®
+        // Êñ∞ tick ËøõÊù•Êó∂: short/long count +1
+        // ËøáÊúü tick ÂºπÂá∫Êó∂: Áõ∏Â∫î count -1
+        // --------------------------------------------------------
+        let short_ms = self.cfg_tick_rate_short_ms;
+        let long_ms = self.cfg_tick_rate_long_ms;
+        let now = tick.recv_ts_ms;
+        w.short_window_count += 1;
+        w.long_window_count += 1;
+
+        // ÊáíÊÉ∞Ââ™Êûù: ÊØè 100 ticks Ê∏ÖÁêÜËøáÊúüÊï∞ÊçÆÔºåÂêåÊó∂‰øÆÊ≠£ËÆ°Êï∞Âô®
+        self.tick_counter += 1;
+        if self.tick_counter >= 100 {
+            self.tick_counter = 0;
+            let window_cutoff =
+                now.saturating_sub((self.cfg.window_max_sec as i64).saturating_mul(1_000));
+            let short_cutoff = now.saturating_sub(short_ms);
+            let long_cutoff = now.saturating_sub(long_ms);
+            // ÈáçÊñ∞Á≤æÁ°ÆËÆ°ÁÆóËÆ°Êï∞Âô®ÔºàÊØè 100 ticks ‰∏ÄÊ¨°ÔºåÂàÜÊëäÊàêÊú¨Ôºâ
+            w.short_window_count =
+                w.ticks.iter().filter(|(ts, _)| *ts >= short_cutoff).count() as u32;
+            w.long_window_count =
+                w.ticks.iter().filter(|(ts, _)| *ts >= long_cutoff).count() as u32;
+            while matches!(w.ticks.front(), Some((ts, _)) if *ts < window_cutoff) {
+                w.ticks.pop_front();
+            }
+        }
+    }
+
+    pub fn evaluate(&self, symbol: &str, now_ms: i64) -> Option<DirectionSignal> {
+        let w = self.windows.get(symbol)?;
+        if w.ticks.len() < self.cfg.min_ticks_for_signal {
+            return None;
+        }
+
+        let latest = w.ticks.back().map(|(_, px)| *px)?;
+        if latest <= 0.0 {
+            return None;
+        }
+
+        let anchor_short_ms =
+            now_ms.saturating_sub((self.cfg.lookback_short_sec as i64).saturating_mul(1_000));
+        let anchor_long_ms =
+            now_ms.saturating_sub((self.cfg.lookback_long_sec as i64).saturating_mul(1_000));
+        let anchor_short = find_anchor_price(&w.ticks, anchor_short_ms)?;
+        let anchor_long = find_anchor_price(&w.ticks, anchor_long_ms)?;
+        if anchor_short <= 0.0 || anchor_long <= 0.0 {
+            return None;
+        }
+
+        let ret_short = (latest - anchor_short) / anchor_short;
+        let ret_long = (latest - anchor_long) / anchor_long;
+        let magnitude_pct = (ret_short * 0.7 + ret_long * 0.3) * 100.0;
+        // kinematics_from_ticks \u73b0\u5728\u53ea\u8fd4\u56de (velocity, acceleration)
+        // tick_consistency \u7531 SymbolWindow \u589e\u91cf\u7ef4\u62a4\uff0cO(1) \u8bfb\u53d6
+        let (velocity_bps_per_sec, acceleration) = kinematics_from_ticks(&w.ticks);
+        let tick_consistency = w.consecutive_dir_count;
+
+        let mut raw_direction = if magnitude_pct > self.cfg.threshold_15m_pct {
+            Direction::Up
+        } else if magnitude_pct < -self.cfg.threshold_15m_pct {
+            Direction::Down
+        } else {
+            Direction::Neutral
+        };
+        let velocity_direction = if velocity_bps_per_sec > 0.0 {
+            Direction::Up
+        } else if velocity_bps_per_sec < 0.0 {
+            Direction::Down
+        } else {
+            Direction::Neutral
+        };
+        let velocity_spike_only = matches!(raw_direction, Direction::Neutral)
+            && !matches!(velocity_direction, Direction::Neutral)
+            && tick_consistency >= self.cfg.min_consecutive_ticks.max(1)
+            && velocity_bps_per_sec.abs()
+                >= self.cfg.min_velocity_bps_per_sec.max(0.0)
+                    * self.cfg.momentum_spike_multiplier.max(1.0);
+
+        if velocity_spike_only {
+            raw_direction = velocity_direction;
+        }
+        let direction_sign = match raw_direction {
+            Direction::Up => 1.0,
+            Direction::Down => -1.0,
+            Direction::Neutral => 0.0,
+        };
+        let velocity_abs = velocity_bps_per_sec.abs();
+        let directional_acceleration = acceleration * direction_sign;
+        let momentum_spike = velocity_abs
+            >= self.cfg.min_velocity_bps_per_sec.max(0.0)
+                * self.cfg.momentum_spike_multiplier.max(1.0);
+        // --------------------------------------------------------
+        // volume_spike: Áõ¥Êé•Áî®ÁºìÂ≠òÁöÑÊªëÂä®Á™óÂè£ËÆ°Êï∞Âô®ÔºåO(1) ËØªÂèñ
+        // Êõø‰ª£ÂéüÊù•ÁöÑ tick_rate_spike_ratio() O(2n) ÂÖ®ÈáèÊâ´Êèè
+        // --------------------------------------------------------
+        let short_ms = self.cfg_tick_rate_short_ms.clamp(50, 10_000);
+        let long_ms = self
+            .cfg_tick_rate_long_ms
+            .max(short_ms + 50)
+            .clamp(100, 60_000);
+        let short_rate = w.short_window_count as f64 / (short_ms as f64 / 1_000.0);
+        let long_rate = (w.long_window_count as f64 / (long_ms as f64 / 1_000.0)).max(1e-6);
+        let tick_rate_ratio = short_rate / long_rate;
+        let volume_spike = tick_rate_ratio >= self.cfg.min_tick_rate_spike_ratio.max(1.0);
+        // --------------------------------------------------------
+        // ÈÄüÂ∫¶ÂàÜÁ∫ßÂø´ÈÄüÁ°ÆËÆ§:
+        //   ÊûÅÂº∫Âä®Èáè (velocity > fast_confirm_threshold) ‚Üí Âçï Tick Âç≥ÂèØËß¶Âèë
+        //   ÊôÆÈÄöÂä®Èáè ‚Üí ÈúÄË¶Å min_consecutive_ticks ‰∏™ÂêåÂêë Tick
+        // ËÆæËÆ°Âì≤Â≠¶: ÊûÅÂº∫Âä®ÈáèÊú¨Ë∫´ÊòØÈ´òÁΩÆ‰ø°Â∫¶ÔºåÁ≠âÂæÖÁ¨¨ 2 ‰∏™ Tick ‰ºöÊçüÂ§±Â•óÂà©Á™óÂè£
+        // --------------------------------------------------------
+        let required_ticks = if velocity_abs >= self.cfg.fast_confirm_velocity_bps_per_sec.max(1.0)
+        {
+            1u8
+        } else {
+            self.cfg.min_consecutive_ticks.max(1)
+        };
+        // Áõ¥Êé•ËØªÁºìÂ≠òÁöÑ tick_consistencyÔºå‰∏çÂÜçË∞ÉÁî® consecutive_direction_count()
+        let tick_consistency = w.consecutive_dir_count;
+        let triple_confirm = !matches!(raw_direction, Direction::Neutral)
+            && tick_consistency >= required_ticks
+            && velocity_abs >= self.cfg.min_velocity_bps_per_sec.max(0.0)
+            && (directional_acceleration >= self.cfg.min_acceleration
+                || momentum_spike
+                || volume_spike);
+        let vote = source_vote_cached(
+            &w.latest_by_source,
+            &w.latest_ts_by_source,
+            w.binance_source_key.as_deref(),
+            w.chainlink_source_key.as_deref(),
+            anchor_short,
+            &raw_direction,
+            now_ms,
+            self.cfg.source_vote_max_age_ms,
+        );
+        // Èó®ÊéßÂÖ≥Èó≠ Êàñ ÊñπÂêë‰∏≠ÊÄß ‚Üí Áõ¥Êé•ÊîæË°åÔºõÂê¶ÂàôÊ£ÄÊü•Êï∞ÊçÆÊ∫êÁ°ÆËÆ§
+        let vote_passed = !self.cfg.enable_source_vote_gate
+            || matches!(raw_direction, Direction::Neutral)
+            || if self.cfg.require_secondary_confirmation {
+                vote.binance_confirms && (!vote.secondary_available || vote.secondary_confirms)
+            } else {
+                vote.binance_confirms
+            };
+        let direction = if triple_confirm && vote_passed {
+            raw_direction
+        } else {
+            Direction::Neutral
+        };
+
+        let recommended_tf = recommended_timeframe(&self.cfg, magnitude_pct.abs());
+
+        let confidence = compute_confidence(
+            &w.latest_by_source,
+            anchor_short,
+            &direction,
+            self.cfg.min_sources_for_high_confidence,
+        );
+
+        Some(DirectionSignal {
+            symbol: symbol.to_string(),
+            direction,
+            magnitude_pct,
+            confidence,
+            recommended_tf,
+            velocity_bps_per_sec,
+            acceleration,
+            tick_consistency,
+            triple_confirm,
+            momentum_spike,
+            ts_ns: now_ms.max(0) * 1_000_000,
+        })
+    }
+}
+
+#[derive(Debug, Default, Clone, Copy)]
+struct SourceVote {
+    binance_confirms: bool,
+    secondary_available: bool,
+    secondary_confirms: bool,
+}
+
+// ============================================================
+// source_vote_cached ‚Äî Âà©Áî®ÁºìÂ≠òÁöÑÊ∫ê key ÈÅøÂÖçÁÉ≠Ë∑ØÂæÑ String ÂàÜÈÖç
+// Êõø‰ª£ÂéüÊù•ÁöÑ source_vote() ÈáåÊØèÊ¨° is_binance/chainlink_source() ÁöÑ alloc
+// ============================================================
+fn source_vote_cached(
+    latest_by_source: &HashMap<String, f64>,
+    latest_ts_by_source: &HashMap<String, i64>,
+    binance_key: Option<&str>,
+    chainlink_key: Option<&str>,
+    anchor_short: f64,
+    direction: &Direction,
+    now_ms: i64,
+    max_age_ms: i64,
+) -> SourceVote {
+    if anchor_short <= 0.0 || matches!(direction, Direction::Neutral) {
+        return SourceVote::default();
+    }
+    let mut out = SourceVote::default();
+    let max_age_ms = max_age_ms.max(50);
+
+    // Ê£ÄÊü• Binance Ê∫êÁ°ÆËÆ§
+    if let Some(key) = binance_key {
+        if let (Some(&px), Some(&ts)) = (latest_by_source.get(key), latest_ts_by_source.get(key)) {
+            if now_ms.saturating_sub(ts) <= max_age_ms {
+                let ret = (px - anchor_short) / anchor_short;
+                out.binance_confirms = match direction {
+                    Direction::Up => ret > 0.0,
+                    Direction::Down => ret < 0.0,
+                    Direction::Neutral => false,
+                };
+            }
+        }
+    }
+
+    // Ê£ÄÊü• Chainlink Ê∫êÁ°ÆËÆ§
+    if let Some(key) = chainlink_key {
+        if let (Some(&px), Some(&ts)) = (latest_by_source.get(key), latest_ts_by_source.get(key)) {
+            out.secondary_available = true;
+            if now_ms.saturating_sub(ts) <= max_age_ms {
+                let ret = (px - anchor_short) / anchor_short;
+                out.secondary_confirms = match direction {
+                    Direction::Up => ret > 0.0,
+                    Direction::Down => ret < 0.0,
+                    Direction::Neutral => false,
+                };
+            }
+        }
+    }
+
+    out
+}
+
+// ============================================================
+// is_binance/chainlink_source ‚Äî Êó†ÂàÜÈÖçÁâàÊú¨
+// ÂéüÊù•ÁöÑ to_ascii_lowercase() ÊØèÊ¨°ÂàÜÈÖçÊñ∞ String
+// Áé∞Âú®Áî® bytes ÊØîËæÉÔºåÈõ∂ÂàÜÈÖç
+// ============================================================
+#[inline]
+fn is_binance_source(source: &str) -> bool {
+    let b = source.as_bytes();
+    b.windows(7).any(|w| w.eq_ignore_ascii_case(b"binance"))
+}
+
+#[inline]
+fn is_chainlink_source(source: &str) -> bool {
+    let b = source.as_bytes();
+    b.windows(9).any(|w| w.eq_ignore_ascii_case(b"chainlink"))
+}
+
+// ============================================================
+// kinematics_from_ticks ‚Äî ËÆ°ÁÆóÈÄüÂ∫¶ÂíåÂä†ÈÄüÂ∫¶
+// Ê≥®ÊÑè: tick_consistency Áé∞Âú®Áî± SymbolWindow Â¢ûÈáèÁª¥Êä§
+// ËøôÈáåÂè™ËøîÂõû (velocity, acceleration)Ôºå‰∏çÂÜçË∞ÉÁî® consecutive_direction_count()
+// ============================================================
+fn kinematics_from_ticks(ticks: &VecDeque<(i64, f64)>) -> (f64, f64) {
+    if ticks.len() < 3 {
+        return (0.0, 0.0);
+    }
+    let mut it = ticks.iter().rev();
+    let (t2, p2) = *it.next().unwrap_or(&(0, 0.0));
+    let (t1, p1) = *it.next().unwrap_or(&(0, 0.0));
+    let (t0, p0) = *it.next().unwrap_or(&(0, 0.0));
+    let v2 = velocity_bps_per_sec(t1, p1, t2, p2);
+    let v1 = velocity_bps_per_sec(t0, p0, t1, p1);
+    let dt_s = ((t2 - t1).max(1) as f64) / 1_000.0;
+    let acceleration = (v2 - v1) / dt_s.max(1e-6);
+    (v2, acceleration)
+}
+
+fn velocity_bps_per_sec(t0_ms: i64, p0: f64, t1_ms: i64, p1: f64) -> f64 {
+    if p0 <= 0.0 || p1 <= 0.0 {
+        return 0.0;
+    }
+    let dt_ms = (t1_ms - t0_ms).max(1) as f64;
+    let dt_s = dt_ms / 1_000.0;
+    let ret = (p1 - p0) / p0;
+    let v = (ret * 10_000.0) / dt_s.max(1e-6);
+    if v.is_finite() {
+        v
+    } else {
+        0.0
+    }
+}
+
+// ============================================================
+// find_anchor_price ‚Äî ‰∫åÂàÜÊü•Êâæ O(log n)
+// deque ÊåâÊó∂Èó¥Êà≥ÂçáÂ∫èÔºåpartition_point ÊâæÂà∞Á¨¨‰∏Ä‰∏™ ts > target_ms ÁöÑ‰ΩçÁΩÆ
+// ÂèñÂÖ∂Ââç‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂç≥ÊúÄÊñ∞ÁöÑ ts <= target_ms ÁöÑ‰ª∑Ê†º
+// ============================================================
+#[inline]
+fn find_anchor_price(ticks: &VecDeque<(i64, f64)>, target_ms: i64) -> Option<f64> {
+    // partition_point: ËøîÂõûÁ¨¨‰∏Ä‰∏™‰∏çÊª°Ë∂≥Êù°‰ª∂ÁöÑÁ¥¢Âºï
+    // Êù°‰ª∂: ts <= target_msÔºåÊâÄ‰ª•ËøîÂõûÁöÑÊòØÁ¨¨‰∏Ä‰∏™ ts > target_ms ÁöÑ‰ΩçÁΩÆ
+    let idx = ticks.partition_point(|(ts, _)| *ts <= target_ms);
+    if idx == 0 {
+        return None; // ÊâÄÊúâ tick ÈÉΩÂú® target_ms ‰πãÂêé
+    }
+    ticks.get(idx - 1).map(|(_, px)| *px)
+}
+
+fn recommended_timeframe(cfg: &DirectionConfig, abs_magnitude_pct: f64) -> TimeframeClass {
+    if abs_magnitude_pct >= cfg.threshold_1d_pct {
+        TimeframeClass::Tf1d
+    } else if abs_magnitude_pct >= cfg.threshold_1h_pct {
+        TimeframeClass::Tf1h
+    } else if abs_magnitude_pct >= cfg.threshold_15m_pct {
+        TimeframeClass::Tf15m
+    } else {
+        TimeframeClass::Tf5m
+    }
+}
+
+fn compute_confidence(
+    latest_by_source: &HashMap<String, f64>,
+    anchor_short: f64,
+    direction: &Direction,
+    min_sources_for_high_confidence: usize,
+) -> f64 {
+    if latest_by_source.is_empty() || anchor_short <= 0.0 {
+        return 0.0;
+    }
+    let mut consistent = 0usize;
+    let mut total = 0usize;
+    // Use a small threshold for Neutral instead of exact equality
+    // Floating-point exact equality is nearly impossible, so we use 0.1% threshold
+    const NEUTRAL_THRESHOLD: f64 = 0.001;
+    for (source, px) in latest_by_source {
+        if is_chainlink_source(source) {
+            continue;
+        }
+        total += 1;
+        let ret = (*px - anchor_short) / anchor_short;
+        let ok = match direction {
+            Direction::Up => ret > 0.0,
+            Direction::Down => ret < 0.0,
+            Direction::Neutral => ret.abs() <= NEUTRAL_THRESHOLD,
+        };
+        if ok {
+            consistent += 1;
+        }
+    }
+    if total == 0 {
+        total = latest_by_source.len();
+        consistent = 0;
+        for px in latest_by_source.values() {
+            let ret = (*px - anchor_short) / anchor_short;
+            let ok = match direction {
+                Direction::Up => ret > 0.0,
+                Direction::Down => ret < 0.0,
+                Direction::Neutral => ret.abs() <= NEUTRAL_THRESHOLD,
+            };
+            if ok {
+                consistent += 1;
+            }
+        }
+    }
+    let mut c = (consistent as f64 / total as f64).clamp(0.0, 1.0);
+    if consistent >= min_sources_for_high_confidence {
+        c = c.max(0.85);
+    }
+    c
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn tick(source: &str, symbol: &str, recv_ts_ms: i64, price: f64) -> RefTick {
+        RefTick {
+            source: source.to_string(),
+            symbol: symbol.to_string(),
+            event_ts_ms: recv_ts_ms,
+            recv_ts_ms,
+            source_seq: 0,
+            event_ts_exchange_ms: recv_ts_ms,
+            recv_ts_local_ns: recv_ts_ms * 1_000_000,
+            ingest_ts_local_ns: recv_ts_ms * 1_000_000,
+            ts_first_hop_ms: None,
+            price,
+        }
+    }
+
+    #[test]
+    fn no_signal_when_cold_start() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 5,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 15_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now, 100.2));
+        assert!(det.evaluate("BTCUSDT", now).is_none());
+    }
+
+    #[test]
+    fn up_direction_when_move_exceeds_threshold() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            threshold_15m_pct: 0.10,
+            min_consecutive_ticks: 1,
+            min_velocity_bps_per_sec: 0.0,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 15_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now, 100.2));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+        assert!(sig.magnitude_pct > 0.10);
+        assert!(sig.velocity_bps_per_sec > 0.0);
+    }
+
+    #[test]
+    fn recommended_timeframe_mapping() {
+        let cfg = DirectionConfig::default();
+        assert_eq!(recommended_timeframe(&cfg, 0.01), TimeframeClass::Tf5m);
+        assert_eq!(recommended_timeframe(&cfg, 0.10), TimeframeClass::Tf15m);
+        assert_eq!(recommended_timeframe(&cfg, 0.25), TimeframeClass::Tf1h);
+        assert_eq!(recommended_timeframe(&cfg, 0.60), TimeframeClass::Tf1d);
+    }
+
+    #[test]
+    fn multi_source_high_confidence_floor() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            min_sources_for_high_confidence: 2,
+            min_consecutive_ticks: 1,
+            min_velocity_bps_per_sec: 0.0,
+            require_secondary_confirmation: true,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now - 15_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now, 100.2));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now, 100.21));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+        assert!(sig.confidence >= 0.85);
+    }
+
+    #[test]
+    fn triple_confirm_blocks_single_tick_fakeout() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            threshold_15m_pct: 0.10,
+            min_consecutive_ticks: 2,
+            min_velocity_bps_per_sec: 1.0,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 15_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 1_000, 100.2));
+        det.on_tick(&tick("binance", "BTCUSDT", now, 100.1));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Neutral);
+    }
+
+    #[test]
+    fn triple_confirm_passes_consistent_move() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 4,
+            threshold_15m_pct: 0.05,
+            min_consecutive_ticks: 2,
+            min_velocity_bps_per_sec: 1.0,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 2_000, 100.05));
+        det.on_tick(&tick("binance", "BTCUSDT", now - 1_000, 100.10));
+        det.on_tick(&tick("binance", "BTCUSDT", now, 100.20));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+        assert!(sig.tick_consistency >= 2);
+    }
+
+    #[test]
+    fn source_vote_blocks_when_binance_unconfirmed() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            min_consecutive_ticks: 1,
+            min_velocity_bps_per_sec: 0.0,
+            require_secondary_confirmation: true,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 1_000, 99.9));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now, 100.2));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Neutral);
+    }
+
+    #[test]
+    fn source_vote_passes_with_binance_plus_secondary() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            threshold_15m_pct: 0.10,
+            min_consecutive_ticks: 1,
+            min_velocity_bps_per_sec: 0.0,
+            require_secondary_confirmation: true,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 1_000, 100.2));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now, 100.21));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+    }
+
+    #[test]
+    fn source_vote_accepts_chainlink_as_secondary() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 3,
+            threshold_15m_pct: 0.10,
+            min_consecutive_ticks: 1,
+            min_velocity_bps_per_sec: 0.0,
+            require_secondary_confirmation: true,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance_udp", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance_udp", "BTCUSDT", now - 1_000, 100.2));
+        det.on_tick(&tick("chainlink_rtds", "BTCUSDT", now, 100.21));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+    }
+
+    #[test]
+    fn velocity_spike_overrides_magnitude_neutral() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 4,
+            threshold_15m_pct: 0.10,
+            min_consecutive_ticks: 2,
+            min_velocity_bps_per_sec: 5.0,
+            momentum_spike_multiplier: 1.8,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 1_000_000i64;
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 60_000, 100.0));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 1_000, 100.00));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 800, 100.04));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 600, 100.08));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+        assert!(sig.magnitude_pct < 0.10);
+    }
+
+    #[test]
+    fn volume_spike_passes_triple_confirm_even_with_low_acceleration() {
+        let mut det = DirectionDetector::new(DirectionConfig {
+            min_ticks_for_signal: 4,
+            threshold_15m_pct: 0.05,
+            lookback_short_sec: 1,
+            lookback_long_sec: 3,
+            min_consecutive_ticks: 2,
+            min_velocity_bps_per_sec: 0.5,
+            min_acceleration: 10_000.0,
+            min_tick_rate_spike_ratio: 2.0,
+            tick_rate_short_ms: 300,
+            tick_rate_long_ms: 3_000,
+            require_secondary_confirmation: false,
+            ..DirectionConfig::default()
+        });
+        let now = 2_000_000i64;
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 4_000, 100.0));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 2_000, 100.02));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 200, 100.07));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 120, 100.12));
+        det.on_tick(&tick("binance_ws", "BTCUSDT", now - 40, 100.17));
+        let sig = det.evaluate("BTCUSDT", now).unwrap();
+        assert_eq!(sig.direction, Direction::Up);
+        assert!(sig.tick_consistency >= 2);
+    }
+}
diff --git a/crates/execution_clob/Cargo.toml b/crates/execution_clob/Cargo.toml
index 671d641..bc4c1aa 100644
--- a/crates/execution_clob/Cargo.toml
+++ b/crates/execution_clob/Cargo.toml
@@ -9,7 +9,11 @@ anyhow.workspace = true
 async-trait.workspace = true
 chrono.workspace = true
 core_types = { path = "../core_types" }
+futures.workspace = true
 parking_lot.workspace = true
 reqwest.workspace = true
 serde.workspace = true
 serde_json.workspace = true
+tokio.workspace = true
+tokio-tungstenite.workspace = true
+tracing.workspace = true
diff --git a/crates/execution_clob/src/lib.rs b/crates/execution_clob/src/lib.rs
index 17a5da5..f7db4f7 100644
--- a/crates/execution_clob/src/lib.rs
+++ b/crates/execution_clob/src/lib.rs
@@ -1,13 +1,18 @@
 use std::collections::HashMap;
+use std::sync::atomic::{AtomicU64, Ordering};
 use std::sync::Arc;
+use std::time::Duration;
 use std::time::Instant;
 
 use anyhow::{bail, Result};
 use async_trait::async_trait;
 use chrono::Utc;
 use core_types::{new_id, ExecutionVenue, OrderAck, OrderAckV2, OrderIntentV2, QuoteIntent};
-use parking_lot::RwLock;
+use parking_lot::{Mutex, RwLock};
 use reqwest::Client;
+use serde::Serialize;
+
+pub mod wss_user_feed;
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum ExecutionMode {
@@ -15,12 +20,52 @@ pub enum ExecutionMode {
     Live,
 }
 
-#[derive(Clone)]
 pub struct ClobExecution {
     mode: ExecutionMode,
     http: Client,
     clob_endpoint: String,
+    order_primary_endpoint: String,
+    order_backup_endpoint: Option<String>,
+    order_failover_timeout: Duration,
     open_orders: Arc<RwLock<HashMap<String, PaperOpenOrder>>>,
+    last_prune: Mutex<Instant>,
+    ack_probe: Option<Arc<AckProbe>>,
+}
+
+fn env_flag_enabled(name: &str) -> bool {
+    std::env::var(name)
+        .ok()
+        .map(|v| {
+            let normalized = v.trim().to_ascii_lowercase();
+            matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
+        })
+        .unwrap_or(false)
+}
+
+impl Clone for ClobExecution {
+    fn clone(&self) -> Self {
+        Self {
+            mode: self.mode,
+            http: self.http.clone(),
+            clob_endpoint: self.clob_endpoint.clone(),
+            order_primary_endpoint: self.order_primary_endpoint.clone(),
+            order_backup_endpoint: self.order_backup_endpoint.clone(),
+            order_failover_timeout: self.order_failover_timeout,
+            open_orders: self.open_orders.clone(),
+            last_prune: Mutex::new(Instant::now()),
+            ack_probe: self.ack_probe.clone(),
+        }
+    }
+}
+
+/// Minimum interval between order pruning to reduce lock contention
+const PRUNE_INTERVAL: Duration = Duration::from_secs(60);
+
+#[derive(Debug)]
+struct AckProbe {
+    url: String,
+    every: u64,
+    counter: AtomicU64,
 }
 
 #[derive(Debug, Clone)]
@@ -29,25 +74,164 @@ struct PaperOpenOrder {
     created_at: Instant,
 }
 
+#[derive(Serialize)]
+struct LiveOrderPayload<'a> {
+    market_id: &'a str,
+    token_id: Option<&'a str>,
+    side: &'a str,
+    price: f64,
+    size: f64,
+    ttl_ms: u64,
+    style: &'a str,
+    tif: &'a str,
+    client_order_id: Option<&'a str>,
+    max_slippage_bps: f64,
+    fee_rate_bps: f64,
+    expected_edge_net_bps: f64,
+    hold_to_resolution: bool,
+}
+
+fn encode_live_order_payload(intent: &OrderIntentV2) -> Vec<u8> {
+    let side = intent.side.to_string();
+    let style = intent.style.to_string();
+    let tif = intent.tif.to_string();
+    let payload = LiveOrderPayload {
+        market_id: intent.market_id.as_str(),
+        token_id: intent.token_id.as_deref(),
+        side: side.as_str(),
+        price: intent.price,
+        size: intent.size,
+        ttl_ms: intent.ttl_ms,
+        style: style.as_str(),
+        tif: tif.as_str(),
+        client_order_id: intent.client_order_id.as_deref(),
+        max_slippage_bps: intent.max_slippage_bps,
+        fee_rate_bps: intent.fee_rate_bps,
+        expected_edge_net_bps: intent.expected_edge_net_bps,
+        hold_to_resolution: intent.hold_to_resolution,
+    };
+    serde_json::to_vec(&payload).unwrap_or_default()
+}
+
 impl ClobExecution {
     pub fn new(mode: ExecutionMode, clob_endpoint: String) -> Self {
-        Self::new_with_timeout(mode, clob_endpoint, std::time::Duration::from_millis(3_000))
+        Self::new_with_order_routing(
+            mode,
+            clob_endpoint,
+            None,
+            None,
+            std::time::Duration::from_millis(3_000),
+            std::time::Duration::from_millis(200),
+        )
     }
 
     pub fn new_with_timeout(
         mode: ExecutionMode,
         clob_endpoint: String,
         timeout: std::time::Duration,
+    ) -> Self {
+        Self::new_with_order_routing(
+            mode,
+            clob_endpoint,
+            None,
+            None,
+            timeout,
+            std::time::Duration::from_millis(200),
+        )
+    }
+
+    pub fn new_with_order_routing(
+        mode: ExecutionMode,
+        clob_endpoint: String,
+        order_primary_endpoint: Option<String>,
+        order_backup_endpoint: Option<String>,
+        timeout: std::time::Duration,
+        order_failover_timeout: std::time::Duration,
     ) -> Self {
         let http = Client::builder()
+            // Keep the request budget bounded (engine must never hang on IO).
             .timeout(timeout)
+            // Connection pooling + keepalive to reduce RTT tail spikes.
+            .pool_max_idle_per_host(
+                std::env::var("POLYEDGE_HTTP_POOL_IDLE_PER_HOST")
+                    .ok()
+                    .and_then(|v| v.parse::<usize>().ok())
+                    .unwrap_or(16)
+                    .max(1),
+            )
+            .pool_idle_timeout(Some(Duration::from_secs(
+                std::env::var("POLYEDGE_HTTP_POOL_IDLE_TIMEOUT_SEC")
+                    .ok()
+                    .and_then(|v| v.parse::<u64>().ok())
+                    .unwrap_or(90)
+                    .max(5),
+            )))
+            .tcp_keepalive(Some(Duration::from_secs(
+                std::env::var("POLYEDGE_HTTP_TCP_KEEPALIVE_SEC")
+                    .ok()
+                    .and_then(|v| v.parse::<u64>().ok())
+                    .unwrap_or(30)
+                    .max(5),
+            )))
+            .tcp_nodelay(true)
+            // Force HTTP/2 without negotiation (Polymarket CLOB supports it)
+            .http2_prior_knowledge()
+            // If the peer supports it (ALPN), this can cut head-of-line blocking.
+            .http2_keep_alive_interval(Some(Duration::from_secs(
+                std::env::var("POLYEDGE_HTTP2_KEEPALIVE_INTERVAL_SEC")
+                    .ok()
+                    .and_then(|v| v.parse::<u64>().ok())
+                    .unwrap_or(30)
+                    .max(5),
+            )))
+            .http2_keep_alive_timeout(Duration::from_secs(
+                std::env::var("POLYEDGE_HTTP2_KEEPALIVE_TIMEOUT_SEC")
+                    .ok()
+                    .and_then(|v| v.parse::<u64>().ok())
+                    .unwrap_or(10)
+                    .max(1),
+            ))
+            .http2_keep_alive_while_idle(true)
             .build()
             .unwrap_or_else(|_| Client::new());
+        let ack_probe = if env_flag_enabled("POLYEDGE_ACK_ONLY_PROBE_ENABLED") {
+            std::env::var("POLYEDGE_ACK_ONLY_PROBE_URL")
+                .ok()
+                .filter(|s| !s.trim().is_empty())
+                .map(|url| {
+                    let every = std::env::var("POLYEDGE_ACK_ONLY_PROBE_EVERY")
+                        .ok()
+                        .and_then(|v| v.parse::<u64>().ok())
+                        .unwrap_or(20)
+                        .max(5);
+                    Arc::new(AckProbe {
+                        url,
+                        every,
+                        counter: AtomicU64::new(0),
+                    })
+                })
+        } else {
+            None
+        };
+
+        let primary = order_primary_endpoint
+            .map(|v| v.trim().trim_end_matches('/').to_string())
+            .filter(|v| !v.is_empty())
+            .unwrap_or_else(|| clob_endpoint.trim().trim_end_matches('/').to_string());
+        let backup = order_backup_endpoint
+            .map(|v| v.trim().trim_end_matches('/').to_string())
+            .filter(|v| !v.is_empty() && v != &primary);
+
         Self {
             mode,
             http,
             clob_endpoint,
+            order_primary_endpoint: primary,
+            order_backup_endpoint: backup,
+            order_failover_timeout,
             open_orders: Arc::new(RwLock::new(HashMap::new())),
+            last_prune: Mutex::new(Instant::now()),
+            ack_probe,
         }
     }
 
@@ -79,13 +263,55 @@ impl ClobExecution {
             .sum()
     }
 
+    pub fn has_open_order(&self, order_id: &str) -> bool {
+        self.prune_expired_orders();
+        self.open_orders.read().contains_key(order_id)
+    }
+
+    pub fn mark_order_closed_local(&self, order_id: &str) {
+        self.open_orders.write().remove(order_id);
+    }
+
+    /// Best-effort warmup for the internal HTTP client pool. Intended to run on startup so the
+    /// first order/ack path doesn't pay DNS+TLS handshake cost.
+    pub async fn prewarm_urls(&self, urls: &[String]) {
+        for url in urls {
+            let _ = self.http.get(url).send().await;
+        }
+    }
+
+    pub fn order_endpoints(&self) -> Vec<String> {
+        let mut out = Vec::with_capacity(2);
+        out.push(self.order_primary_endpoint.clone());
+        if let Some(backup) = &self.order_backup_endpoint {
+            out.push(backup.clone());
+        }
+        out
+    }
+
+    /// Prune expired orders with lazy cleanup (only every 60 seconds)
+    /// This reduces lock contention from O(n) per call to O(n) per minute
     fn prune_expired_orders(&self) {
-        let mut orders = self.open_orders.write();
-        let now = Instant::now();
-        orders.retain(|_, o| {
-            let ttl = std::time::Duration::from_millis(o.intent.ttl_ms.max(1));
-            now.duration_since(o.created_at) < ttl
-        });
+        // Check if enough time has passed since last prune
+        let should_prune = {
+            let mut last = self.last_prune.lock();
+            let now = Instant::now();
+            if now.duration_since(*last) >= PRUNE_INTERVAL {
+                *last = now;
+                true
+            } else {
+                false
+            }
+        };
+
+        if should_prune {
+            let mut orders = self.open_orders.write();
+            let now = Instant::now();
+            orders.retain(|_, o| {
+                let ttl = Duration::from_millis(o.intent.ttl_ms.max(1));
+                now.duration_since(o.created_at) < ttl
+            });
+        }
     }
 }
 
@@ -121,98 +347,187 @@ impl ExecutionVenue for ClobExecution {
                         created_at: Instant::now(),
                     },
                 );
+                // In paper mode, there is no real exchange RTT. Optionally probe a configured URL
+                // at a low sampling rate to estimate ack_only_ms without placing orders.
+                let mut exchange_latency_ms = 0.0;
+                if let Some(probe) = &self.ack_probe {
+                    let n = probe
+                        .counter
+                        .fetch_add(1, Ordering::Relaxed)
+                        .wrapping_add(1);
+                    if n % probe.every == 0 {
+                        let t0 = Instant::now();
+                        let _ = self.http.get(&probe.url).send().await;
+                        exchange_latency_ms = t0.elapsed().as_secs_f64() * 1_000.0;
+                    }
+                }
                 Ok(OrderAckV2 {
                     order_id,
                     market_id: intent.market_id,
                     accepted: true,
                     accepted_size: intent.size,
                     reject_code: None,
-                    exchange_latency_ms: started.elapsed().as_secs_f64() * 1_000.0,
+                    // Note: default is 0.0 unless probing is enabled.
+                    exchange_latency_ms,
                     ts_ms: Utc::now().timestamp_millis(),
                 })
             }
             ExecutionMode::Live => {
-                let payload = serde_json::json!({
-                    "market_id": intent.market_id,
-                    "side": intent.side.to_string(),
-                    "price": intent.price,
-                    "size": intent.size,
-                    "ttl_ms": intent.ttl_ms,
-                    "style": intent.style.to_string(),
-                    "tif": intent.tif.to_string(),
-                    "max_slippage_bps": intent.max_slippage_bps,
-                    "fee_rate_bps": intent.fee_rate_bps,
-                    "expected_edge_net_bps": intent.expected_edge_net_bps,
-                    "hold_to_resolution": intent.hold_to_resolution,
-                });
-
-                let res = self
-                    .http
-                    .post(format!("{}/orders", self.clob_endpoint))
-                    .json(&payload)
-                    .send()
-                    .await?;
-                let status = res.status();
-                let exchange_latency_ms = started.elapsed().as_secs_f64() * 1_000.0;
-
-                if !status.is_success() {
+                if env_flag_enabled("POLYEDGE_FORCE_PAPER") {
                     return Ok(OrderAckV2 {
                         order_id: new_id(),
                         market_id: intent.market_id,
                         accepted: false,
                         accepted_size: 0.0,
-                        reject_code: Some(format!("http_{}", status.as_u16())),
-                        exchange_latency_ms,
+                        reject_code: Some("force_paper_guard".to_string()),
+                        exchange_latency_ms: 0.0,
                         ts_ms: Utc::now().timestamp_millis(),
                     });
                 }
-
-                let payload_value = res
-                    .json::<serde_json::Value>()
-                    .await
-                    .unwrap_or_else(|_| serde_json::json!({}));
-                let order_id = payload_value
-                    .get("order_id")
-                    .and_then(|v| v.as_str())
-                    .or_else(|| payload_value.get("id").and_then(|v| v.as_str()))
-                    .or_else(|| payload_value.get("orderID").and_then(|v| v.as_str()))
-                    .map(ToString::to_string)
-                    .unwrap_or_else(new_id);
-                let accepted_size = payload_value
-                    .get("accepted_size")
-                    .and_then(|v| v.as_f64())
-                    .or_else(|| payload_value.get("size").and_then(|v| v.as_f64()))
-                    .unwrap_or(intent.size);
-                let mut accepted = payload_value
-                    .get("accepted")
-                    .and_then(|v| v.as_bool())
-                    .unwrap_or(true);
-                let mut reject_code = payload_value
-                    .get("reject_code")
-                    .and_then(|v| v.as_str())
-                    .or_else(|| payload_value.get("reason").and_then(|v| v.as_str()))
-                    .or_else(|| payload_value.get("error").and_then(|v| v.as_str()))
-                    .map(ToString::to_string);
-
-                if accepted_size <= 0.0 {
-                    accepted = false;
-                    reject_code.get_or_insert_with(|| "zero_fill".to_string());
+                // Validate price is finite and within valid range before sending
+                if !intent.price.is_finite() || intent.price <= 0.0 || intent.price >= 1.0 {
+                    return Ok(OrderAckV2 {
+                        order_id: new_id(),
+                        market_id: intent.market_id,
+                        accepted: false,
+                        accepted_size: 0.0,
+                        reject_code: Some("invalid_price".to_string()),
+                        exchange_latency_ms: 0.0,
+                        ts_ms: Utc::now().timestamp_millis(),
+                    });
                 }
-                if accepted && matches!(intent.tif, core_types::OrderTimeInForce::Fok) {
-                    let missing = intent.size - accepted_size;
-                    if missing > 1e-9 {
-                        accepted = false;
-                        reject_code.get_or_insert_with(|| "fok_partial_fill".to_string());
+
+                let body_bytes: Vec<u8> = if let Some(ref prebuilt) = intent.prebuilt_payload {
+                    prebuilt.clone()
+                } else {
+                    encode_live_order_payload(&intent)
+                };
+
+                const MAX_RETRIES: u32 = 2;
+                let mut last_network_error: Option<String> = None;
+                for (idx, endpoint) in self.order_endpoints().iter().enumerate() {
+                    let primary_leg = idx == 0;
+                    for attempt in 0..MAX_RETRIES {
+                        let mut req = self
+                            .http
+                            .post(format!("{endpoint}/orders"))
+                            .header("content-type", "application/json")
+                            .body(body_bytes.clone());
+                        if primary_leg && self.order_failover_timeout > Duration::from_millis(0) {
+                            req = req.timeout(self.order_failover_timeout);
+                        }
+                        let res = match req.send().await {
+                            Ok(res) => res,
+                            Err(err) => {
+                                last_network_error = Some(err.to_string());
+                                if attempt + 1 < MAX_RETRIES {
+                                    continue;
+                                }
+                                break;
+                            }
+                        };
+
+                        let status = res.status();
+                        let raw = res.text().await.unwrap_or_default();
+                        let payload_value = serde_json::from_str::<serde_json::Value>(&raw)
+                            .unwrap_or_else(|_| {
+                                serde_json::json!({
+                                    "raw": raw,
+                                })
+                            });
+                        let order_id = payload_value
+                            .get("order_id")
+                            .and_then(|v| v.as_str())
+                            .or_else(|| payload_value.get("id").and_then(|v| v.as_str()))
+                            .or_else(|| payload_value.get("orderID").and_then(|v| v.as_str()))
+                            .map(ToString::to_string)
+                            .unwrap_or_else(new_id);
+                        let accepted_size = payload_value
+                            .get("accepted_size")
+                            .and_then(|v| v.as_f64())
+                            .or_else(|| payload_value.get("size").and_then(|v| v.as_f64()))
+                            .unwrap_or_else(|| {
+                                if status.is_success() {
+                                    intent.size
+                                } else {
+                                    0.0
+                                }
+                            })
+                            .max(0.0);
+                        let mut accepted = payload_value
+                            .get("accepted")
+                            .and_then(|v| v.as_bool())
+                            .unwrap_or(status.is_success());
+                        let mut reject_code = payload_value
+                            .get("reject_code")
+                            .and_then(|v| v.as_str())
+                            .or_else(|| payload_value.get("reason").and_then(|v| v.as_str()))
+                            .or_else(|| payload_value.get("error").and_then(|v| v.as_str()))
+                            .map(ToString::to_string);
+
+                        if !status.is_success() {
+                            accepted = false;
+                            if reject_code.is_none() {
+                                reject_code = Some(format!("http_{}", status.as_u16()));
+                            }
+                        }
+                        if accepted_size <= 0.0 {
+                            accepted = false;
+                        }
+                        if status.is_server_error() && attempt + 1 < MAX_RETRIES {
+                            continue;
+                        }
+                        if accepted {
+                            if matches!(intent.tif, core_types::OrderTimeInForce::PostOnly) {
+                                self.open_orders.write().insert(
+                                    order_id.clone(),
+                                    PaperOpenOrder {
+                                        intent: QuoteIntent {
+                                            market_id: intent.market_id.clone(),
+                                            side: intent.side.clone(),
+                                            price: intent.price,
+                                            size: accepted_size.max(0.0),
+                                            ttl_ms: intent.ttl_ms,
+                                        },
+                                        created_at: Instant::now(),
+                                    },
+                                );
+                            }
+                            return Ok(OrderAckV2 {
+                                order_id,
+                                market_id: intent.market_id,
+                                accepted: true,
+                                accepted_size,
+                                reject_code: None,
+                                exchange_latency_ms: started.elapsed().as_secs_f64() * 1_000.0,
+                                ts_ms: Utc::now().timestamp_millis(),
+                            });
+                        }
+                        if primary_leg {
+                            break;
+                        }
+                        return Ok(OrderAckV2 {
+                            order_id,
+                            market_id: intent.market_id,
+                            accepted: false,
+                            accepted_size: 0.0,
+                            reject_code,
+                            exchange_latency_ms: started.elapsed().as_secs_f64() * 1_000.0,
+                            ts_ms: Utc::now().timestamp_millis(),
+                        });
                     }
                 }
 
+                let reject_code = last_network_error
+                    .map(|e| format!("network_error:{e}"))
+                    .unwrap_or_else(|| "network_error_after_failover".to_string());
                 Ok(OrderAckV2 {
-                    order_id,
+                    order_id: new_id(),
                     market_id: intent.market_id,
-                    accepted,
-                    accepted_size: accepted_size.max(0.0),
-                    reject_code,
-                    exchange_latency_ms,
+                    accepted: false,
+                    accepted_size: 0.0,
+                    reject_code: Some(reject_code),
+                    exchange_latency_ms: started.elapsed().as_secs_f64() * 1_000.0,
                     ts_ms: Utc::now().timestamp_millis(),
                 })
             }
@@ -226,21 +541,101 @@ impl ExecutionVenue for ClobExecution {
                 Ok(())
             }
             ExecutionMode::Live => {
-                let res = self
-                    .http
-                    .delete(format!("{}/orders/{order_id}", self.clob_endpoint))
-                    .send()
-                    .await?;
-                if !res.status().is_success() {
-                    bail!("cancel failed with status {}", res.status());
+                if env_flag_enabled("POLYEDGE_FORCE_PAPER") {
+                    bail!("force_paper_guard: cancel blocked in live mode");
                 }
-                Ok(())
+                let mut last_status: Option<reqwest::StatusCode> = None;
+                for endpoint in self.order_endpoints() {
+                    let res = self
+                        .http
+                        .delete(format!("{endpoint}/orders/{order_id}"))
+                        .send()
+                        .await?;
+                    if res.status().is_success() {
+                        self.open_orders.write().remove(order_id);
+                        return Ok(());
+                    }
+                    last_status = Some(res.status());
+                }
+                bail!(
+                    "cancel failed with status {}",
+                    last_status
+                        .map(|s| s.as_u16().to_string())
+                        .unwrap_or_else(|| "unknown".to_string())
+                )
             }
         }
     }
 
     async fn flatten_all(&self) -> Result<()> {
         self.open_orders.write().clear();
-        Ok(())
+        match self.mode {
+            ExecutionMode::Paper => Ok(()),
+            ExecutionMode::Live => {
+                if env_flag_enabled("POLYEDGE_FORCE_PAPER") {
+                    bail!("force_paper_guard: flatten blocked in live mode");
+                }
+                let mut last_status: Option<reqwest::StatusCode> = None;
+                for endpoint in self.order_endpoints() {
+                    let res = self.http.post(format!("{endpoint}/flatten")).send().await?;
+                    if res.status().is_success() {
+                        return Ok(());
+                    }
+                    last_status = Some(res.status());
+                }
+                bail!(
+                    "flatten failed with status {}",
+                    last_status
+                        .map(|s| s.as_u16().to_string())
+                        .unwrap_or_else(|| "unknown".to_string())
+                )
+            }
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn env_flag_enabled_parses_common_true_values() {
+        for value in ["1", "true", "TRUE", "yes", "on"] {
+            std::env::set_var("POLYEDGE_TEST_FLAG", value);
+            assert!(env_flag_enabled("POLYEDGE_TEST_FLAG"), "value={value}");
+        }
+        std::env::remove_var("POLYEDGE_TEST_FLAG");
+        assert!(!env_flag_enabled("POLYEDGE_TEST_FLAG"));
+    }
+
+    #[test]
+    fn order_endpoints_include_backup_when_configured() {
+        let exec = ClobExecution::new_with_order_routing(
+            ExecutionMode::Paper,
+            "https://clob.polymarket.com".to_string(),
+            Some("http://127.0.0.1:9001".to_string()),
+            Some("http://127.0.0.1:9002".to_string()),
+            Duration::from_millis(1_000),
+            Duration::from_millis(200),
+        );
+        let endpoints = exec.order_endpoints();
+        assert_eq!(endpoints.len(), 2);
+        assert_eq!(endpoints[0], "http://127.0.0.1:9001");
+        assert_eq!(endpoints[1], "http://127.0.0.1:9002");
+    }
+
+    #[test]
+    fn order_endpoints_dedup_empty_backup() {
+        let exec = ClobExecution::new_with_order_routing(
+            ExecutionMode::Paper,
+            "https://clob.polymarket.com".to_string(),
+            Some("http://127.0.0.1:9001".to_string()),
+            Some("http://127.0.0.1:9001".to_string()),
+            Duration::from_millis(1_000),
+            Duration::from_millis(200),
+        );
+        let endpoints = exec.order_endpoints();
+        assert_eq!(endpoints.len(), 1);
+        assert_eq!(endpoints[0], "http://127.0.0.1:9001");
     }
 }
diff --git a/crates/execution_clob/src/wss_user_feed.rs b/crates/execution_clob/src/wss_user_feed.rs
new file mode 100644
index 0000000..29e2c0e
--- /dev/null
+++ b/crates/execution_clob/src/wss_user_feed.rs
@@ -0,0 +1,199 @@
+use std::sync::atomic::{AtomicU64, Ordering};
+use std::sync::Arc;
+use std::time::Duration;
+
+use anyhow::Result;
+use futures::{SinkExt, StreamExt};
+use serde::Deserialize;
+use tokio::sync::broadcast;
+use tokio_tungstenite::connect_async;
+use tokio_tungstenite::tungstenite::Message;
+
+// -----------------------------------------------------------------------
+// ÂÖ¨ÂºÄÁ±ªÂûã
+// -----------------------------------------------------------------------
+
+/// ‰ªé WSS user channel Ëß£ÊûêÂá∫ÁöÑ fill ‰∫ã‰ª∂Ôºà‰ªÖ‰øùÁïô exit lifecycle ÂÖ≥ÂøÉÁöÑÂ≠óÊÆµÔºâ
+#[derive(Debug, Clone)]
+pub struct WssFillEvent {
+    /// ËÆ¢Âçï IDÔºàÂØπÂ∫î OrderAckV2.order_idÔºâ
+    pub order_id: String,
+    /// Â∏ÇÂú∫ ID
+    pub market_id: String,
+    /// Êàê‰∫§‰ª∑Ê†º
+    pub price: f64,
+    /// Êàê‰∫§Êï∞Èáè
+    pub size: f64,
+    /// ‰∫ã‰ª∂Á±ªÂûã: "trade" | "order"
+    pub event_type: &'static str,
+    /// ÊúçÂä°Á´ØÊó∂Èó¥Êà≥ ms
+    pub ts_ms: i64,
+}
+
+// -----------------------------------------------------------------------
+// ÂÜÖÈÉ® JSON ÁªìÊûÑÔºàPolymarket WSS user channel Ê†ºÂºèÔºâ
+// -----------------------------------------------------------------------
+
+#[derive(Debug, Deserialize)]
+struct WssEnvelope {
+    event_type: Option<String>,
+    #[serde(default)]
+    data: Vec<WssEventData>,
+}
+
+#[derive(Debug, Deserialize)]
+struct WssEventData {
+    #[serde(default)]
+    order_id: String,
+    #[serde(default)]
+    market: String,
+    #[serde(default)]
+    price: String,
+    #[serde(default)]
+    size: String,
+    #[serde(default)]
+    timestamp: String,
+    // order ‰∫ã‰ª∂Â≠óÊÆµ
+    #[serde(default)]
+    id: String,
+    #[serde(default)]
+    market_id: String,
+}
+
+// -----------------------------------------------------------------------
+// ÂÖ¨ÂºÄÂÖ•Âè£Ôºöapp_runner ÂèØÁî®Ëá™Â∑±ÁöÑ broadcast::Sender ÂêØÂä® WSS Âæ™ÁéØ
+// -----------------------------------------------------------------------
+
+/// ÂêØÂä® WSS user channel Âæ™ÁéØÔºàËá™Âä®ÈáçËøûÔºåÊ∞∏‰∏çÈÄÄÂá∫Ôºâ
+///
+/// `tx`: ÂπøÊí≠ÂèëÈÄÅÁ´ØÔºàapp_runner ÊåÅÊúâ Arc<Sender>ÔºåÊ≠§Â§ÑÂÖ±‰∫´Ôºâ
+/// `wss_url`: Polymarket user channel URL
+/// `api_key`: CLOB API keyÔºàÁî®‰∫é subscribe Ê∂àÊÅØËÆ§ËØÅÔºâ
+pub async fn run_wss_loop_with_sender(
+    tx: Arc<broadcast::Sender<WssFillEvent>>,
+    wss_url: String,
+    api_key: String,
+) {
+    let mut backoff_ms = 500_u64;
+    loop {
+        match connect_and_stream(&tx, &wss_url, &api_key).await {
+            Ok(()) => {
+                tracing::info!("wss_user_feed: connection closed, reconnecting");
+                backoff_ms = 500;
+            }
+            Err(err) => {
+                tracing::warn!(
+                    ?err,
+                    backoff_ms,
+                    "wss_user_feed: connection error, retrying"
+                );
+                backoff_ms = (backoff_ms * 2).min(30_000);
+            }
+        }
+        tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
+    }
+}
+
+// -----------------------------------------------------------------------
+// Ê†∏ÂøÉËøûÊé•Âæ™ÁéØ
+// -----------------------------------------------------------------------
+
+async fn connect_and_stream(
+    tx: &Arc<broadcast::Sender<WssFillEvent>>,
+    wss_url: &str,
+    api_key: &str,
+) -> Result<()> {
+    let (mut ws, _) = connect_async(wss_url).await?;
+    tracing::info!(wss_url, "wss_user_feed: connected");
+
+    // ÂèëÈÄÅ subscribe Ê∂àÊÅØÔºàPolymarket user channel ËÆ§ËØÅÊ†ºÂºèÔºâ
+    let subscribe_json = serde_json::json!({
+        "auth": { "apiKey": api_key },
+        "type": "subscribe",
+        "channel": "user",
+    })
+    .to_string();
+    ws.send(Message::Text(subscribe_json.into())).await?;
+
+    while let Some(msg) = ws.next().await {
+        let msg = msg?;
+        match msg {
+            Message::Text(text) => {
+                if let Ok(envelope) = serde_json::from_str::<WssEnvelope>(&text) {
+                    parse_and_broadcast(tx, envelope);
+                }
+            }
+            // tungstenite 0.24+ Ëá™Âä®ÂìçÂ∫î PingÔºåÊó†ÈúÄÊâãÂä®Â§ÑÁêÜ
+            Message::Close(_) => break,
+            _ => {}
+        }
+    }
+    Ok(())
+}
+
+// -----------------------------------------------------------------------
+// ‰∫ã‰ª∂Ëß£Êûê ‚Äî Èõ∂ÂàÜÈÖçÁÉ≠Ë∑ØÂæÑ
+// -----------------------------------------------------------------------
+
+fn parse_and_broadcast(tx: &Arc<broadcast::Sender<WssFillEvent>>, envelope: WssEnvelope) {
+    let event_type = match envelope.event_type.as_deref() {
+        Some("trade") => "trade",
+        Some("order") => "order",
+        _ => return, // ÂøΩÁï•Èùû fill ‰∫ã‰ª∂Ôºàheartbeat Á≠âÔºâ
+    };
+
+    for data in envelope.data {
+        let order_id = if !data.order_id.is_empty() {
+            data.order_id.clone()
+        } else {
+            data.id.clone()
+        };
+        if order_id.is_empty() {
+            continue;
+        }
+
+        let market_id = if !data.market.is_empty() {
+            data.market.clone()
+        } else {
+            data.market_id.clone()
+        };
+
+        let Ok(price) = data.price.parse::<f64>() else {
+            record_parse_error("price");
+            continue;
+        };
+        let Ok(size) = data.size.parse::<f64>() else {
+            record_parse_error("size");
+            continue;
+        };
+        let ts_ms = data
+            .timestamp
+            .parse::<i64>()
+            .unwrap_or_else(|_| chrono::Utc::now().timestamp_millis());
+
+        let event = WssFillEvent {
+            order_id,
+            market_id,
+            price,
+            size,
+            event_type,
+            ts_ms,
+        };
+
+        // ÂøΩÁï• lagged receiver ÈîôËØØÔºàÊ∂àË¥πËÄÖÂ§™ÊÖ¢Êó∂‰∏¢ÂºÉÊóß‰∫ã‰ª∂Ôºâ
+        let _ = tx.send(event);
+    }
+}
+
+static PARSE_ERROR_COUNT: AtomicU64 = AtomicU64::new(0);
+
+fn record_parse_error(field: &'static str) {
+    let count = PARSE_ERROR_COUNT.fetch_add(1, Ordering::Relaxed) + 1;
+    if count.is_power_of_two() {
+        tracing::warn!(
+            field,
+            count,
+            "wss_user_feed: dropping malformed fill event field"
+        );
+    }
+}
diff --git a/crates/exit_manager/Cargo.toml b/crates/exit_manager/Cargo.toml
new file mode 100644
index 0000000..ab61b2c
--- /dev/null
+++ b/crates/exit_manager/Cargo.toml
@@ -0,0 +1,9 @@
+[package]
+name = "exit_manager"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+serde.workspace = true
+
diff --git a/crates/exit_manager/src/lib.rs b/crates/exit_manager/src/lib.rs
new file mode 100644
index 0000000..0567607
--- /dev/null
+++ b/crates/exit_manager/src/lib.rs
@@ -0,0 +1,463 @@
+use std::collections::HashMap;
+
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ExitManagerConfig {
+    /// Early reversal threshold (bps) for the 100ms..300ms window.
+    pub t100ms_reversal_bps: f64,
+    /// Reversal threshold (bps) for the 300ms..3s window.
+    pub t300ms_reversal_bps: f64,
+    /// Convergence ratio threshold. Exit once PM has closed enough of the fair-value gap.
+    pub convergence_exit_ratio: f64,
+    /// T+3s take-profit ratio against entry edge.
+    pub t3_take_ratio: f64,
+    /// Minimum unrealized PnL at T+15s.
+    pub t15_min_unrealized_usdc: f64,
+    /// Probability guard floor at T+60s.
+    pub t60_true_prob_floor: f64,
+    /// Hard max holding time in ms.
+    pub t300_force_exit_ms: u64,
+    /// Allow-hold probability threshold near expiry.
+    pub t300_hold_prob_threshold: f64,
+    /// Allow-hold remaining-time threshold in ms.
+    pub t300_hold_time_to_expiry_ms: u64,
+    /// Max allowed loss per position in USDC.
+    pub max_single_trade_loss_usdc: f64,
+}
+
+impl Default for ExitManagerConfig {
+    fn default() -> Self {
+        Self {
+            t100ms_reversal_bps: -3.0,
+            t300ms_reversal_bps: -2.0,
+            convergence_exit_ratio: 0.85,
+            t3_take_ratio: 0.60,
+            t15_min_unrealized_usdc: 0.0,
+            t60_true_prob_floor: 0.70,
+            t300_force_exit_ms: 300_000,
+            t300_hold_prob_threshold: 0.95,
+            t300_hold_time_to_expiry_ms: 300_000,
+            max_single_trade_loss_usdc: 1.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PositionLifecycle {
+    pub position_id: String,
+    pub market_id: String,
+    pub symbol: String,
+    pub opened_at_ms: i64,
+    pub entry_edge_usdc: f64,
+    pub entry_notional_usdc: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct MarketEvalInput {
+    pub now_ms: i64,
+    pub unrealized_pnl_usdc: f64,
+    pub true_prob: f64,
+    pub time_to_expiry_ms: i64,
+    /// Current PM YES mid used for convergence checks.
+    pub pm_mid_yes: f64,
+    /// PM YES mid at entry.
+    pub entry_pm_mid_yes: f64,
+    /// Fair YES value at entry.
+    pub entry_fair_yes: f64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+#[serde(rename_all = "snake_case")]
+pub enum ExitReason {
+    /// Hard stop on max per-trade loss.
+    StopLoss,
+    /// Sharp reversal in 100ms..300ms.
+    Reversal100ms,
+    /// Sustained reversal in 300ms..3s.
+    Reversal300ms,
+    /// PM price has converged enough to fair value.
+    ConvergenceExit,
+    /// Profit target reached at/after T+3s.
+    TakeProfit3s,
+    /// Any positive pnl at/after T+15s.
+    TakeProfit15s,
+    /// Probability guard at/after T+60s.
+    ProbGuard60s,
+    /// Hard close after max hold time.
+    ForceClose300s,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ExitAction {
+    pub position_id: String,
+    pub market_id: String,
+    pub symbol: String,
+    pub reason: ExitReason,
+}
+
+#[derive(Debug)]
+pub struct ExitManager {
+    cfg: ExitManagerConfig,
+    open: HashMap<String, PositionLifecycle>,
+}
+
+impl ExitManager {
+    pub fn new(cfg: ExitManagerConfig) -> Self {
+        Self {
+            cfg,
+            open: HashMap::new(),
+        }
+    }
+
+    pub fn cfg(&self) -> &ExitManagerConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, cfg: ExitManagerConfig) {
+        self.cfg = cfg;
+    }
+
+    pub fn register(&mut self, position: PositionLifecycle) {
+        // Keep one active position per market to avoid stale entries that can never be selected.
+        if let Some(existing_id) = self
+            .open
+            .iter()
+            .find_map(|(id, p)| (p.market_id == position.market_id).then(|| id.clone()))
+        {
+            self.open.remove(&existing_id);
+        }
+        self.open.insert(position.position_id.clone(), position);
+    }
+
+    pub fn close(&mut self, position_id: &str) -> Option<PositionLifecycle> {
+        self.open.remove(position_id)
+    }
+
+    pub fn open_count(&self) -> usize {
+        self.open.len()
+    }
+
+    pub fn evaluate_market(
+        &mut self,
+        market_id: &str,
+        input: MarketEvalInput,
+    ) -> Option<ExitAction> {
+        let position = self
+            .open
+            .values()
+            .filter(|p| p.market_id == market_id)
+            .max_by_key(|p| p.opened_at_ms)
+            .cloned()?;
+        let reason = self.evaluate_position(&position, &input)?;
+        self.open.remove(&position.position_id);
+        Some(ExitAction {
+            position_id: position.position_id,
+            market_id: position.market_id,
+            symbol: position.symbol,
+            reason,
+        })
+    }
+
+    fn evaluate_position(
+        &self,
+        position: &PositionLifecycle,
+        input: &MarketEvalInput,
+    ) -> Option<ExitReason> {
+        let elapsed_ms = input.now_ms.saturating_sub(position.opened_at_ms).max(0) as u64;
+        let true_prob = input.true_prob.clamp(0.0, 1.0);
+
+        if input.unrealized_pnl_usdc <= -self.cfg.max_single_trade_loss_usdc {
+            return Some(ExitReason::StopLoss);
+        }
+
+        if position.entry_notional_usdc > 0.0 && (100..300).contains(&elapsed_ms) {
+            let pnl_bps = (input.unrealized_pnl_usdc / position.entry_notional_usdc) * 10_000.0;
+            if pnl_bps <= self.cfg.t100ms_reversal_bps {
+                return Some(ExitReason::Reversal100ms);
+            }
+        }
+
+        if position.entry_notional_usdc > 0.0 && (300..3_000).contains(&elapsed_ms) {
+            let pnl_bps = (input.unrealized_pnl_usdc / position.entry_notional_usdc) * 10_000.0;
+            if pnl_bps <= self.cfg.t300ms_reversal_bps {
+                return Some(ExitReason::Reversal300ms);
+            }
+        }
+
+        if self.cfg.convergence_exit_ratio > 0.0
+            && input.pm_mid_yes > 0.0
+            && input.entry_pm_mid_yes > 0.0
+            && input.entry_fair_yes > 0.0
+        {
+            let gap_total = (input.entry_fair_yes - input.entry_pm_mid_yes).abs();
+            if gap_total > 1e-6 {
+                let gap_remaining = (input.entry_fair_yes - input.pm_mid_yes).abs();
+                let convergence_ratio = 1.0 - (gap_remaining / gap_total);
+                if convergence_ratio >= self.cfg.convergence_exit_ratio {
+                    return Some(ExitReason::ConvergenceExit);
+                }
+            }
+        }
+
+        if elapsed_ms >= 3_000 {
+            let t3_target = position.entry_edge_usdc.max(0.0) * self.cfg.t3_take_ratio;
+            if input.unrealized_pnl_usdc > t3_target {
+                return Some(ExitReason::TakeProfit3s);
+            }
+        }
+
+        // Default t15_min_unrealized_usdc=0.0 means any positive PnL exits at T+15s.
+        if elapsed_ms >= 15_000 && input.unrealized_pnl_usdc > self.cfg.t15_min_unrealized_usdc {
+            return Some(ExitReason::TakeProfit15s);
+        }
+
+        if elapsed_ms >= 60_000 && true_prob <= self.cfg.t60_true_prob_floor {
+            return Some(ExitReason::ProbGuard60s);
+        }
+
+        if elapsed_ms >= self.cfg.t300_force_exit_ms {
+            let allow_hold = true_prob > self.cfg.t300_hold_prob_threshold
+                && input.time_to_expiry_ms >= 0
+                && (input.time_to_expiry_ms as u64) < self.cfg.t300_hold_time_to_expiry_ms;
+            if !allow_hold {
+                return Some(ExitReason::ForceClose300s);
+            }
+        }
+
+        None
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn sample_position(opened_at_ms: i64) -> PositionLifecycle {
+        PositionLifecycle {
+            position_id: "p1".to_string(),
+            market_id: "m1".to_string(),
+            symbol: "BTCUSDT".to_string(),
+            opened_at_ms,
+            entry_edge_usdc: 1.0,
+            entry_notional_usdc: 50.0,
+        }
+    }
+
+    fn eval(
+        now_ms: i64,
+        unrealized_pnl_usdc: f64,
+        true_prob: f64,
+        time_to_expiry_ms: i64,
+    ) -> MarketEvalInput {
+        MarketEvalInput {
+            now_ms,
+            unrealized_pnl_usdc,
+            true_prob,
+            time_to_expiry_ms,
+            pm_mid_yes: 0.0,
+            entry_pm_mid_yes: 0.0,
+            entry_fair_yes: 0.0,
+        }
+    }
+
+    #[test]
+    fn stop_loss_triggers_immediately() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(1_100, -1.1, 0.9, 600_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::StopLoss)
+        ));
+    }
+
+    #[test]
+    fn reversal_100ms_triggers_on_fast_reversal() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(1_150, -0.02, 0.9, 600_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::Reversal100ms)
+        ));
+    }
+
+    #[test]
+    fn reversal_100ms_does_not_trigger_too_early() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(1_050, -0.02, 0.9, 600_000));
+        assert!(action.is_none());
+    }
+
+    #[test]
+    fn reversal_100ms_does_not_trigger_on_small_loss() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(1_150, -0.005, 0.9, 600_000));
+        assert!(action.is_none());
+    }
+
+    #[test]
+    fn reversal_300ms_triggers_before_t3() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(1_400, -0.01, 0.9, 500_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::Reversal300ms)
+        ));
+    }
+
+    #[test]
+    fn t3_take_profit_triggers() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(4_500, 0.7, 0.8, 500_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::TakeProfit3s)
+        ));
+    }
+
+    #[test]
+    fn t15_positive_exit_triggers() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(20_500, 0.01, 0.9, 450_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::TakeProfit15s)
+        ));
+    }
+
+    #[test]
+    fn t60_prob_guard_triggers_on_low_prob() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(62_000, -0.2, 0.65, 360_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::ProbGuard60s)
+        ));
+    }
+
+    #[test]
+    fn t300_force_close_triggers() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(305_000, -0.01, 0.93, 1_000_000));
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::ForceClose300s)
+        ));
+    }
+
+    #[test]
+    fn t300_allows_hold_near_expiry_with_high_prob() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market("m1", eval(305_000, -0.01, 0.97, 240_000));
+        assert!(action.is_none());
+        assert_eq!(manager.open_count(), 1);
+    }
+
+    #[test]
+    fn evaluate_market_uses_latest_position() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(PositionLifecycle {
+            position_id: "old".to_string(),
+            opened_at_ms: 1_000,
+            ..sample_position(1_000)
+        });
+        manager.register(PositionLifecycle {
+            position_id: "new".to_string(),
+            opened_at_ms: 10_000,
+            ..sample_position(10_000)
+        });
+        let action = manager.evaluate_market("m1", eval(15_000, 1.0, 0.9, 600_000));
+        let Some(action) = action else {
+            panic!("expected action");
+        };
+        assert_eq!(action.position_id, "new");
+    }
+
+    #[test]
+    fn register_enforces_single_position_per_market() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(PositionLifecycle {
+            position_id: "old".to_string(),
+            opened_at_ms: 1_000,
+            ..sample_position(1_000)
+        });
+        manager.register(PositionLifecycle {
+            position_id: "new".to_string(),
+            opened_at_ms: 2_000,
+            ..sample_position(2_000)
+        });
+        assert_eq!(manager.open_count(), 1);
+        let action = manager.evaluate_market("m1", eval(6_000, 1.0, 0.9, 600_000));
+        assert_eq!(action.map(|a| a.position_id), Some("new".to_string()));
+    }
+
+    #[test]
+    fn convergence_exit_triggers_at_85_percent() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market(
+            "m1",
+            MarketEvalInput {
+                now_ms: 1_500,
+                unrealized_pnl_usdc: 0.5,
+                true_prob: 0.9,
+                time_to_expiry_ms: 600_000,
+                pm_mid_yes: 0.785,
+                entry_pm_mid_yes: 0.70,
+                entry_fair_yes: 0.80,
+            },
+        );
+        assert!(matches!(
+            action.map(|a| a.reason),
+            Some(ExitReason::ConvergenceExit)
+        ));
+    }
+
+    #[test]
+    fn convergence_exit_does_not_trigger_below_threshold() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market(
+            "m1",
+            MarketEvalInput {
+                now_ms: 1_500,
+                unrealized_pnl_usdc: 0.3,
+                true_prob: 0.9,
+                time_to_expiry_ms: 600_000,
+                pm_mid_yes: 0.77,
+                entry_pm_mid_yes: 0.70,
+                entry_fair_yes: 0.80,
+            },
+        );
+        assert!(action.is_none());
+    }
+
+    #[test]
+    fn convergence_exit_skipped_when_pm_mid_zero() {
+        let mut manager = ExitManager::new(ExitManagerConfig::default());
+        manager.register(sample_position(1_000));
+        let action = manager.evaluate_market(
+            "m1",
+            MarketEvalInput {
+                now_ms: 1_500,
+                unrealized_pnl_usdc: 0.5,
+                true_prob: 0.9,
+                time_to_expiry_ms: 600_000,
+                pm_mid_yes: 0.0,
+                entry_pm_mid_yes: 0.70,
+                entry_fair_yes: 0.80,
+            },
+        );
+        assert!(action.is_none());
+    }
+}
diff --git a/crates/fair_value/Cargo.toml b/crates/fair_value/Cargo.toml
index ee9b27f..d81c669 100644
--- a/crates/fair_value/Cargo.toml
+++ b/crates/fair_value/Cargo.toml
@@ -7,3 +7,4 @@ license.workspace = true
 [dependencies]
 core_types = { path = "../core_types" }
 serde.workspace = true
+parking_lot.workspace = true
diff --git a/crates/fair_value/src/lib.rs b/crates/fair_value/src/lib.rs
index 95b416f..4c94ef7 100644
--- a/crates/fair_value/src/lib.rs
+++ b/crates/fair_value/src/lib.rs
@@ -1,7 +1,8 @@
 use std::collections::HashMap;
-use std::sync::{Arc, Mutex, RwLock};
+use std::sync::{Arc, RwLock};
 
 use core_types::{BookTop, FairValueModel, RefTick, Signal};
+use parking_lot::Mutex;
 use serde::{Deserialize, Serialize};
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
@@ -67,18 +68,17 @@ impl Default for BasisMrFairValue {
 
 impl FairValueModel for BasisMrFairValue {
     fn evaluate(&self, tick: &RefTick, book: &BookTop) -> Signal {
-        let cfg = self
-            .cfg
-            .read()
-            .map(|g| g.clone())
-            .unwrap_or_else(|_| BasisMrConfig::default());
+        let cfg = match self.cfg.read() {
+            Ok(guard) => guard.clone(),
+            Err(poisoned) => poisoned.into_inner().clone(),
+        };
         let mid_yes = ((book.bid_yes + book.ask_yes) * 0.5).clamp(0.001, 0.999);
         let spread = (book.ask_yes - book.bid_yes).max(0.0001);
         // Fix DESIGN-2: Key by symbol only (e.g. "BTCUSDT") to share specific fair value state
         // across all markets (e.g. daily, 15m) for that asset. This prevents warmup reset on rollover.
         let key = tick.symbol.clone();
 
-        let mut map = self.state.lock().unwrap_or_else(|e| e.into_inner());
+        let mut map = self.state.lock();
         let st = map.entry(key).or_default();
 
         let ret = if st.last_ref_px > 0.0 {
@@ -137,8 +137,11 @@ mod tests {
             symbol: "BTCUSDT".to_string(),
             event_ts_ms: ts,
             recv_ts_ms: ts,
+            source_seq: ts.max(0) as u64,
             event_ts_exchange_ms: ts,
             recv_ts_local_ns: ts * 1_000_000,
+            ingest_ts_local_ns: ts * 1_000_000,
+            ts_first_hop_ms: None,
             price: px,
         }
     }
diff --git a/crates/feed_polymarket/src/lib.rs b/crates/feed_polymarket/src/lib.rs
index 92fdd98..c40e752 100644
--- a/crates/feed_polymarket/src/lib.rs
+++ b/crates/feed_polymarket/src/lib.rs
@@ -13,10 +13,21 @@ use rand::Rng;
 use reqwest::Client;
 use serde::Deserialize;
 use tokio::sync::mpsc;
+use tokio::time::timeout;
 use tokio_stream::wrappers::ReceiverStream;
 use tokio_tungstenite::connect_async;
 use tokio_tungstenite::tungstenite::Message;
 
+/// WebSocket connection timeout
+const WS_CONNECT_TIMEOUT: Duration = Duration::from_secs(10);
+/// WebSocket read timeout - prevents hanging on stale connections
+const WS_READ_TIMEOUT: Duration = Duration::from_secs(30);
+
+/// Validates that a price value is finite and within valid range [0, 1]
+fn validate_price(price: f64) -> bool {
+    price.is_finite() && (0.0..=1.0).contains(&price)
+}
+
 #[derive(Debug, Clone)]
 pub struct PolymarketEndpoints {
     pub gamma_markets: String,
@@ -154,11 +165,11 @@ impl PolymarketFeed {
         let this = self.clone();
 
         tokio::spawn(async move {
-            loop {
-                if let Err(err) = this.run_market_loop(&tx).await {
-                    tracing::warn!(?err, "polymarket market ws loop failed; reconnecting");
-                }
-                sleep_with_jitter(this.reconnect_backoff).await;
+            // NOTE: app_runner owns the reconnect lifecycle for market feed.
+            // Keep this worker single-shot to avoid nested reconnect loops that
+            // can fan out into discovery storms (and trigger Gamma 429s).
+            if let Err(err) = this.run_market_loop(&tx).await {
+                tracing::warn!(?err, "polymarket market ws loop failed");
             }
         });
 
@@ -184,9 +195,13 @@ impl PolymarketFeed {
             "polymarket market ws subscribing"
         );
 
-        let (mut ws, _) = connect_async(&self.endpoints.clob_ws_market)
-            .await
-            .context("connect polymarket market ws")?;
+        let (mut ws, _) = timeout(
+            WS_CONNECT_TIMEOUT,
+            connect_async(&self.endpoints.clob_ws_market),
+        )
+        .await
+        .context("connect polymarket market ws timeout")?
+        .context("connect polymarket market ws")?;
         tracing::info!(endpoint = %self.endpoints.clob_ws_market, "polymarket market ws connected");
 
         let sub = serde_json::json!({
@@ -200,21 +215,51 @@ impl PolymarketFeed {
 
         let mut ping = tokio::time::interval(Duration::from_secs(15));
         ping.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
+        // Many Polymarket markets (especially 5m/15m contracts) expire quickly. If the WS
+        // connection stays up, we would otherwise keep subscribing to stale/closed assets and
+        // stop seeing updates. Force a periodic re-discovery + resubscribe.
+        let refresh_every = std::env::var("POLYEDGE_MARKET_REFRESH_SEC")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .map(Duration::from_secs)
+            .unwrap_or(Duration::from_secs(120));
+        let refresh_deadline = tokio::time::sleep(refresh_every);
+        tokio::pin!(refresh_deadline);
         let mut parse_failures = 0_u64;
         let mut no_update_msgs = 0_u64;
         let mut seen_msgs = 0_u64;
 
         loop {
             tokio::select! {
+                _ = &mut refresh_deadline => {
+                    tracing::info!(
+                        refresh_sec = refresh_every.as_secs(),
+                        "polymarket market ws refresh triggered; resubscribing"
+                    );
+                    break;
+                }
                 _ = ping.tick() => {
                     // The Polymarket WS docs recommend an application-level "PING".
                     ws.send(Message::Text("PING".to_string().into()))
                         .await
                         .context("send polymarket ping")?;
                 }
-                msg = ws.next() => {
-                    let Some(msg) = msg else { break };
-                    let msg = msg.context("polymarket ws read")?;
+                msg = timeout(WS_READ_TIMEOUT, ws.next()) => {
+                    let msg = match msg {
+                        Ok(m) => m,
+                        Err(_) => {
+                            tracing::warn!("polymarket ws read timeout, reconnecting");
+                            break;
+                        }
+                    };
+                    let msg = match msg {
+                        Some(Ok(m)) => m,
+                        None => break, // Stream ended
+                        Some(Err(e)) => {
+                            tracing::warn!(error = %e, "polymarket ws read error");
+                            break;
+                        }
+                    };
                     let text = match msg {
                         Message::Text(t) => t.to_string(),
                         Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
@@ -285,11 +330,20 @@ impl PolymarketFeed {
                             } else {
                                 &mut state.no
                             };
+                            // Validate price data before assignment
                             if let Some(v) = update.best_bid {
-                                target.bid = v;
+                                if validate_price(v) {
+                                    target.bid = v;
+                                } else {
+                                    tracing::warn!(price = v, "invalid bid price, skipping");
+                                }
                             }
                             if let Some(v) = update.best_ask {
-                                target.ask = v;
+                                if validate_price(v) {
+                                    target.ask = v;
+                                } else {
+                                    tracing::warn!(price = v, "invalid ask price, skipping");
+                                }
                             }
                             target.ts_exchange_ms = update.ts_exchange_ms;
                             target.recv_ts_local_ns = update.recv_ts_local_ns;
@@ -350,8 +404,9 @@ async fn run_book_update_loop(
 ) -> Result<()> {
     let token_market_map = fetch_token_market_map(gamma_endpoint, token_ids).await?;
 
-    let (mut ws, _) = connect_async(endpoint)
+    let (mut ws, _) = timeout(WS_CONNECT_TIMEOUT, connect_async(endpoint))
         .await
+        .with_context(|| format!("connect polymarket ws timeout: {endpoint}"))?
         .with_context(|| format!("connect polymarket ws: {endpoint}"))?;
 
     let sub = serde_json::json!({
@@ -373,9 +428,22 @@ async fn run_book_update_loop(
                     .await
                     .context("send polymarket book ping")?;
             }
-            msg = ws.next() => {
-                let Some(msg) = msg else { break };
-                let msg = msg.context("polymarket book ws read")?;
+            msg = timeout(WS_READ_TIMEOUT, ws.next()) => {
+                let msg = match msg {
+                    Ok(m) => m,
+                    Err(_) => {
+                        tracing::warn!("polymarket book ws read timeout, reconnecting");
+                        break;
+                    }
+                };
+                let msg = match msg {
+                    Some(Ok(m)) => m,
+                    None => break,
+                    Some(Err(e)) => {
+                        tracing::warn!(error = %e, "polymarket book ws read error");
+                        break;
+                    }
+                };
                 let text = match msg {
                     Message::Text(t) => t.to_string(),
                     Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
@@ -417,7 +485,16 @@ async fn run_book_update_loop(
                         if let Some(market_id) = token_market_map.get(&snapshot.asset_id) {
                             snapshot.market_id = market_id.clone();
                         }
-                        if tx.send(BookUpdate::Snapshot(snapshot)).await.is_err() {
+                        // Validate snapshot price levels
+                        let mut valid_snapshot = true;
+                        for level in snapshot.bids.iter().chain(snapshot.asks.iter()) {
+                            if !validate_price(level.price) {
+                                tracing::warn!(price = level.price, "invalid snapshot price level");
+                                valid_snapshot = false;
+                                break;
+                            }
+                        }
+                        if valid_snapshot && tx.send(BookUpdate::Snapshot(snapshot)).await.is_err() {
                             return Ok(());
                         }
                     }
@@ -426,6 +503,13 @@ async fn run_book_update_loop(
                         if let Some(market_id) = token_market_map.get(&delta.asset_id) {
                             delta.market_id = market_id.clone();
                         }
+                        // Validate delta prices
+                        let valid_bid = delta.best_bid.map(validate_price).unwrap_or(true);
+                        let valid_ask = delta.best_ask.map(validate_price).unwrap_or(true);
+                        if !valid_bid || !valid_ask {
+                            tracing::warn!("invalid delta prices, skipping");
+                            continue;
+                        }
                         let digest = OrderbookStateDigest {
                             market_id: delta.market_id.clone(),
                             asset_id: delta.asset_id.clone(),
@@ -693,8 +777,12 @@ fn top_level_price(value: Option<&Vec<WsLevel>>) -> Option<f64> {
     value?.first()?.price
 }
 
+/// Fast timestamp using SystemTime (more efficient than chrono::Utc::now())
 fn now_ms() -> i64 {
-    chrono::Utc::now().timestamp_millis()
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .map(|d| d.as_millis() as i64)
+        .unwrap_or(0)
 }
 
 async fn sleep_with_jitter(base: Duration) {
@@ -704,9 +792,10 @@ async fn sleep_with_jitter(base: Duration) {
 }
 
 fn now_ns() -> i64 {
-    chrono::Utc::now()
-        .timestamp_nanos_opt()
-        .unwrap_or_else(|| now_ms() * 1_000_000)
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .map(|d| d.as_nanos() as i64)
+        .unwrap_or_else(|_| now_ms() * 1_000_000)
 }
 
 #[derive(Debug, Deserialize)]
diff --git a/crates/feed_reference/src/lib.rs b/crates/feed_reference/src/lib.rs
index e4e2c08..d2e5681 100644
--- a/crates/feed_reference/src/lib.rs
+++ b/crates/feed_reference/src/lib.rs
@@ -1,5 +1,6 @@
 use std::collections::HashSet;
-use std::time::Duration;
+use std::sync::atomic::{AtomicU64, Ordering};
+use std::time::{Duration, Instant};
 
 use anyhow::{Context, Result};
 use core_types::{DynStream, RefPriceFeed, RefPriceWsFeed, RefTick};
@@ -8,10 +9,29 @@ use rand::Rng;
 use reqwest::Client;
 use serde::Deserialize;
 use tokio::sync::mpsc;
+use tokio::time::timeout;
 use tokio_stream::wrappers::ReceiverStream;
 use tokio_tungstenite::connect_async;
 use tokio_tungstenite::tungstenite::Message;
 
+/// WebSocket connection timeout
+const WS_CONNECT_TIMEOUT: Duration = Duration::from_secs(10);
+/// WebSocket read timeout - prevents hanging on stale connections
+const WS_READ_TIMEOUT: Duration = Duration::from_secs(30);
+const REF_TICK_QUEUE_DEFAULT: usize = 16_384;
+
+/// Validates that a price value is finite and positive
+fn validate_price(price: f64) -> bool {
+    price.is_finite() && price > 0.0
+}
+
+fn env_flag(key: &str, default: bool) -> bool {
+    std::env::var(key)
+        .ok()
+        .map(|v| v != "0" && !v.eq_ignore_ascii_case("false"))
+        .unwrap_or(default)
+}
+
 #[derive(Debug, Clone)]
 pub struct MultiSourceRefFeed {
     _http: Client,
@@ -37,46 +57,28 @@ impl RefPriceFeed for MultiSourceRefFeed {
 #[async_trait::async_trait]
 impl RefPriceWsFeed for MultiSourceRefFeed {
     async fn stream_ticks_ws(&self, symbols: Vec<String>) -> Result<DynStream<RefTick>> {
-        let (tx, rx) = mpsc::channel::<RefTick>(16_384);
+        let queue_cap = std::env::var("POLYEDGE_REF_TICK_QUEUE_CAP")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(REF_TICK_QUEUE_DEFAULT)
+            .clamp(1_024, 65_536);
+        let (tx, rx) = mpsc::channel::<RefTick>(queue_cap);
 
         let binance_symbols = symbols.clone();
         let tx_binance = tx.clone();
         let backoff = self.reconnect_backoff;
-        tokio::spawn(async move {
-            loop {
-                if let Err(err) = run_binance_stream(&binance_symbols, &tx_binance).await {
-                    tracing::warn!(?err, "binance ws stream failed; reconnecting");
-                }
-                sleep_with_jitter(backoff).await;
-            }
-        });
-
-        let bybit_symbols = symbols.clone();
-        let tx_bybit = tx.clone();
-        tokio::spawn(async move {
-            loop {
-                if let Err(err) = run_bybit_stream(&bybit_symbols, &tx_bybit).await {
-                    tracing::warn!(?err, "bybit ws stream failed; reconnecting");
-                }
-                sleep_with_jitter(backoff).await;
-            }
-        });
-
-        let coinbase_symbols = symbols.clone();
-        let tx_coinbase = tx.clone();
-        tokio::spawn(async move {
-            loop {
-                if let Err(err) = run_coinbase_stream(&coinbase_symbols, &tx_coinbase).await {
-                    tracing::warn!(?err, "coinbase ws stream failed; reconnecting");
+        if env_flag("POLYEDGE_ENABLE_BINANCE_WS", true) {
+            tokio::spawn(async move {
+                loop {
+                    if let Err(err) = run_binance_stream(&binance_symbols, &tx_binance).await {
+                        tracing::warn!(?err, "binance ws stream failed; reconnecting");
+                    }
+                    sleep_with_jitter(backoff).await;
                 }
-                sleep_with_jitter(backoff).await;
-            }
-        });
+            });
+        }
 
-        let enable_chainlink_anchor = std::env::var("POLYEDGE_ENABLE_CHAINLINK_ANCHOR")
-            .ok()
-            .map(|v| v != "0" && !v.eq_ignore_ascii_case("false"))
-            .unwrap_or(true);
+        let enable_chainlink_anchor = env_flag("POLYEDGE_ENABLE_CHAINLINK_ANCHOR", true);
         if enable_chainlink_anchor {
             let anchor_symbols = symbols.clone();
             let tx_anchor = tx.clone();
@@ -103,6 +105,32 @@ async fn sleep_with_jitter(base: Duration) {
     tokio::time::sleep(Duration::from_millis(base_ms.saturating_add(jitter_ms))).await;
 }
 
+enum TickDispatch {
+    Sent,
+    Dropped,
+    Closed,
+}
+
+fn dispatch_ref_tick(
+    tx: &mpsc::Sender<RefTick>,
+    tick: RefTick,
+    source: &'static str,
+) -> TickDispatch {
+    static DROP_COUNTER: AtomicU64 = AtomicU64::new(0);
+
+    match tx.try_send(tick) {
+        Ok(()) => TickDispatch::Sent,
+        Err(mpsc::error::TrySendError::Full(_)) => {
+            let dropped = DROP_COUNTER.fetch_add(1, Ordering::Relaxed) + 1;
+            if dropped.is_multiple_of(1024) {
+                tracing::warn!(source, dropped, "ref tick queue full, dropping stale ticks");
+            }
+            TickDispatch::Dropped
+        }
+        Err(mpsc::error::TrySendError::Closed(_)) => TickDispatch::Closed,
+    }
+}
+
 async fn run_binance_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> Result<()> {
     if symbols.is_empty() {
         anyhow::bail!("binance symbols list is empty");
@@ -114,16 +142,17 @@ async fn run_binance_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> R
         .collect::<Vec<_>>()
         .join("/");
     let endpoint_candidates = binance_ws_endpoints(&streams);
+    let endpoint_candidates = pick_best_ws_endpoint(endpoint_candidates).await;
     let mut last_err: Option<anyhow::Error> = None;
     let mut ws = None;
 
     for endpoint in endpoint_candidates {
-        match connect_async(&endpoint).await {
-            Ok((socket, _)) => {
+        match timeout(WS_CONNECT_TIMEOUT, connect_async(&endpoint)).await {
+            Ok(Ok((socket, _))) => {
                 ws = Some(socket);
                 break;
             }
-            Err(err) => {
+            Ok(Err(err)) => {
                 tracing::warn!(
                     ?err,
                     endpoint,
@@ -131,6 +160,10 @@ async fn run_binance_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> R
                 );
                 last_err = Some(anyhow::Error::new(err));
             }
+            Err(_) => {
+                tracing::warn!(endpoint = %endpoint, "connect binance ws timeout; trying next endpoint");
+                last_err = Some(anyhow::anyhow!("connection timeout"));
+            }
         }
     }
     let mut ws = ws.ok_or_else(|| {
@@ -138,46 +171,142 @@ async fn run_binance_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> R
             .unwrap_or_else(|| anyhow::anyhow!("connect binance ws failed: no endpoint available"))
     })?;
 
-    while let Some(msg) = ws.next().await {
-        let msg = msg.context("binance ws read")?;
-        let text = match msg {
-            Message::Text(t) => t.to_string(),
-            Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
-            Message::Ping(v) => {
-                let _ = ws.send(Message::Pong(v)).await;
-                continue;
+    loop {
+        match timeout(WS_READ_TIMEOUT, ws.next()).await {
+            Ok(Some(Ok(msg))) => {
+                // Capture local receive timestamp as close as possible to socket delivery.
+                let recv_ns = now_ns();
+                let recv_ms = recv_ns / 1_000_000;
+                let text = match msg {
+                    Message::Text(t) => t.to_string(),
+                    Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
+                    Message::Ping(v) => {
+                        let _ = ws.send(Message::Pong(v)).await;
+                        continue;
+                    }
+                    Message::Pong(_) => continue,
+                    Message::Close(_) => break,
+                    Message::Frame(_) => continue,
+                };
+
+                let Ok(payload) = serde_json::from_str::<BinanceWsMessage>(&text) else {
+                    continue;
+                };
+                let trade = payload.into_trade();
+                let symbol = trade.symbol;
+                let price = trade.price;
+
+                // Validate price before creating tick
+                if !validate_price(price) {
+                    tracing::warn!(price = price, "invalid binance price, skipping");
+                    continue;
+                }
+
+                let event_ts = trade.event_ts.unwrap_or_else(now_ms);
+                let ingest_ns = now_ns();
+
+                let tick = RefTick {
+                    source: "binance_ws".into(),
+                    symbol,
+                    event_ts_ms: event_ts,
+                    recv_ts_ms: recv_ms,
+                    source_seq: event_ts.max(0) as u64,
+                    event_ts_exchange_ms: event_ts,
+                    recv_ts_local_ns: recv_ns,
+                    ingest_ts_local_ns: ingest_ns,
+                    ts_first_hop_ms: None,
+                    price,
+                };
+
+                match dispatch_ref_tick(tx, tick, "binance_ws") {
+                    TickDispatch::Sent | TickDispatch::Dropped => {}
+                    TickDispatch::Closed => break,
+                }
+            }
+            Ok(None) => break, // Stream ended
+            Ok(Some(Err(e))) => {
+                tracing::warn!(error = %e, "binance ws read error");
+                break;
+            }
+            Err(_) => {
+                tracing::warn!("binance ws read timeout, reconnecting");
+                break;
             }
-            Message::Pong(_) => continue,
-            Message::Close(_) => break,
-            Message::Frame(_) => continue,
-        };
-
-        let Ok(payload) = serde_json::from_str::<BinanceWsMessage>(&text) else {
-            continue;
-        };
-        let trade = payload.into_trade();
-        let symbol = trade.symbol;
-        let price = trade.price;
-        let event_ts = trade.event_ts.unwrap_or_else(now_ms);
-
-        let tick = RefTick {
-            source: "binance_ws".to_string(),
-            symbol,
-            event_ts_ms: event_ts,
-            recv_ts_ms: now_ms(),
-            event_ts_exchange_ms: event_ts,
-            recv_ts_local_ns: now_ns(),
-            price,
-        };
-
-        if tx.send(tick).await.is_err() {
-            break;
         }
     }
 
     Ok(())
 }
 
+async fn pick_best_ws_endpoint(endpoints: Vec<String>) -> Vec<String> {
+    if endpoints.len() <= 1 {
+        return endpoints;
+    }
+
+    // Probe all candidates concurrently at startup and prefer the fastest handshake.
+    // This matters because some Binance hosts/ports resolve to different regions and DNS can
+    // change over time; we want a deterministic "fastest-first" order.
+    let timeout = Duration::from_secs(
+        std::env::var("POLYEDGE_WS_PROBE_TIMEOUT_SEC")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(3)
+            .max(1),
+    );
+
+    let mut join_set = tokio::task::JoinSet::new();
+    for ep in endpoints.iter().cloned() {
+        join_set.spawn(async move {
+            let started = Instant::now();
+            let ok = tokio::time::timeout(timeout, connect_async(&ep)).await;
+            match ok {
+                Ok(Ok((ws, _resp))) => {
+                    drop(ws);
+                    Some((ep, started.elapsed().as_secs_f64() * 1_000.0))
+                }
+                _ => None,
+            }
+        });
+    }
+
+    let mut results: Vec<(String, f64)> = Vec::new();
+    while let Some(res) = join_set.join_next().await {
+        if let Ok(Some(v)) = res {
+            results.push(v);
+        }
+    }
+
+    if results.is_empty() {
+        return endpoints;
+    }
+
+    results.sort_by(|a, b| a.1.total_cmp(&b.1));
+    for (ep, ms) in results.iter().take(8) {
+        tracing::info!(
+            endpoint = ep.as_str(),
+            handshake_ms = *ms,
+            "ws endpoint probe result"
+        );
+    }
+    let best = results[0].0.clone();
+    tracing::info!(
+        endpoint = best.as_str(),
+        handshake_ms = results[0].1,
+        candidates = endpoints.len(),
+        "selected best ws endpoint by handshake latency"
+    );
+
+    // Return endpoints reordered: best first, then the rest in original order.
+    let mut out = Vec::with_capacity(endpoints.len());
+    out.push(best.clone());
+    for ep in endpoints {
+        if ep != best {
+            out.push(ep);
+        }
+    }
+    out
+}
+
 fn binance_ws_endpoints(streams: &str) -> Vec<String> {
     if let Ok(raw) = std::env::var("POLYEDGE_BINANCE_WS_BASES") {
         let endpoints = raw
@@ -201,177 +330,13 @@ fn binance_ws_endpoints(streams: &str) -> Vec<String> {
     }
 
     vec![
-        format!("wss://stream.binance.com/stream?streams={streams}"),
         format!("wss://stream.binance.com:9443/stream?streams={streams}"),
         format!("wss://data-stream.binance.vision/stream?streams={streams}"),
+        // Keep the default host as a fallback, but do not prefer it.
+        format!("wss://stream.binance.com/stream?streams={streams}"),
     ]
 }
 
-async fn run_bybit_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> Result<()> {
-    if symbols.is_empty() {
-        anyhow::bail!("bybit symbols list is empty");
-    }
-
-    let endpoint = "wss://stream.bybit.com/v5/public/spot";
-    let (mut ws, _) = connect_async(endpoint).await.context("connect bybit ws")?;
-
-    let args = symbols
-        .iter()
-        .map(|s| format!("tickers.{s}"))
-        .collect::<Vec<_>>();
-    let sub = serde_json::json!({
-        "op": "subscribe",
-        "args": args,
-    });
-    ws.send(Message::Text(sub.to_string().into()))
-        .await
-        .context("send bybit subscribe")?;
-
-    while let Some(msg) = ws.next().await {
-        let msg = msg.context("bybit ws read")?;
-        let text = match msg {
-            Message::Text(t) => t.to_string(),
-            Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
-            Message::Ping(v) => {
-                let _ = ws.send(Message::Pong(v)).await;
-                continue;
-            }
-            Message::Pong(_) => continue,
-            Message::Close(_) => break,
-            Message::Frame(_) => continue,
-        };
-
-        let Ok(payload) = serde_json::from_str::<BybitWsMessage>(&text) else {
-            continue;
-        };
-        if payload.success.is_some() {
-            continue;
-        }
-        let topic = payload.topic.as_deref().unwrap_or_default();
-        if !topic.starts_with("tickers.") {
-            continue;
-        }
-
-        let symbol = payload
-            .data
-            .as_ref()
-            .and_then(|d| d.symbol.clone())
-            .or_else(|| topic.split('.').nth(1).map(ToOwned::to_owned));
-        let price = payload
-            .data
-            .as_ref()
-            .and_then(|d| d.last_price.as_deref())
-            .or_else(|| payload.data.as_ref().and_then(|d| d.mark_price.as_deref()))
-            .and_then(parse_f64_str);
-        let event_ts = payload
-            .ts
-            .or_else(|| payload.data.as_ref().and_then(|d| d.ts))
-            .unwrap_or_else(now_ms);
-
-        let (Some(symbol), Some(price)) = (symbol, price) else {
-            continue;
-        };
-
-        let tick = RefTick {
-            source: "bybit_ws".to_string(),
-            symbol,
-            event_ts_ms: event_ts,
-            recv_ts_ms: now_ms(),
-            event_ts_exchange_ms: event_ts,
-            recv_ts_local_ns: now_ns(),
-            price,
-        };
-
-        if tx.send(tick).await.is_err() {
-            break;
-        }
-    }
-
-    Ok(())
-}
-
-async fn run_coinbase_stream(symbols: &[String], tx: &mpsc::Sender<RefTick>) -> Result<()> {
-    if symbols.is_empty() {
-        anyhow::bail!("coinbase symbols list is empty");
-    }
-
-    let products = symbols
-        .iter()
-        .filter_map(|s| to_coinbase_pair(s))
-        .collect::<Vec<_>>();
-    if products.is_empty() {
-        anyhow::bail!("coinbase has no supported symbols");
-    }
-
-    let endpoint = "wss://ws-feed.exchange.coinbase.com";
-    let (mut ws, _) = connect_async(endpoint)
-        .await
-        .context("connect coinbase ws")?;
-
-    let sub = serde_json::json!({
-        "type": "subscribe",
-        "product_ids": products,
-        "channels": ["ticker"],
-    });
-    ws.send(Message::Text(sub.to_string().into()))
-        .await
-        .context("send coinbase subscribe")?;
-
-    while let Some(msg) = ws.next().await {
-        let msg = msg.context("coinbase ws read")?;
-        let text = match msg {
-            Message::Text(t) => t.to_string(),
-            Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
-            Message::Ping(v) => {
-                let _ = ws.send(Message::Pong(v)).await;
-                continue;
-            }
-            Message::Pong(_) => continue,
-            Message::Close(_) => break,
-            Message::Frame(_) => continue,
-        };
-
-        let Ok(payload) = serde_json::from_str::<CoinbaseWsMessage>(&text) else {
-            continue;
-        };
-        let msg_type = payload.kind.as_deref().unwrap_or_default();
-        if msg_type != "ticker" {
-            continue;
-        }
-        let product_id = payload.product_id.as_deref().unwrap_or_default();
-        let Some(symbol) = from_coinbase_pair(product_id) else {
-            continue;
-        };
-
-        let price = payload.price.as_deref().and_then(parse_f64_str);
-        let event_ts = payload
-            .time
-            .as_deref()
-            .and_then(parse_rfc3339_ms)
-            .unwrap_or_else(now_ms);
-
-        let Some(price) = price else {
-            continue;
-        };
-
-        let tick = RefTick {
-            source: "coinbase_ws".to_string(),
-            symbol,
-            event_ts_ms: event_ts,
-            recv_ts_ms: now_ms(),
-            event_ts_exchange_ms: event_ts,
-            recv_ts_local_ns: now_ns(),
-            price,
-        };
-
-        if tx.send(tick).await.is_err() {
-            break;
-        }
-    }
-
-    Ok(())
-}
-
 #[derive(Debug, Deserialize)]
 struct RtdsEnvelope {
     #[serde(default)]
@@ -436,13 +401,15 @@ async fn run_chainlink_rtds_stream(symbols: &[String], tx: &mpsc::Sender<RefTick
                 // RTDS docs recommend sending a ping periodically.
                 let _ = ws.send(Message::Ping(Vec::new().into())).await;
             }
-            msg = ws.next() => {
-                let Some(msg) = msg else { break; };
-                let msg = msg.context("chainlink rtds read")?;
-                let text = match msg {
-                    Message::Text(t) => t.to_string(),
-                    Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
-                    Message::Ping(v) => {
+             msg = ws.next() => {
+                 let Some(msg) = msg else { break; };
+                 let msg = msg.context("chainlink rtds read")?;
+                 let recv_ns = now_ns();
+                 let recv_ms = recv_ns / 1_000_000;
+                 let text = match msg {
+                     Message::Text(t) => t.to_string(),
+                     Message::Binary(b) => String::from_utf8_lossy(&b).to_string(),
+                     Message::Ping(v) => {
                         let _ = ws.send(Message::Pong(v)).await;
                         continue;
                     }
@@ -475,19 +442,24 @@ async fn run_chainlink_rtds_stream(symbols: &[String], tx: &mpsc::Sender<RefTick
                     continue;
                 };
                 let event_ts = payload.timestamp.or(env.timestamp).unwrap_or_else(now_ms);
+                let ingest_ns = now_ns();
 
                 let tick = RefTick {
-                    source: "chainlink_rtds".to_string(),
+                    source: "chainlink_rtds".into(),
                     symbol,
                     event_ts_ms: event_ts,
-                    recv_ts_ms: now_ms(),
+                    recv_ts_ms: recv_ms,
+                    source_seq: event_ts.max(0) as u64,
                     event_ts_exchange_ms: event_ts,
-                    recv_ts_local_ns: now_ns(),
+                    recv_ts_local_ns: recv_ns,
+                    ingest_ts_local_ns: ingest_ns,
+                    ts_first_hop_ms: None,
                     price,
                 };
 
-                if tx.send(tick).await.is_err() {
-                    break;
+                match dispatch_ref_tick(tx, tick, "chainlink_rtds") {
+                    TickDispatch::Sent | TickDispatch::Dropped => {}
+                    TickDispatch::Closed => break,
                 }
             }
         }
@@ -496,16 +468,6 @@ async fn run_chainlink_rtds_stream(symbols: &[String], tx: &mpsc::Sender<RefTick
     Ok(())
 }
 
-fn parse_rfc3339_ms(value: &str) -> Option<i64> {
-    chrono::DateTime::parse_from_rfc3339(value)
-        .ok()
-        .map(|dt| dt.timestamp_millis())
-}
-
-fn parse_f64_str(value: &str) -> Option<f64> {
-    value.parse::<f64>().ok()
-}
-
 #[derive(Debug, Deserialize)]
 #[serde(untagged)]
 enum BinanceWsMessage {
@@ -532,42 +494,6 @@ struct BinanceTrade {
     event_ts: Option<i64>,
 }
 
-#[derive(Debug, Deserialize)]
-struct BybitWsMessage {
-    #[serde(default)]
-    success: Option<bool>,
-    #[serde(default)]
-    topic: Option<String>,
-    #[serde(default)]
-    ts: Option<i64>,
-    #[serde(default)]
-    data: Option<BybitTickData>,
-}
-
-#[derive(Debug, Deserialize)]
-struct BybitTickData {
-    #[serde(default)]
-    symbol: Option<String>,
-    #[serde(rename = "lastPrice", default)]
-    last_price: Option<String>,
-    #[serde(rename = "markPrice", default)]
-    mark_price: Option<String>,
-    #[serde(default)]
-    ts: Option<i64>,
-}
-
-#[derive(Debug, Deserialize)]
-struct CoinbaseWsMessage {
-    #[serde(rename = "type", default)]
-    kind: Option<String>,
-    #[serde(default)]
-    product_id: Option<String>,
-    #[serde(default)]
-    price: Option<String>,
-    #[serde(default)]
-    time: Option<String>,
-}
-
 fn de_f64_from_str<'de, D>(deserializer: D) -> Result<f64, D::Error>
 where
     D: serde::Deserializer<'de>,
@@ -586,43 +512,25 @@ where
     }
 }
 
-fn to_coinbase_pair(symbol: &str) -> Option<String> {
-    let base = symbol.strip_suffix("USDT")?;
-    Some(format!("{base}-USD"))
-}
-
-fn from_coinbase_pair(product_id: &str) -> Option<String> {
-    let base = product_id.strip_suffix("-USD")?;
-    Some(format!("{base}USDT"))
-}
-
+/// Fast timestamp using SystemTime (more efficient than chrono::Utc::now())
 fn now_ms() -> i64 {
-    chrono::Utc::now().timestamp_millis()
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .map(|d| d.as_millis() as i64)
+        .unwrap_or(0)
 }
 
 fn now_ns() -> i64 {
-    chrono::Utc::now()
-        .timestamp_nanos_opt()
-        .unwrap_or_else(|| now_ms() * 1_000_000)
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .map(|d| d.as_nanos() as i64)
+        .unwrap_or_else(|_| now_ms() * 1_000_000)
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
-    #[test]
-    fn coinbase_pair_conversion() {
-        assert_eq!(to_coinbase_pair("BTCUSDT").as_deref(), Some("BTC-USD"));
-        assert_eq!(to_coinbase_pair("FOO"), None);
-        assert_eq!(from_coinbase_pair("ETH-USD").as_deref(), Some("ETHUSDT"));
-    }
-
-    #[test]
-    fn parse_time_works() {
-        let ts = parse_rfc3339_ms("2026-02-13T12:34:56.789Z").expect("parse");
-        assert!(ts > 0);
-    }
-
     #[test]
     fn chainlink_symbol_conversion() {
         assert_eq!(
diff --git a/crates/feed_udp/Cargo.toml b/crates/feed_udp/Cargo.toml
new file mode 100644
index 0000000..ff008ac
--- /dev/null
+++ b/crates/feed_udp/Cargo.toml
@@ -0,0 +1,13 @@
+[package]
+name = "feed_udp"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+tokio = { workspace = true, features = ["full"] }
+tokio-stream = { workspace = true }
+anyhow = { workspace = true }
+async-trait = { workspace = true }
+poly_wire = { path = "../poly_wire" }
+core_types = { path = "../core_types" }
+libc = "0.2"
diff --git a/crates/feed_udp/src/lib.rs b/crates/feed_udp/src/lib.rs
new file mode 100644
index 0000000..acd77bb
--- /dev/null
+++ b/crates/feed_udp/src/lib.rs
@@ -0,0 +1,525 @@
+use anyhow::{Context, Result};
+use async_trait::async_trait;
+use core_types::{DynStream, RefPriceFeed, RefTick};
+use poly_wire::{
+    decode_auto, WirePacket, WIRE_BOOK_TOP24_SIZE, WIRE_MAX_PACKET_SIZE, WIRE_MOMENTUM_TICK32_SIZE,
+};
+use std::collections::{HashMap, HashSet};
+use std::net::{IpAddr, SocketAddr, UdpSocket as StdUdpSocket};
+#[cfg(target_os = "linux")]
+use std::os::fd::AsRawFd;
+use std::sync::atomic::{AtomicU64, Ordering};
+use std::time::{Duration, Instant};
+use tokio::sync::mpsc;
+use tokio_stream::wrappers::ReceiverStream;
+
+pub struct UdpBinanceFeed {
+    port: u16,
+}
+
+static UDP_LOCAL_DROP_COUNT: AtomicU64 = AtomicU64::new(0);
+
+pub fn udp_local_drop_count() -> u64 {
+    UDP_LOCAL_DROP_COUNT.load(Ordering::Relaxed)
+}
+
+#[derive(Debug, Clone)]
+struct UdpLocalPolicy {
+    local_only: bool,
+    allow_private: bool,
+    allowlist: HashSet<IpAddr>,
+}
+
+impl UdpLocalPolicy {
+    fn from_env() -> Self {
+        let local_only = std::env::var("POLYEDGE_UDP_LOCAL_ONLY")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(true);
+        let allow_private = std::env::var("POLYEDGE_UDP_LOCAL_ALLOW_PRIVATE")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(false);
+        let allowlist =
+            parse_ip_allowlist(&std::env::var("POLYEDGE_UDP_LOCAL_ALLOW").unwrap_or_default());
+        Self {
+            local_only,
+            allow_private,
+            allowlist,
+        }
+    }
+
+    fn allows(&self, addr: &SocketAddr) -> bool {
+        if !self.local_only {
+            return true;
+        }
+        let ip = addr.ip();
+        if ip.is_loopback() {
+            return true;
+        }
+        if self.allow_private && is_private_ip(&ip) {
+            return true;
+        }
+        self.allowlist.contains(&ip)
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+#[cfg_attr(not(target_os = "linux"), allow(dead_code))]
+struct UdpRecvTuning {
+    rcvbuf_bytes: Option<usize>,
+    busy_poll_us: Option<u32>,
+    user_spin: bool,
+    drop_on_full: bool,
+}
+
+impl UdpRecvTuning {
+    fn from_env() -> Self {
+        let rcvbuf_bytes = std::env::var("POLYEDGE_UDP_RCVBUF_BYTES")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .filter(|v| *v > 0);
+        let busy_poll_us = std::env::var("POLYEDGE_UDP_BUSY_POLL_US")
+            .ok()
+            .and_then(|v| v.parse::<u32>().ok())
+            .filter(|v| *v > 0);
+        let user_spin = std::env::var("POLYEDGE_UDP_USER_SPIN")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(false);
+        let drop_on_full = std::env::var("POLYEDGE_UDP_DROP_ON_FULL")
+            .ok()
+            .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+            .unwrap_or(true);
+        Self {
+            rcvbuf_bytes,
+            busy_poll_us,
+            user_spin,
+            drop_on_full,
+        }
+    }
+}
+
+impl UdpBinanceFeed {
+    pub fn new(port: u16) -> Self {
+        Self { port }
+    }
+}
+
+#[async_trait]
+impl RefPriceFeed for UdpBinanceFeed {
+    async fn stream_ticks(&self, symbols: Vec<String>) -> Result<DynStream<RefTick>> {
+        let rx_queue_cap = std::env::var("POLYEDGE_UDP_RX_QUEUE_CAP")
+            .ok()
+            .and_then(|v| v.parse::<usize>().ok())
+            .unwrap_or(4_096)
+            .clamp(512, 65_536);
+        let (tx, rx) = mpsc::channel::<Result<RefTick>>(rx_queue_cap);
+        let normalized_symbols = normalize_symbols(&symbols);
+        let bindings = udp_bindings(self.port, &normalized_symbols);
+        let tuning = UdpRecvTuning::from_env();
+        let core_map =
+            parse_port_core_map(&std::env::var("POLYEDGE_UDP_PIN_CORES").unwrap_or_default());
+
+        if bindings.is_empty() {
+            let symbol = normalized_symbols
+                .first()
+                .cloned()
+                .unwrap_or_else(|| "BTCUSDT".to_string());
+            let addr: SocketAddr = format!("0.0.0.0:{}", self.port)
+                .parse()
+                .context("parse udp bind addr")?;
+            let socket = StdUdpSocket::bind(addr).context("bind udp feed socket")?;
+            let core_id = core_map.get(&self.port).copied();
+            spawn_recv_loop(socket, symbol, tx.clone(), tuning, core_id)?;
+        } else {
+            for (symbol, port) in bindings {
+                let addr: SocketAddr = format!("0.0.0.0:{port}")
+                    .parse()
+                    .context("parse udp bind addr")?;
+                let socket = StdUdpSocket::bind(addr).with_context(|| {
+                    format!("bind udp feed socket for symbol={symbol} port={port}")
+                })?;
+                let core_id = core_map.get(&port).copied();
+                spawn_recv_loop(socket, symbol, tx.clone(), tuning, core_id)?;
+            }
+        }
+        drop(tx);
+
+        Ok(Box::pin(ReceiverStream::new(rx)))
+    }
+}
+
+fn spawn_recv_loop(
+    socket: StdUdpSocket,
+    symbol: String,
+    tx: mpsc::Sender<Result<RefTick>>,
+    tuning: UdpRecvTuning,
+    core_id: Option<usize>,
+) -> Result<()> {
+    socket
+        .set_nonblocking(tuning.user_spin)
+        .context("configure udp nonblocking")?;
+    apply_udp_recv_socket_tuning(&socket, tuning)?;
+
+    std::thread::Builder::new()
+        .name(format!("udp-recv-{symbol}"))
+        .spawn(move || {
+            if let Some(core) = core_id {
+                if let Err(err) = pin_current_thread(core) {
+                    let _ = tx.blocking_send(Err(err));
+                }
+            }
+
+            let mut buf = [0u8; WIRE_MAX_PACKET_SIZE];
+            let mut local_policy = UdpLocalPolicy::from_env();
+            let mut local_policy_refresh_at = Instant::now();
+            loop {
+                let recv = socket.recv_from(&mut buf);
+                let (amt, src) = match recv {
+                    Ok(v) => v,
+                    Err(err)
+                        if tuning.user_spin && err.kind() == std::io::ErrorKind::WouldBlock =>
+                    {
+                        std::hint::spin_loop();
+                        continue;
+                    }
+                    Err(err) => {
+                        let send_err = if tuning.drop_on_full {
+                            match tx.try_send(Err(err.into())) {
+                                Ok(_) | Err(mpsc::error::TrySendError::Full(_)) => false,
+                                Err(mpsc::error::TrySendError::Closed(_)) => true,
+                            }
+                        } else {
+                            tx.blocking_send(Err(err.into())).is_err()
+                        };
+                        if send_err {
+                            break;
+                        }
+                        continue;
+                    }
+                };
+                if local_policy_refresh_at.elapsed() >= Duration::from_secs(1) {
+                    local_policy = UdpLocalPolicy::from_env();
+                    local_policy_refresh_at = Instant::now();
+                }
+                if !local_policy.allows(&src) {
+                    UDP_LOCAL_DROP_COUNT.fetch_add(1, Ordering::Relaxed);
+                    continue;
+                }
+                if amt != WIRE_BOOK_TOP24_SIZE
+                    && amt != WIRE_MOMENTUM_TICK32_SIZE
+                    && amt != poly_wire::WIRE_RELAY_TICK40_SIZE
+                {
+                    continue;
+                }
+
+                let recv_ns = now_ns();
+                let (ts_micros, bid, ask, ts_first_hop_ms) = match decode_auto(&buf[..amt]) {
+                    Ok(WirePacket::BookTop24(pkt)) => (pkt.ts_micros, pkt.bid, pkt.ask, None),
+                    Ok(WirePacket::MomentumTick32(pkt)) => (pkt.ts_micros, pkt.bid, pkt.ask, None),
+                    Ok(WirePacket::RelayTick40(pkt)) => {
+                        (pkt.ts_micros, pkt.bid, pkt.ask, Some(pkt.ts_first_hop_ms))
+                    }
+                    Err(err) => {
+                        let send_err = if tuning.drop_on_full {
+                            match tx.try_send(Err(err.into())) {
+                                Ok(_) | Err(mpsc::error::TrySendError::Full(_)) => false,
+                                Err(mpsc::error::TrySendError::Closed(_)) => true,
+                            }
+                        } else {
+                            tx.blocking_send(Err(err.into())).is_err()
+                        };
+                        if send_err {
+                            break;
+                        }
+                        continue;
+                    }
+                };
+
+                let event_ms = (ts_micros / 1_000) as i64;
+                let mid = (bid + ask) * 0.5;
+                if !mid.is_finite() || mid <= 0.0 {
+                    continue;
+                }
+
+                let tick = RefTick {
+                    source: "binance_udp".into(),
+                    symbol: symbol.clone(),
+                    event_ts_ms: event_ms,
+                    recv_ts_ms: recv_ns / 1_000_000,
+                    source_seq: stable_udp_seq(ts_micros, bid, ask),
+                    event_ts_exchange_ms: event_ms,
+                    recv_ts_local_ns: recv_ns,
+                    ingest_ts_local_ns: recv_ns,
+                    ts_first_hop_ms,
+                    price: mid,
+                };
+
+                let send_err = if tuning.drop_on_full {
+                    match tx.try_send(Ok(tick)) {
+                        Ok(_) | Err(mpsc::error::TrySendError::Full(_)) => false,
+                        Err(mpsc::error::TrySendError::Closed(_)) => true,
+                    }
+                } else {
+                    tx.blocking_send(Ok(tick)).is_err()
+                };
+                if send_err {
+                    break;
+                }
+            }
+        })
+        .context("spawn udp receiver thread")?;
+
+    Ok(())
+}
+
+#[cfg(target_os = "linux")]
+fn apply_udp_recv_socket_tuning(socket: &StdUdpSocket, tuning: UdpRecvTuning) -> Result<()> {
+    if let Some(bytes) = tuning.rcvbuf_bytes {
+        let value: libc::c_int = bytes.try_into().unwrap_or(libc::c_int::MAX);
+        let rc = unsafe {
+            libc::setsockopt(
+                socket.as_raw_fd(),
+                libc::SOL_SOCKET,
+                libc::SO_RCVBUF,
+                (&value as *const libc::c_int).cast(),
+                std::mem::size_of::<libc::c_int>() as libc::socklen_t,
+            )
+        };
+        if rc != 0 {
+            let err = std::io::Error::last_os_error();
+            anyhow::bail!("set SO_RCVBUF={} failed: {}", bytes, err);
+        }
+    }
+    if let Some(us) = tuning.busy_poll_us {
+        let value: libc::c_int = us.try_into().unwrap_or(libc::c_int::MAX);
+        let rc = unsafe {
+            libc::setsockopt(
+                socket.as_raw_fd(),
+                libc::SOL_SOCKET,
+                libc::SO_BUSY_POLL,
+                (&value as *const libc::c_int).cast(),
+                std::mem::size_of::<libc::c_int>() as libc::socklen_t,
+            )
+        };
+        if rc != 0 {
+            let err = std::io::Error::last_os_error();
+            anyhow::bail!("set SO_BUSY_POLL={} failed: {}", us, err);
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn apply_udp_recv_socket_tuning(_socket: &StdUdpSocket, _tuning: UdpRecvTuning) -> Result<()> {
+    Ok(())
+}
+
+#[cfg(target_os = "linux")]
+fn pin_current_thread(core_id: usize) -> Result<()> {
+    let mut cpuset: libc::cpu_set_t = unsafe { std::mem::zeroed() };
+    unsafe {
+        libc::CPU_ZERO(&mut cpuset);
+        libc::CPU_SET(core_id, &mut cpuset);
+        let rc = libc::pthread_setaffinity_np(
+            libc::pthread_self(),
+            std::mem::size_of::<libc::cpu_set_t>(),
+            &cpuset,
+        );
+        if rc != 0 {
+            let err = std::io::Error::from_raw_os_error(rc);
+            anyhow::bail!("pthread_setaffinity_np(core={core_id}) failed: {err}");
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn pin_current_thread(_core_id: usize) -> Result<()> {
+    Ok(())
+}
+
+fn normalize_symbols(symbols: &[String]) -> Vec<String> {
+    let mut out: Vec<String> = symbols
+        .iter()
+        .map(|s| s.trim().to_ascii_uppercase())
+        .filter(|s| !s.is_empty())
+        .collect();
+    if out.is_empty() {
+        out.push("BTCUSDT".to_string());
+    }
+    out
+}
+
+fn udp_bindings(default_port: u16, symbols: &[String]) -> Vec<(String, u16)> {
+    let raw = std::env::var("POLYEDGE_UDP_SYMBOL_PORTS").unwrap_or_default();
+    udp_bindings_from_raw(default_port, symbols, &raw)
+}
+
+fn udp_bindings_from_raw(default_port: u16, symbols: &[String], raw: &str) -> Vec<(String, u16)> {
+    let map = parse_symbol_port_map(raw);
+    if map.is_empty() {
+        if symbols.len() <= 1 {
+            return vec![];
+        }
+        return symbols
+            .iter()
+            .enumerate()
+            .filter_map(|(idx, symbol)| {
+                let delta = u16::try_from(idx).ok()?;
+                let port = default_port.checked_add(delta)?;
+                Some((symbol.clone(), port))
+            })
+            .collect();
+    }
+    let mut out = Vec::<(String, u16)>::new();
+    for symbol in symbols {
+        if let Some(port) = map.get(symbol).copied() {
+            out.push((symbol.clone(), port));
+        }
+    }
+    if out.is_empty() && symbols.len() == 1 {
+        out.push((symbols[0].clone(), default_port));
+    }
+    out
+}
+
+fn parse_symbol_port_map(raw: &str) -> HashMap<String, u16> {
+    let mut out = HashMap::<String, u16>::new();
+    for item in raw.split(',') {
+        let token = item.trim();
+        if token.is_empty() {
+            continue;
+        }
+        let mut parts = token.split(':');
+        let symbol = parts.next().unwrap_or_default().trim().to_ascii_uppercase();
+        let port = parts.next().unwrap_or_default().trim();
+        if symbol.is_empty() || port.is_empty() || parts.next().is_some() {
+            continue;
+        }
+        if let Ok(parsed_port) = port.parse::<u16>() {
+            out.insert(symbol, parsed_port);
+        }
+    }
+    out
+}
+
+fn parse_port_core_map(raw: &str) -> HashMap<u16, usize> {
+    let mut out = HashMap::<u16, usize>::new();
+    for item in raw.split(',') {
+        let token = item.trim();
+        if token.is_empty() {
+            continue;
+        }
+        let mut pair = token.split(':');
+        let port = pair.next().unwrap_or_default().trim();
+        let core = pair.next().unwrap_or_default().trim();
+        if port.is_empty() || core.is_empty() || pair.next().is_some() {
+            continue;
+        }
+        if let (Ok(port_id), Ok(core_id)) = (port.parse::<u16>(), core.parse::<usize>()) {
+            out.insert(port_id, core_id);
+        }
+    }
+    out
+}
+
+fn parse_ip_allowlist(raw: &str) -> HashSet<IpAddr> {
+    let mut out = HashSet::new();
+    for token in raw.split(',') {
+        let candidate = token.trim();
+        if candidate.is_empty() {
+            continue;
+        }
+        if let Ok(ip) = candidate.parse::<IpAddr>() {
+            out.insert(ip);
+        }
+    }
+    out
+}
+
+fn is_private_ip(ip: &IpAddr) -> bool {
+    match ip {
+        IpAddr::V4(v4) => v4.is_private() || v4.is_link_local(),
+        IpAddr::V6(v6) => v6.is_unique_local() || v6.is_unicast_link_local(),
+    }
+}
+
+#[inline]
+fn now_ns() -> i64 {
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_nanos() as i64
+}
+
+#[inline]
+fn stable_udp_seq(ts_micros: u64, bid: f64, ask: f64) -> u64 {
+    let mut h = ts_micros
+        ^ bid.to_bits().rotate_left(13)
+        ^ ask.to_bits().rotate_right(7)
+        ^ 0x9E37_79B9_7F4A_7C15;
+    if h == 0 {
+        h = 1;
+    }
+    h
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn stable_udp_seq_is_non_zero() {
+        assert_ne!(stable_udp_seq(0, 1.0, 1.0), 0);
+    }
+
+    #[test]
+    fn parse_symbol_port_map_accepts_valid_pairs() {
+        let map = parse_symbol_port_map("BTCUSDT:6666,ETHUSDT:6667");
+        assert_eq!(map.get("BTCUSDT"), Some(&6666));
+        assert_eq!(map.get("ETHUSDT"), Some(&6667));
+    }
+
+    #[test]
+    fn parse_symbol_port_map_ignores_invalid_tokens() {
+        let map = parse_symbol_port_map("BTCUSDT:6666,bad,ETHUSDT:notaport, :7777");
+        assert_eq!(map.get("BTCUSDT"), Some(&6666));
+        assert_eq!(map.len(), 1);
+    }
+
+    #[test]
+    fn udp_bindings_defaults_to_sequential_ports_for_multi_symbol() {
+        let symbols = vec![
+            "BTCUSDT".to_string(),
+            "ETHUSDT".to_string(),
+            "SOLUSDT".to_string(),
+        ];
+        let bindings = udp_bindings_from_raw(6666, &symbols, "");
+        assert_eq!(
+            bindings,
+            vec![
+                ("BTCUSDT".to_string(), 6666),
+                ("ETHUSDT".to_string(), 6667),
+                ("SOLUSDT".to_string(), 6668),
+            ]
+        );
+    }
+
+    #[test]
+    fn parse_port_core_map_accepts_pairs() {
+        let map = parse_port_core_map("6666:2,6667:3");
+        assert_eq!(map.get(&6666), Some(&2usize));
+        assert_eq!(map.get(&6667), Some(&3usize));
+    }
+
+    #[test]
+    fn parse_ip_allowlist_accepts_valid_ips() {
+        let allowlist = parse_ip_allowlist("127.0.0.1,10.0.0.2,::1,bad");
+        assert!(allowlist.contains(&"127.0.0.1".parse::<IpAddr>().unwrap()));
+        assert!(allowlist.contains(&"10.0.0.2".parse::<IpAddr>().unwrap()));
+        assert!(allowlist.contains(&"::1".parse::<IpAddr>().unwrap()));
+        assert_eq!(allowlist.len(), 3);
+    }
+}
diff --git a/crates/feeder_tokyo/Cargo.toml b/crates/feeder_tokyo/Cargo.toml
new file mode 100644
index 0000000..c497ecc
--- /dev/null
+++ b/crates/feeder_tokyo/Cargo.toml
@@ -0,0 +1,13 @@
+[package]
+name = "feeder_tokyo"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+tokio = { workspace = true, features = ["full"] }
+tokio-tungstenite = { workspace = true }
+futures = { workspace = true }
+anyhow = { workspace = true }
+poly_wire = { path = "../poly_wire" }
+rustls = { workspace = true }
+libc = "0.2"
diff --git a/crates/feeder_tokyo/src/bin/receiver.rs b/crates/feeder_tokyo/src/bin/receiver.rs
new file mode 100644
index 0000000..d6b4971
--- /dev/null
+++ b/crates/feeder_tokyo/src/bin/receiver.rs
@@ -0,0 +1,173 @@
+use anyhow::{Context, Result};
+use poly_wire::{
+    decode_auto, now_micros, WirePacket, WIRE_BOOK_TOP24_SIZE, WIRE_MAX_PACKET_SIZE,
+    WIRE_MOMENTUM_TICK32_SIZE, WIRE_RELAY_TICK40_SIZE,
+};
+use std::net::UdpSocket;
+#[cfg(target_os = "linux")]
+use std::os::fd::AsRawFd;
+
+fn main() -> Result<()> {
+    let bind_addr = std::env::var("BIND_ADDR").unwrap_or_else(|_| "0.0.0.0:6666".to_string());
+    let print_every = std::env::var("PRINT_EVERY")
+        .ok()
+        .and_then(|v| v.parse::<u64>().ok())
+        .filter(|v| *v > 0)
+        .unwrap_or(1);
+    let pin_core = std::env::var("PIN_CORE")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok());
+    let busy_poll_us = std::env::var("BUSY_POLL_US")
+        .ok()
+        .and_then(|v| v.parse::<u32>().ok())
+        .filter(|v| *v > 0);
+    let rcvbuf_bytes = std::env::var("RCVBUF_BYTES")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok())
+        .filter(|v| *v > 0);
+
+    if let Some(core_id) = pin_core {
+        pin_current_thread(core_id)?;
+    }
+
+    let socket = UdpSocket::bind(&bind_addr)
+        .with_context(|| format!("bind receiver UDP socket at {bind_addr}"))?;
+    apply_udp_socket_tuning(&socket, rcvbuf_bytes, busy_poll_us)?;
+    socket
+        .set_nonblocking(true)
+        .context("set receiver UDP socket nonblocking")?;
+
+    eprintln!(
+        "receiver: listening={} packet_sizes=[{},{},{}] print_every={} (busy-spin mode)",
+        bind_addr,
+        WIRE_BOOK_TOP24_SIZE,
+        WIRE_MOMENTUM_TICK32_SIZE,
+        WIRE_RELAY_TICK40_SIZE,
+        print_every
+    );
+
+    let mut buf = [0u8; WIRE_MAX_PACKET_SIZE];
+    let mut last_packet_ts: u64 = 0;
+    let mut recv_ok: u64 = 0;
+    let mut dropped_out_of_order: u64 = 0;
+    let mut dropped_size: u64 = 0;
+
+    loop {
+        match socket.recv_from(&mut buf) {
+            Ok((amt, _src)) => {
+                if amt != WIRE_BOOK_TOP24_SIZE
+                    && amt != WIRE_MOMENTUM_TICK32_SIZE
+                    && amt != WIRE_RELAY_TICK40_SIZE
+                {
+                    dropped_size = dropped_size.saturating_add(1);
+                    continue;
+                }
+
+                let (ts_micros, bid, ask) = match decode_auto(&buf[..amt]) {
+                    Ok(WirePacket::BookTop24(pkt)) => (pkt.ts_micros, pkt.bid, pkt.ask),
+                    Ok(WirePacket::MomentumTick32(pkt)) => (pkt.ts_micros, pkt.bid, pkt.ask),
+                    Ok(WirePacket::RelayTick40(pkt)) => (pkt.ts_micros, pkt.bid, pkt.ask),
+                    Err(_) => continue,
+                };
+
+                if ts_micros < last_packet_ts {
+                    dropped_out_of_order = dropped_out_of_order.saturating_add(1);
+                    continue;
+                }
+                last_packet_ts = ts_micros;
+
+                recv_ok = recv_ok.saturating_add(1);
+                if recv_ok.is_multiple_of(print_every) {
+                    let now = now_micros();
+                    let latency_us = now.saturating_sub(ts_micros);
+                    println!(
+                        "latency_us={} bid={:.8} ask={:.8} recv_ok={} drop_ooo={} drop_size={}",
+                        latency_us, bid, ask, recv_ok, dropped_out_of_order, dropped_size
+                    );
+                }
+            }
+            Err(err) if err.kind() == std::io::ErrorKind::WouldBlock => {
+                // Busy-wait for lowest wakeup latency.
+                std::hint::spin_loop();
+            }
+            Err(err) => return Err(err).context("udp recv_from failed"),
+        }
+    }
+}
+
+#[cfg(target_os = "linux")]
+fn apply_udp_socket_tuning(
+    socket: &UdpSocket,
+    rcvbuf_bytes: Option<usize>,
+    busy_poll_us: Option<u32>,
+) -> Result<()> {
+    if let Some(bytes) = rcvbuf_bytes {
+        let value: libc::c_int = bytes.try_into().unwrap_or(libc::c_int::MAX);
+        let rc = unsafe {
+            libc::setsockopt(
+                socket.as_raw_fd(),
+                libc::SOL_SOCKET,
+                libc::SO_RCVBUF,
+                (&value as *const libc::c_int).cast(),
+                std::mem::size_of::<libc::c_int>() as libc::socklen_t,
+            )
+        };
+        if rc != 0 {
+            anyhow::bail!("set SO_RCVBUF failed: {}", std::io::Error::last_os_error());
+        }
+    }
+    if let Some(us) = busy_poll_us {
+        let value: libc::c_int = us.try_into().unwrap_or(libc::c_int::MAX);
+        let rc = unsafe {
+            libc::setsockopt(
+                socket.as_raw_fd(),
+                libc::SOL_SOCKET,
+                libc::SO_BUSY_POLL,
+                (&value as *const libc::c_int).cast(),
+                std::mem::size_of::<libc::c_int>() as libc::socklen_t,
+            )
+        };
+        if rc != 0 {
+            anyhow::bail!(
+                "set SO_BUSY_POLL failed: {}",
+                std::io::Error::last_os_error()
+            );
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn apply_udp_socket_tuning(
+    _socket: &UdpSocket,
+    _rcvbuf_bytes: Option<usize>,
+    _busy_poll_us: Option<u32>,
+) -> Result<()> {
+    Ok(())
+}
+
+#[cfg(target_os = "linux")]
+fn pin_current_thread(core_id: usize) -> Result<()> {
+    let mut cpuset: libc::cpu_set_t = unsafe { std::mem::zeroed() };
+    unsafe {
+        libc::CPU_ZERO(&mut cpuset);
+        libc::CPU_SET(core_id, &mut cpuset);
+        let rc = libc::pthread_setaffinity_np(
+            libc::pthread_self(),
+            std::mem::size_of::<libc::cpu_set_t>(),
+            &cpuset,
+        );
+        if rc != 0 {
+            anyhow::bail!(
+                "pthread_setaffinity_np(core={core_id}) failed: {}",
+                std::io::Error::from_raw_os_error(rc)
+            );
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn pin_current_thread(_core_id: usize) -> Result<()> {
+    Ok(())
+}
diff --git a/crates/feeder_tokyo/src/bin/sender.rs b/crates/feeder_tokyo/src/bin/sender.rs
new file mode 100644
index 0000000..6a4c30d
--- /dev/null
+++ b/crates/feeder_tokyo/src/bin/sender.rs
@@ -0,0 +1,681 @@
+use anyhow::{Context, Result};
+use futures::StreamExt;
+use poly_wire::{encode_with_mode, now_micros, WireBookTop24, WireMode, WIRE_MAX_PACKET_SIZE};
+use std::collections::HashMap;
+use std::net::{SocketAddr, UdpSocket};
+#[cfg(target_os = "linux")]
+use std::os::fd::AsRawFd;
+use std::time::{Duration, Instant};
+use tokio::time::timeout;
+use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
+
+const KEY_BID: &[u8] = br#""b":""#;
+const KEY_ASK: &[u8] = br#""a":""#;
+const KEY_EVENT_MS: &[u8] = br#""E":"#;
+
+#[derive(Debug, Clone)]
+struct Route {
+    symbol: String,
+    bind_addr: String,
+    target: String,
+    core_id: Option<usize>,
+}
+
+#[derive(Debug, Clone, Copy)]
+struct SenderTuning {
+    redundancy: u8,
+    sndbuf_bytes: Option<usize>,
+    adaptive_redundancy: bool,
+    adaptive_redundancy_high: u8,
+    adaptive_err_threshold_per_sec: u64,
+    adaptive_cooldown_sec: u64,
+}
+
+fn main() -> Result<()> {
+    let _ = rustls::crypto::ring::default_provider().install_default();
+    let mut routes = resolve_routes();
+    if routes.is_empty() {
+        anyhow::bail!("no sender routes configured");
+    }
+    assign_route_cores(&mut routes);
+    let tuning = load_sender_tuning();
+    eprintln!("sender: routes={routes:?} tuning={tuning:?}");
+
+    let mut handles = Vec::with_capacity(routes.len());
+    for route in routes {
+        let tuning_local = tuning;
+        let name = format!("sender-{}", route.symbol);
+        let handle = std::thread::Builder::new()
+            .name(name.clone())
+            .spawn(move || {
+                if let Some(core_id) = route.core_id {
+                    if let Err(err) = pin_current_thread(core_id) {
+                        eprintln!(
+                            "sender: symbol={} failed to pin thread to core {}: {}",
+                            route.symbol, core_id, err
+                        );
+                    } else {
+                        eprintln!("sender: symbol={} pinned to core {}", route.symbol, core_id);
+                    }
+                }
+
+                let rt = match tokio::runtime::Builder::new_current_thread()
+                    .enable_all()
+                    .build()
+                {
+                    Ok(v) => v,
+                    Err(err) => {
+                        eprintln!(
+                            "sender: symbol={} runtime build failed: {}",
+                            route.symbol, err
+                        );
+                        return;
+                    }
+                };
+
+                rt.block_on(async move {
+                    loop {
+                        if let Err(err) = run_route(&route, tuning_local).await {
+                            eprintln!(
+                                "sender: route symbol={} target={} failed: {}",
+                                route.symbol, route.target, err
+                            );
+                        }
+                        tokio::time::sleep(Duration::from_millis(300)).await;
+                    }
+                });
+            })
+            .with_context(|| format!("spawn thread {name}"))?;
+        handles.push(handle);
+    }
+
+    for h in handles {
+        if let Err(err) = h.join() {
+            eprintln!("sender: worker thread panic: {:?}", err);
+        }
+    }
+    Ok(())
+}
+
+fn load_sender_tuning() -> SenderTuning {
+    let redundancy = std::env::var("POLYEDGE_UDP_REDUNDANCY")
+        .ok()
+        .and_then(|v| v.parse::<u8>().ok())
+        .filter(|v| *v > 0)
+        .unwrap_or(1)
+        .min(8);
+    let sndbuf_bytes = std::env::var("POLYEDGE_UDP_SNDBUF_BYTES")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok())
+        .filter(|v| *v > 0);
+    let adaptive_redundancy = std::env::var("POLYEDGE_UDP_REDUNDANCY_ADAPTIVE")
+        .ok()
+        .map(|v| matches!(v.as_str(), "1" | "true" | "TRUE" | "True"))
+        .unwrap_or(false);
+    let adaptive_redundancy_high = std::env::var("POLYEDGE_UDP_REDUNDANCY_ADAPTIVE_HIGH")
+        .ok()
+        .and_then(|v| v.parse::<u8>().ok())
+        .filter(|v| *v > 0)
+        .unwrap_or(2)
+        .min(8);
+    let adaptive_err_threshold_per_sec =
+        std::env::var("POLYEDGE_UDP_REDUNDANCY_ERR_THRESHOLD_PER_SEC")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(2)
+            .max(1);
+    let adaptive_cooldown_sec = std::env::var("POLYEDGE_UDP_REDUNDANCY_COOLDOWN_SEC")
+        .ok()
+        .and_then(|v| v.parse::<u64>().ok())
+        .unwrap_or(10)
+        .max(1);
+    SenderTuning {
+        redundancy,
+        sndbuf_bytes,
+        adaptive_redundancy,
+        adaptive_redundancy_high,
+        adaptive_err_threshold_per_sec,
+        adaptive_cooldown_sec,
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+struct RedundancyController {
+    base: u8,
+    high: u8,
+    enabled: bool,
+    err_threshold_per_sec: u64,
+    cooldown_sec: u64,
+    current: u8,
+    last_error_window: std::time::Instant,
+    last_error_total: u64,
+    last_error_event: std::time::Instant,
+}
+
+#[derive(Debug, Default, Clone, Copy)]
+struct VelocityEstimator {
+    prev_ts_micros: u64,
+    prev_mid: f64,
+}
+
+impl VelocityEstimator {
+    fn velocity_bps_per_sec(&mut self, packet: &WireBookTop24) -> f64 {
+        let mid = (packet.bid + packet.ask) * 0.5;
+        if !mid.is_finite() || mid <= 0.0 {
+            return 0.0;
+        }
+        if self.prev_ts_micros == 0 || self.prev_mid <= 0.0 || !self.prev_mid.is_finite() {
+            self.prev_ts_micros = packet.ts_micros;
+            self.prev_mid = mid;
+            return 0.0;
+        }
+
+        let dt_micros = packet.ts_micros.saturating_sub(self.prev_ts_micros);
+        if dt_micros == 0 {
+            return 0.0;
+        }
+        let dt_sec = dt_micros as f64 / 1_000_000.0;
+        if dt_sec <= 0.0 {
+            return 0.0;
+        }
+        let ret = (mid - self.prev_mid) / self.prev_mid;
+        let velocity = (ret * 10_000.0) / dt_sec;
+
+        self.prev_ts_micros = packet.ts_micros;
+        self.prev_mid = mid;
+
+        if velocity.is_finite() {
+            velocity
+        } else {
+            0.0
+        }
+    }
+}
+
+impl RedundancyController {
+    fn new(tuning: SenderTuning) -> Self {
+        let base = tuning.redundancy.max(1);
+        let high = tuning.adaptive_redundancy_high.max(base);
+        let now = std::time::Instant::now();
+        Self {
+            base,
+            high,
+            enabled: tuning.adaptive_redundancy,
+            err_threshold_per_sec: tuning.adaptive_err_threshold_per_sec.max(1),
+            cooldown_sec: tuning.adaptive_cooldown_sec.max(1),
+            current: base,
+            last_error_window: now,
+            last_error_total: 0,
+            last_error_event: now,
+        }
+    }
+
+    fn current(&self) -> u8 {
+        self.current
+    }
+
+    fn on_progress(&mut self, total_errors: u64) {
+        if !self.enabled {
+            self.current = self.base;
+            return;
+        }
+        let now = std::time::Instant::now();
+        let elapsed = now.saturating_duration_since(self.last_error_window);
+        if elapsed >= Duration::from_secs(1) {
+            let err_delta = total_errors.saturating_sub(self.last_error_total);
+            if err_delta >= self.err_threshold_per_sec {
+                self.current = self.high;
+                self.last_error_event = now;
+            } else if self.current > self.base
+                && now.saturating_duration_since(self.last_error_event)
+                    >= Duration::from_secs(self.cooldown_sec)
+            {
+                self.current = self.current.saturating_sub(1).max(self.base);
+            }
+            self.last_error_total = total_errors;
+            self.last_error_window = now;
+        }
+    }
+}
+
+fn resolve_routes() -> Vec<Route> {
+    let from_targets = parse_symbol_targets(
+        &std::env::var("SYMBOL_TARGETS").unwrap_or_default(),
+        &std::env::var("BIND_BASE_PORT").unwrap_or_else(|_| "9999".to_string()),
+    );
+    if !from_targets.is_empty() {
+        return from_targets
+            .into_iter()
+            .map(|(symbol, bind_addr, target)| Route {
+                symbol,
+                bind_addr,
+                target,
+                core_id: None,
+            })
+            .collect();
+    }
+    let symbol = std::env::var("SYMBOL").unwrap_or_else(|_| "btcusdt".to_string());
+    let bind_addr = std::env::var("BIND_ADDR").unwrap_or_else(|_| "0.0.0.0:9999".to_string());
+    let target = std::env::var("TARGET").unwrap_or_else(|_| "10.0.3.123:6666".to_string());
+    vec![Route {
+        symbol: symbol.trim().to_ascii_lowercase(),
+        bind_addr,
+        target,
+        core_id: None,
+    }]
+}
+
+fn assign_route_cores(routes: &mut [Route]) {
+    let per_symbol =
+        parse_symbol_core_map(&std::env::var("POLYEDGE_SENDER_PIN_CORES").unwrap_or_default());
+    let fallback = std::env::var("POLYEDGE_SENDER_PIN_CORE")
+        .ok()
+        .and_then(|v| v.parse::<usize>().ok());
+    for route in routes {
+        route.core_id = per_symbol.get(route.symbol.as_str()).copied().or(fallback);
+    }
+}
+
+fn parse_symbol_targets(raw: &str, bind_base_port_raw: &str) -> Vec<(String, String, String)> {
+    let bind_base_port = bind_base_port_raw.parse::<u16>().unwrap_or(9999);
+    let mut routes = Vec::<(String, String, String)>::new();
+    for (idx, token) in raw.split(',').enumerate() {
+        let token = token.trim();
+        if token.is_empty() {
+            continue;
+        }
+        let mut pair = token.split('=');
+        let symbol = pair.next().unwrap_or_default().trim().to_ascii_lowercase();
+        let target = pair.next().unwrap_or_default().trim().to_string();
+        if symbol.is_empty() || target.is_empty() || pair.next().is_some() {
+            continue;
+        }
+        let bind_addr = format!("0.0.0.0:{}", bind_base_port.saturating_add(idx as u16));
+        routes.push((symbol, bind_addr, target));
+    }
+    routes
+}
+
+fn parse_symbol_core_map(raw: &str) -> HashMap<String, usize> {
+    let mut out = HashMap::<String, usize>::new();
+    for item in raw.split(',') {
+        let token = item.trim();
+        if token.is_empty() {
+            continue;
+        }
+        let mut pair = token.split(':');
+        let symbol = pair.next().unwrap_or_default().trim().to_ascii_lowercase();
+        let core = pair.next().unwrap_or_default().trim();
+        if symbol.is_empty() || core.is_empty() || pair.next().is_some() {
+            continue;
+        }
+        if let Ok(core_id) = core.parse::<usize>() {
+            out.insert(symbol, core_id);
+        }
+    }
+    out
+}
+
+async fn run_route(route: &Route, tuning: SenderTuning) -> Result<()> {
+    let target_addr: SocketAddr = route
+        .target
+        .parse()
+        .with_context(|| format!("parse sender target {}", route.target))?;
+    let socket = UdpSocket::bind(&route.bind_addr)
+        .with_context(|| format!("bind sender UDP socket at {}", route.bind_addr))?;
+    apply_udp_sender_socket_tuning(&socket, tuning.sndbuf_bytes)?;
+    socket
+        .set_nonblocking(true)
+        .context("set sender UDP socket nonblocking")?;
+
+    eprintln!(
+        "sender: bind={} target={} symbol={} redundancy={} sndbuf={:?}",
+        route.bind_addr, route.target, route.symbol, tuning.redundancy, tuning.sndbuf_bytes
+    );
+
+    let wire_mode = WireMode::from_env("POLYEDGE_WIRE_MODE");
+    let mut packet_buf = [0u8; WIRE_MAX_PACKET_SIZE];
+    let mut frames: u64 = 0;
+    let mut packets_ok: u64 = 0;
+    let mut dropped_would_block: u64 = 0;
+    let mut dropped_conn_refused: u64 = 0;
+    let mut dropped_other: u64 = 0;
+    let mut redundancy_ctl = RedundancyController::new(tuning);
+    let mut velocity_estimator = VelocityEstimator::default();
+    let mut last_log = std::time::Instant::now();
+
+    loop {
+        let endpoint_candidates = pick_best_fstream_ws_endpoint(fstream_ws_endpoints(&route.symbol)).await;
+        let mut ws_stream = None;
+        let mut last_err: Option<String> = None;
+        for endpoint in endpoint_candidates {
+            match timeout(
+                Duration::from_secs(
+                    std::env::var("POLYEDGE_FSTREAM_WS_CONNECT_TIMEOUT_SEC")
+                        .ok()
+                        .and_then(|v| v.parse::<u64>().ok())
+                        .unwrap_or(3)
+                        .max(1),
+                ),
+                connect_async(&endpoint),
+            )
+            .await
+            {
+                Ok(Ok((socket, _))) => {
+                    ws_stream = Some(socket);
+                    break;
+                }
+                Ok(Err(err)) => {
+                    last_err = Some(format!("{endpoint}: {err}"));
+                    continue;
+                }
+                Err(_) => {
+                    last_err = Some(format!("{endpoint}: connect timeout"));
+                    continue;
+                }
+            }
+        }
+        let Some(mut ws_stream) = ws_stream else {
+            eprintln!(
+                "sender: websocket connect error for symbol={} last={}",
+                route.symbol,
+                last_err.unwrap_or_else(|| "no endpoint available".to_string())
+            );
+            tokio::time::sleep(Duration::from_secs(1)).await;
+            continue;
+        };
+
+        while let Some(frame) = ws_stream.next().await {
+            let Ok(message) = frame else {
+                break;
+            };
+            let Message::Text(text) = message else {
+                continue;
+            };
+
+            if let Some(packet) = parse_book_ticker(&text) {
+                let velocity_bps_per_sec = velocity_estimator.velocity_bps_per_sec(&packet);
+                let packet_len = encode_with_mode(
+                    &packet,
+                    velocity_bps_per_sec,
+                    Some((now_micros() / 1_000) as i64),
+                    wire_mode,
+                    &mut packet_buf,
+                )
+                .context("encode wire packet")?;
+                frames = frames.saturating_add(1);
+
+                for _ in 0..redundancy_ctl.current() {
+                    match socket.send_to(&packet_buf[..packet_len], target_addr) {
+                        Ok(_) => packets_ok = packets_ok.saturating_add(1),
+                        Err(err) if err.kind() == std::io::ErrorKind::WouldBlock => {
+                            dropped_would_block = dropped_would_block.saturating_add(1);
+                        }
+                        Err(err) if err.kind() == std::io::ErrorKind::ConnectionRefused => {
+                            dropped_conn_refused = dropped_conn_refused.saturating_add(1);
+                        }
+                        Err(_) => dropped_other = dropped_other.saturating_add(1),
+                    }
+                }
+            }
+
+            let total_errors = dropped_would_block
+                .saturating_add(dropped_conn_refused)
+                .saturating_add(dropped_other);
+            redundancy_ctl.on_progress(total_errors);
+
+            if last_log.elapsed().as_secs() >= 5 {
+                eprintln!(
+                    "sender: symbol={} wire_mode={:?} frames={} packets_ok={} dropped_would_block={} dropped_conn_refused={} dropped_other={} redundancy={}",
+                    route.symbol,
+                    wire_mode,
+                    frames,
+                    packets_ok,
+                    dropped_would_block,
+                    dropped_conn_refused,
+                    dropped_other,
+                    redundancy_ctl.current()
+                );
+                last_log = std::time::Instant::now();
+            }
+        }
+
+        eprintln!(
+            "sender: websocket disconnected for symbol={}, reconnecting...",
+            route.symbol
+        );
+        tokio::time::sleep(Duration::from_millis(300)).await;
+    }
+}
+
+async fn pick_best_fstream_ws_endpoint(endpoints: Vec<String>) -> Vec<String> {
+    if endpoints.len() <= 1 {
+        return endpoints;
+    }
+    let timeout_dur = Duration::from_secs(
+        std::env::var("POLYEDGE_WS_PROBE_TIMEOUT_SEC")
+            .ok()
+            .and_then(|v| v.parse::<u64>().ok())
+            .unwrap_or(2)
+            .max(1),
+    );
+    let mut join_set = tokio::task::JoinSet::new();
+    for ep in endpoints.iter().cloned() {
+        join_set.spawn(async move {
+            let started = Instant::now();
+            let ok = timeout(timeout_dur, connect_async(&ep)).await;
+            match ok {
+                Ok(Ok((ws, _resp))) => {
+                    drop(ws);
+                    Some((ep, started.elapsed().as_secs_f64() * 1_000.0))
+                }
+                _ => None,
+            }
+        });
+    }
+    let mut results: Vec<(String, f64)> = Vec::new();
+    while let Some(res) = join_set.join_next().await {
+        if let Ok(Some(v)) = res {
+            results.push(v);
+        }
+    }
+    if results.is_empty() {
+        return endpoints;
+    }
+    results.sort_by(|a, b| a.1.total_cmp(&b.1));
+    let best = results[0].0.clone();
+    eprintln!(
+        "sender: symbol endpoint selected={} handshake_ms={:.3} candidates={}",
+        best,
+        results[0].1,
+        endpoints.len()
+    );
+    let mut out = Vec::with_capacity(endpoints.len());
+    out.push(best.clone());
+    for ep in endpoints {
+        if ep != best {
+            out.push(ep);
+        }
+    }
+    out
+}
+
+fn fstream_ws_endpoints(symbol: &str) -> Vec<String> {
+    if let Ok(raw) = std::env::var("POLYEDGE_BINANCE_FSTREAM_WS_BASES") {
+        let out = raw
+            .split(',')
+            .map(str::trim)
+            .filter(|v| v.starts_with("ws://") || v.starts_with("wss://"))
+            .map(|base| format!("{}/ws/{}@bookTicker", base.trim_end_matches('/'), symbol))
+            .collect::<Vec<_>>();
+        if !out.is_empty() {
+            return out;
+        }
+    }
+    if let Ok(base) = std::env::var("POLYEDGE_BINANCE_FSTREAM_WS_BASE") {
+        if base.starts_with("ws://") || base.starts_with("wss://") {
+            return vec![format!(
+                "{}/ws/{}@bookTicker",
+                base.trim_end_matches('/'),
+                symbol
+            )];
+        }
+    }
+    vec![
+        format!("wss://fstream.binance.com/ws/{}@bookTicker", symbol),
+        format!("wss://fstream1.binance.com/ws/{}@bookTicker", symbol),
+        format!("wss://fstream2.binance.com/ws/{}@bookTicker", symbol),
+    ]
+}
+
+#[cfg(target_os = "linux")]
+fn apply_udp_sender_socket_tuning(socket: &UdpSocket, sndbuf_bytes: Option<usize>) -> Result<()> {
+    if let Some(bytes) = sndbuf_bytes {
+        let value: libc::c_int = bytes.try_into().unwrap_or(libc::c_int::MAX);
+        let rc = unsafe {
+            libc::setsockopt(
+                socket.as_raw_fd(),
+                libc::SOL_SOCKET,
+                libc::SO_SNDBUF,
+                (&value as *const libc::c_int).cast(),
+                std::mem::size_of::<libc::c_int>() as libc::socklen_t,
+            )
+        };
+        if rc != 0 {
+            let err = std::io::Error::last_os_error();
+            anyhow::bail!("set SO_SNDBUF={} failed: {}", bytes, err);
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn apply_udp_sender_socket_tuning(_socket: &UdpSocket, _sndbuf_bytes: Option<usize>) -> Result<()> {
+    Ok(())
+}
+
+#[cfg(target_os = "linux")]
+fn pin_current_thread(core_id: usize) -> Result<()> {
+    let mut cpuset: libc::cpu_set_t = unsafe { std::mem::zeroed() };
+    unsafe {
+        libc::CPU_ZERO(&mut cpuset);
+        libc::CPU_SET(core_id, &mut cpuset);
+        let rc = libc::pthread_setaffinity_np(
+            libc::pthread_self(),
+            std::mem::size_of::<libc::cpu_set_t>(),
+            &cpuset,
+        );
+        if rc != 0 {
+            let err = std::io::Error::from_raw_os_error(rc);
+            anyhow::bail!("pthread_setaffinity_np(core={core_id}) failed: {err}");
+        }
+    }
+    Ok(())
+}
+
+#[cfg(not(target_os = "linux"))]
+fn pin_current_thread(_core_id: usize) -> Result<()> {
+    Ok(())
+}
+
+#[inline]
+fn parse_book_ticker(payload: &str) -> Option<WireBookTop24> {
+    let bytes = payload.as_bytes();
+    let bid = extract_quoted_f64(bytes, KEY_BID)?;
+    let ask = extract_quoted_f64(bytes, KEY_ASK)?;
+    let event_ms = extract_u64(bytes, KEY_EVENT_MS)?;
+
+    let ts_micros = if event_ms > 0 {
+        event_ms.saturating_mul(1_000)
+    } else {
+        now_micros()
+    };
+
+    Some(WireBookTop24 {
+        ts_micros,
+        bid,
+        ask,
+    })
+}
+
+#[inline]
+fn extract_quoted_f64(payload: &[u8], key_with_quote: &[u8]) -> Option<f64> {
+    let start = find_subslice(payload, key_with_quote)? + key_with_quote.len();
+    let end_rel = payload.get(start..)?.iter().position(|&b| b == b'"')?;
+    let end = start + end_rel;
+    std::str::from_utf8(payload.get(start..end)?)
+        .ok()?
+        .parse()
+        .ok()
+}
+
+#[inline]
+fn extract_u64(payload: &[u8], key: &[u8]) -> Option<u64> {
+    let start = find_subslice(payload, key)? + key.len();
+    let tail = payload.get(start..)?;
+    let mut end_rel = 0usize;
+    while end_rel < tail.len() && tail[end_rel].is_ascii_digit() {
+        end_rel += 1;
+    }
+    if end_rel == 0 {
+        return None;
+    }
+    std::str::from_utf8(&tail[..end_rel]).ok()?.parse().ok()
+}
+
+#[inline]
+fn find_subslice(haystack: &[u8], needle: &[u8]) -> Option<usize> {
+    if needle.is_empty() || needle.len() > haystack.len() {
+        return None;
+    }
+    haystack
+        .windows(needle.len())
+        .position(|window| window == needle)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn parse_symbol_targets_accepts_valid_tokens() {
+        let routes =
+            parse_symbol_targets("btcusdt=10.0.3.123:6666,ethusdt=10.0.3.123:6667", "9999");
+        assert_eq!(routes.len(), 2);
+        assert_eq!(routes[0].0, "btcusdt");
+        assert_eq!(routes[0].1, "0.0.0.0:9999");
+        assert_eq!(routes[1].0, "ethusdt");
+        assert_eq!(routes[1].1, "0.0.0.0:10000");
+    }
+
+    #[test]
+    fn parse_symbol_targets_skips_invalid_tokens() {
+        let routes = parse_symbol_targets("bad,btcusdt=10.0.3.123:6666, =x", "9999");
+        assert_eq!(routes.len(), 1);
+        assert_eq!(routes[0].0, "btcusdt");
+    }
+
+    #[test]
+    fn parse_symbol_core_map_accepts_valid_entries() {
+        let map = parse_symbol_core_map("btcusdt:2,ethusdt:3");
+        assert_eq!(map.get("btcusdt"), Some(&2usize));
+        assert_eq!(map.get("ethusdt"), Some(&3usize));
+    }
+
+    #[test]
+    fn adaptive_redundancy_escalates_on_error_spike() {
+        let tuning = SenderTuning {
+            redundancy: 1,
+            sndbuf_bytes: None,
+            adaptive_redundancy: true,
+            adaptive_redundancy_high: 2,
+            adaptive_err_threshold_per_sec: 1,
+            adaptive_cooldown_sec: 1,
+        };
+        let mut ctl = RedundancyController::new(tuning);
+        assert_eq!(ctl.current(), 1);
+        std::thread::sleep(Duration::from_millis(1100));
+        ctl.on_progress(2);
+        assert_eq!(ctl.current(), 2);
+    }
+}
diff --git a/crates/infra_clock/src/lib.rs b/crates/infra_clock/src/lib.rs
index c78ab08..396f7ec 100644
--- a/crates/infra_clock/src/lib.rs
+++ b/crates/infra_clock/src/lib.rs
@@ -23,7 +23,9 @@ impl Default for MonotonicClock {
 impl MonotonicClock {
     pub fn now_ns(&self) -> i64 {
         let elapsed = self.boot.elapsed().as_nanos() as i64;
-        elapsed + self.offset_ns.load(Ordering::Relaxed)
+        // Use SeqCst to ensure proper memory ordering for time synchronization
+        // This guarantees that writes to offset_ns are visible to subsequent reads
+        elapsed + self.offset_ns.load(Ordering::SeqCst)
     }
 
     pub fn now_ms(&self) -> i64 {
@@ -35,11 +37,12 @@ impl MonotonicClock {
     }
 
     pub fn apply_offset_ns(&self, offset_ns: i64) {
-        self.offset_ns.store(offset_ns, Ordering::Relaxed);
+        // Use SeqCst to ensure the offset is properly visible to all threads
+        self.offset_ns.store(offset_ns, Ordering::SeqCst);
     }
 
     pub fn offset_ns(&self) -> i64 {
-        self.offset_ns.load(Ordering::Relaxed)
+        self.offset_ns.load(Ordering::SeqCst)
     }
 }
 
diff --git a/crates/market_discovery/src/lib.rs b/crates/market_discovery/src/lib.rs
index 969d470..6228d25 100644
--- a/crates/market_discovery/src/lib.rs
+++ b/crates/market_discovery/src/lib.rs
@@ -1,4 +1,4 @@
-use anyhow::{Context, Result};
+use anyhow::{anyhow, Context, Result};
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
 
@@ -11,6 +11,8 @@ pub struct MarketDescriptor {
     pub token_id_no: Option<String>,
     pub event_slug: Option<String>,
     pub end_date: Option<String>,
+    pub timeframe: Option<String>,   // "5m" / "15m" / "1h" / "1d"
+    pub market_type: Option<String>, // "updown" / "above_below" / "range"
     pub best_bid: Option<f64>,
     pub best_ask: Option<f64>,
 }
@@ -82,7 +84,7 @@ impl MarketDiscovery {
         for offset in [0_i64, 1000, 2000, 3000] {
             let limit_s = limit.to_string();
             let offset_s = offset.to_string();
-            let markets: Vec<GammaMarket> = self
+            let response = self
                 .http
                 .get(&self.cfg.endpoint)
                 .query(&[
@@ -95,13 +97,34 @@ impl MarketDiscovery {
                     ("ascending", "false"),
                 ])
                 .send()
-                .await
-                .context("discovery request")?
-                .error_for_status()
-                .context("discovery status")?
-                .json()
-                .await
-                .context("discovery json")?;
+                .await;
+            let response = match response {
+                Ok(v) => v,
+                Err(err) => {
+                    if out.is_empty() {
+                        return Err(err).context("discovery request");
+                    }
+                    break;
+                }
+            };
+            let response = match response.error_for_status() {
+                Ok(v) => v,
+                Err(err) => {
+                    if out.is_empty() {
+                        return Err(err).context("discovery status");
+                    }
+                    break;
+                }
+            };
+            let markets: Vec<GammaMarket> = match response.json().await {
+                Ok(v) => v,
+                Err(err) => {
+                    if out.is_empty() {
+                        return Err(err).context("discovery json");
+                    }
+                    break;
+                }
+            };
 
             if markets.is_empty() {
                 break;
@@ -130,15 +153,16 @@ impl MarketDiscovery {
                 {
                     continue;
                 }
+                let timeframe = classify_timeframe(&text);
                 if !self.cfg.timeframes.is_empty() {
-                    let Some(timeframe) = classify_timeframe(&text) else {
+                    let Some(tf) = timeframe else {
                         continue;
                     };
                     if !self
                         .cfg
                         .timeframes
                         .iter()
-                        .any(|t| t.eq_ignore_ascii_case(timeframe))
+                        .any(|t| t.eq_ignore_ascii_case(tf))
                     {
                         continue;
                     }
@@ -155,12 +179,17 @@ impl MarketDiscovery {
                     token_id_no: parse_token_pair(market.clob_token_ids.as_deref()).map(|x| x.1),
                     event_slug: market.event_slug,
                     end_date: market.end_date,
+                    timeframe: timeframe.map(|v| v.to_string()),
+                    market_type: Some(market_type.to_string()),
                     best_bid: market.best_bid,
                     best_ask: market.best_ask,
                 });
             }
         }
 
+        if out.is_empty() {
+            return Err(anyhow!("no markets discovered from gamma"));
+        }
         Ok(out)
     }
 }
diff --git a/crates/observability/Cargo.toml b/crates/observability/Cargo.toml
index 382060a..e5a2281 100644
--- a/crates/observability/Cargo.toml
+++ b/crates/observability/Cargo.toml
@@ -9,3 +9,4 @@ metrics.workspace = true
 metrics-exporter-prometheus.workspace = true
 tracing.workspace = true
 tracing-subscriber.workspace = true
+tracing-appender.workspace = true
diff --git a/crates/observability/src/lib.rs b/crates/observability/src/lib.rs
index 75ae823..57be135 100644
--- a/crates/observability/src/lib.rs
+++ b/crates/observability/src/lib.rs
@@ -5,15 +5,20 @@ use tracing_subscriber::EnvFilter;
 
 static PROM_HANDLE: OnceLock<PrometheusHandle> = OnceLock::new();
 
-pub fn init_tracing(service_name: &str) {
+pub fn init_tracing(service_name: &str) -> Option<tracing_appender::non_blocking::WorkerGuard> {
     let filter = EnvFilter::try_from_default_env()
         .unwrap_or_else(|_| EnvFilter::new(format!("{service_name}=info,info")));
 
+    let (non_blocking, guard) = tracing_appender::non_blocking(std::io::stdout());
+
     let _ = tracing_subscriber::fmt()
         .with_env_filter(filter)
+        .with_writer(non_blocking)
         .with_target(true)
         .with_thread_ids(true)
         .try_init();
+
+    Some(guard)
 }
 
 pub fn init_metrics() -> PrometheusHandle {
diff --git a/crates/paper_executor/src/lib.rs b/crates/paper_executor/src/lib.rs
index 279d8a6..b282753 100644
--- a/crates/paper_executor/src/lib.rs
+++ b/crates/paper_executor/src/lib.rs
@@ -1,13 +1,16 @@
 use std::collections::HashMap;
 
 use chrono::Utc;
-use core_types::{BookTop, FillEvent, OrderAck, OrderSide, QuoteIntent};
+use core_types::{BookTop, ExecutionStyle, FillEvent, OrderAck, OrderSide, QuoteIntent};
 use parking_lot::RwLock;
 
 #[derive(Debug, Clone)]
 pub struct ShadowOrder {
     pub order_id: String,
     pub intent: QuoteIntent,
+    pub style: ExecutionStyle,
+    pub reference_mid: f64,
+    pub fee_rate_bps: f64,
 }
 
 #[derive(Default)]
@@ -16,12 +19,22 @@ pub struct ShadowExecutor {
 }
 
 impl ShadowExecutor {
-    pub fn register_order(&self, ack: &OrderAck, intent: QuoteIntent) {
+    pub fn register_order(
+        &self,
+        ack: &OrderAck,
+        intent: QuoteIntent,
+        style: ExecutionStyle,
+        reference_mid: f64,
+        fee_rate_bps: f64,
+    ) {
         self.orders.write().insert(
             ack.order_id.clone(),
             ShadowOrder {
                 order_id: ack.order_id.clone(),
                 intent,
+                style,
+                reference_mid,
+                fee_rate_bps,
             },
         );
     }
@@ -32,15 +45,14 @@ impl ShadowExecutor {
 
     pub fn on_book(&self, book: &BookTop) -> Vec<FillEvent> {
         let mut fills = Vec::new();
-        let mut to_remove = Vec::new();
-
-        {
-            let orders = self.orders.read();
-            for (id, order) in orders.iter() {
-                if order.intent.market_id != book.market_id {
-                    continue;
-                }
 
+        // Use write lock for entire operation to prevent race condition
+        // between read (matching) and write (removing filled orders)
+        let mut orders = self.orders.write();
+        let to_remove: Vec<String> = orders
+            .iter()
+            .filter(|(_, order)| order.intent.market_id == book.market_id)
+            .filter_map(|(id, order)| {
                 let maybe_fill_price = match order.intent.side {
                     OrderSide::BuyYes if order.intent.price >= book.ask_yes => Some(book.ask_yes),
                     OrderSide::SellYes if order.intent.price <= book.bid_yes => Some(book.bid_yes),
@@ -48,27 +60,49 @@ impl ShadowExecutor {
                     OrderSide::SellNo if order.intent.price <= book.bid_no => Some(book.bid_no),
                     _ => None,
                 };
-
-                if let Some(px) = maybe_fill_price {
+                maybe_fill_price.map(|px| {
+                    let mid_price = mid_for_side(book, &order.intent.side);
+                    let slippage_bps = if mid_price > 0.0 {
+                        Some(((px - mid_price) / mid_price) * 10_000.0)
+                    } else {
+                        None
+                    };
+                    let executed_size_usdc = (px * order.intent.size).max(0.0);
+                    let fee = if order.fee_rate_bps.is_finite() && order.fee_rate_bps != 0.0 {
+                        executed_size_usdc * (order.fee_rate_bps / 10_000.0)
+                    } else {
+                        match order.style {
+                            ExecutionStyle::Maker => 0.0,
+                            ExecutionStyle::Taker | ExecutionStyle::Arb => {
+                                let taker_fee_rate = if !(0.02..=0.98).contains(&px) {
+                                    0.001
+                                } else {
+                                    0.01
+                                };
+                                executed_size_usdc * taker_fee_rate
+                            }
+                        }
+                    };
                     fills.push(FillEvent {
                         order_id: id.clone(),
                         market_id: order.intent.market_id.clone(),
                         side: order.intent.side.clone(),
+                        style: order.style.clone(),
                         price: px,
                         size: order.intent.size,
-                        fee: 0.0,
+                        fee,
+                        mid_price: Some(mid_price.max(0.0)),
+                        slippage_bps,
                         ts_ms: Utc::now().timestamp_millis(),
                     });
-                    to_remove.push(id.clone());
-                }
-            }
-        }
+                    id.clone()
+                })
+            })
+            .collect();
 
-        if !to_remove.is_empty() {
-            let mut orders = self.orders.write();
-            for id in to_remove {
-                orders.remove(&id);
-            }
+        // Remove filled orders within same write lock
+        for id in to_remove {
+            orders.remove(&id);
         }
 
         fills
@@ -79,6 +113,13 @@ impl ShadowExecutor {
     }
 }
 
+fn mid_for_side(book: &BookTop, side: &OrderSide) -> f64 {
+    match side {
+        OrderSide::BuyYes | OrderSide::SellYes => (book.bid_yes + book.ask_yes) * 0.5,
+        OrderSide::BuyNo | OrderSide::SellNo => (book.bid_no + book.ask_no) * 0.5,
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -101,6 +142,9 @@ mod tests {
                 size: 1.0,
                 ttl_ms: 1_000,
             },
+            ExecutionStyle::Maker,
+            0.52,
+            -2.0,
         );
         let fills = shadow.on_book(&BookTop {
             market_id: "m1".to_string(),
@@ -114,5 +158,107 @@ mod tests {
             recv_ts_local_ns: 2_000_000,
         });
         assert_eq!(fills.len(), 1);
+        assert!(fills[0].fee < 0.0);
+    }
+
+    #[test]
+    fn taker_fee_curve_boundaries() {
+        let shadow = ShadowExecutor::default();
+        let book = BookTop {
+            market_id: "m1".to_string(),
+            token_id_yes: "y".to_string(),
+            token_id_no: "n".to_string(),
+            bid_yes: 0.50,
+            ask_yes: 0.50,
+            bid_no: 0.49,
+            ask_no: 0.51,
+            ts_ms: 2,
+            recv_ts_local_ns: 2_000_000,
+        };
+
+        for (idx, px, expected_rate) in [
+            (0, 0.0199, 0.001),
+            (1, 0.02, 0.01),
+            (2, 0.98, 0.01),
+            (3, 0.9801, 0.001),
+        ] {
+            let order_id = format!("o{idx}");
+            let ack = OrderAck {
+                order_id: order_id.clone(),
+                market_id: "m1".to_string(),
+                accepted: true,
+                ts_ms: 1,
+            };
+            let side = OrderSide::BuyYes;
+            shadow.register_order(
+                &ack,
+                QuoteIntent {
+                    market_id: "m1".to_string(),
+                    side,
+                    price: px,
+                    size: 10.0,
+                    ttl_ms: 1000,
+                },
+                ExecutionStyle::Taker,
+                px,
+                expected_rate * 10_000.0,
+            );
+            let mut book_local = book.clone();
+            book_local.ask_yes = px;
+            book_local.bid_yes = px;
+            let fills = shadow.on_book(&book_local);
+            assert_eq!(fills.len(), 1);
+            let expected = px * 10.0 * expected_rate;
+            assert!((fills[0].fee - expected).abs() < 1e-9);
+        }
+    }
+
+    #[test]
+    fn slippage_bps_sign_and_side_formula() {
+        let shadow = ShadowExecutor::default();
+        let book = BookTop {
+            market_id: "m1".to_string(),
+            token_id_yes: "y".to_string(),
+            token_id_no: "n".to_string(),
+            bid_yes: 0.48,
+            ask_yes: 0.52,
+            bid_no: 0.47,
+            ask_no: 0.53,
+            ts_ms: 2,
+            recv_ts_local_ns: 2_000_000,
+        };
+
+        let cases = [
+            ("by", OrderSide::BuyYes, 0.52, 400.0),
+            ("sy", OrderSide::SellYes, 0.48, -400.0),
+            ("bn", OrderSide::BuyNo, 0.53, 600.0),
+            ("sn", OrderSide::SellNo, 0.47, -600.0),
+        ];
+
+        for (suffix, side, px, expected_slippage) in cases {
+            let order_id = format!("o-{suffix}");
+            let ack = OrderAck {
+                order_id: order_id.clone(),
+                market_id: "m1".to_string(),
+                accepted: true,
+                ts_ms: 1,
+            };
+            shadow.register_order(
+                &ack,
+                QuoteIntent {
+                    market_id: "m1".to_string(),
+                    side,
+                    price: px,
+                    size: 1.0,
+                    ttl_ms: 1000,
+                },
+                ExecutionStyle::Taker,
+                0.5,
+                0.0,
+            );
+            let fills = shadow.on_book(&book);
+            assert_eq!(fills.len(), 1);
+            assert!((fills[0].slippage_bps.unwrap_or_default() - expected_slippage).abs() < 1e-9);
+        }
     }
 }
diff --git a/crates/poly_wire/Cargo.toml b/crates/poly_wire/Cargo.toml
new file mode 100644
index 0000000..86eefa9
--- /dev/null
+++ b/crates/poly_wire/Cargo.toml
@@ -0,0 +1,8 @@
+[package]
+name = "poly_wire"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+serde = { workspace = true, features = ["derive"] }
+bincode = { workspace = true }
diff --git a/crates/poly_wire/src/lib.rs b/crates/poly_wire/src/lib.rs
new file mode 100644
index 0000000..0c7b149
--- /dev/null
+++ b/crates/poly_wire/src/lib.rs
@@ -0,0 +1,321 @@
+use bincode::Options;
+use serde::{Deserialize, Serialize};
+use std::io::Cursor;
+
+/// Tight 24-byte quote packet for pure UDP relay hot path.
+/// Layout (Little Endian):
+/// [ts_micros: u64][bid: f64][ask: f64]
+pub const WIRE_BOOK_TOP24_SIZE: usize = 24;
+/// Momentum packet extension.
+/// Layout (Little Endian):
+/// [ts_micros: u64][bid: f64][ask: f64][velocity_bps_per_sec: f64]
+pub const WIRE_MOMENTUM_TICK32_SIZE: usize = 32;
+/// Relay packet extension (first-hop timestamp carried from Tokyo sender).
+/// Layout (Little Endian):
+/// [ts_micros: u64][bid: f64][ask: f64][velocity_bps_per_sec: f64][ts_first_hop_ms: i64]
+pub const WIRE_RELAY_TICK40_SIZE: usize = 40;
+pub const WIRE_MAX_PACKET_SIZE: usize = WIRE_RELAY_TICK40_SIZE;
+
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
+pub struct WireBookTop24 {
+    pub ts_micros: u64,
+    pub bid: f64,
+    pub ask: f64,
+}
+
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
+pub struct WireMomentumTick32 {
+    pub ts_micros: u64,
+    pub bid: f64,
+    pub ask: f64,
+    pub velocity_bps_per_sec: f64,
+}
+
+#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
+pub struct WireRelayTick40 {
+    pub ts_micros: u64,
+    pub bid: f64,
+    pub ask: f64,
+    pub velocity_bps_per_sec: f64,
+    pub ts_first_hop_ms: i64,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum WireMode {
+    Fixed24,
+    Fixed32,
+    Auto,
+}
+
+impl WireMode {
+    pub fn from_env(var_name: &str) -> Self {
+        let raw = std::env::var(var_name).unwrap_or_else(|_| "auto".to_string());
+        Self::parse(&raw)
+    }
+
+    pub fn parse(raw: &str) -> Self {
+        match raw.trim().to_ascii_lowercase().as_str() {
+            "24" | "book24" | "top24" | "fixed24" => Self::Fixed24,
+            "32" | "momentum32" | "tick32" | "fixed32" => Self::Fixed32,
+            _ => Self::Auto,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub enum WirePacket {
+    BookTop24(WireBookTop24),
+    MomentumTick32(WireMomentumTick32),
+    RelayTick40(WireRelayTick40),
+}
+
+#[derive(Debug)]
+pub enum WireDecodeError {
+    UnsupportedSize(usize),
+    Bincode(bincode::Error),
+}
+
+impl std::fmt::Display for WireDecodeError {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        match self {
+            Self::UnsupportedSize(sz) => write!(f, "unsupported wire packet size: {}", sz),
+            Self::Bincode(err) => write!(f, "wire decode error: {}", err),
+        }
+    }
+}
+
+impl std::error::Error for WireDecodeError {}
+
+/// Explicit little-endian + fixed-width encoding for deterministic wire format.
+#[inline]
+pub fn wire_options() -> impl Options {
+    bincode::DefaultOptions::new()
+        .with_little_endian()
+        .with_fixint_encoding()
+}
+
+#[inline]
+pub fn encode_book_top24(
+    packet: &WireBookTop24,
+    out: &mut [u8; WIRE_BOOK_TOP24_SIZE],
+) -> Result<(), bincode::Error> {
+    let mut cursor = Cursor::new(out.as_mut_slice());
+    wire_options().serialize_into(&mut cursor, packet)
+}
+
+#[inline]
+pub fn decode_book_top24(
+    input: &[u8; WIRE_BOOK_TOP24_SIZE],
+) -> Result<WireBookTop24, bincode::Error> {
+    wire_options().deserialize(input.as_slice())
+}
+
+#[inline]
+pub fn encode_momentum_tick32(
+    packet: &WireMomentumTick32,
+    out: &mut [u8; WIRE_MOMENTUM_TICK32_SIZE],
+) -> Result<(), bincode::Error> {
+    let mut cursor = Cursor::new(out.as_mut_slice());
+    wire_options().serialize_into(&mut cursor, packet)
+}
+
+#[inline]
+pub fn decode_momentum_tick32(
+    input: &[u8; WIRE_MOMENTUM_TICK32_SIZE],
+) -> Result<WireMomentumTick32, bincode::Error> {
+    wire_options().deserialize(input.as_slice())
+}
+
+#[inline]
+pub fn encode_relay_tick40(
+    packet: &WireRelayTick40,
+    out: &mut [u8; WIRE_RELAY_TICK40_SIZE],
+) -> Result<(), bincode::Error> {
+    let mut cursor = Cursor::new(out.as_mut_slice());
+    wire_options().serialize_into(&mut cursor, packet)
+}
+
+#[inline]
+pub fn decode_relay_tick40(
+    input: &[u8; WIRE_RELAY_TICK40_SIZE],
+) -> Result<WireRelayTick40, bincode::Error> {
+    wire_options().deserialize(input.as_slice())
+}
+
+#[inline]
+pub fn decode_auto(input: &[u8]) -> Result<WirePacket, WireDecodeError> {
+    match input.len() {
+        WIRE_BOOK_TOP24_SIZE => {
+            let mut buf = [0u8; WIRE_BOOK_TOP24_SIZE];
+            buf.copy_from_slice(input);
+            decode_book_top24(&buf)
+                .map(WirePacket::BookTop24)
+                .map_err(WireDecodeError::Bincode)
+        }
+        WIRE_MOMENTUM_TICK32_SIZE => {
+            let mut buf = [0u8; WIRE_MOMENTUM_TICK32_SIZE];
+            buf.copy_from_slice(input);
+            decode_momentum_tick32(&buf)
+                .map(WirePacket::MomentumTick32)
+                .map_err(WireDecodeError::Bincode)
+        }
+        WIRE_RELAY_TICK40_SIZE => {
+            let mut buf = [0u8; WIRE_RELAY_TICK40_SIZE];
+            buf.copy_from_slice(input);
+            decode_relay_tick40(&buf)
+                .map(WirePacket::RelayTick40)
+                .map_err(WireDecodeError::Bincode)
+        }
+        other => Err(WireDecodeError::UnsupportedSize(other)),
+    }
+}
+
+#[inline]
+pub fn encode_with_mode(
+    packet24: &WireBookTop24,
+    velocity_bps_per_sec: f64,
+    ts_first_hop_ms: Option<i64>,
+    mode: WireMode,
+    out: &mut [u8; WIRE_MAX_PACKET_SIZE],
+) -> Result<usize, bincode::Error> {
+    match mode {
+        WireMode::Fixed24 => {
+            let mut view = [0u8; WIRE_BOOK_TOP24_SIZE];
+            encode_book_top24(packet24, &mut view)?;
+            out[..WIRE_BOOK_TOP24_SIZE].copy_from_slice(&view);
+            Ok(WIRE_BOOK_TOP24_SIZE)
+        }
+        WireMode::Fixed32 => {
+            let mut view = [0u8; WIRE_MOMENTUM_TICK32_SIZE];
+            let packet32 = WireMomentumTick32 {
+                ts_micros: packet24.ts_micros,
+                bid: packet24.bid,
+                ask: packet24.ask,
+                velocity_bps_per_sec,
+            };
+            encode_momentum_tick32(&packet32, &mut view)?;
+            out[..WIRE_MOMENTUM_TICK32_SIZE].copy_from_slice(&view);
+            Ok(WIRE_MOMENTUM_TICK32_SIZE)
+        }
+        WireMode::Auto => {
+            // Auto prefers the richer relay packet while receivers stay backward-compatible.
+            let mut view = [0u8; WIRE_RELAY_TICK40_SIZE];
+            let packet40 = WireRelayTick40 {
+                ts_micros: packet24.ts_micros,
+                bid: packet24.bid,
+                ask: packet24.ask,
+                velocity_bps_per_sec,
+                ts_first_hop_ms: ts_first_hop_ms
+                    .unwrap_or_else(|| (packet24.ts_micros / 1_000) as i64),
+            };
+            encode_relay_tick40(&packet40, &mut view)?;
+            out[..WIRE_RELAY_TICK40_SIZE].copy_from_slice(&view);
+            Ok(WIRE_RELAY_TICK40_SIZE)
+        }
+    }
+}
+
+/// Helper to get current micros
+pub fn now_micros() -> u64 {
+    std::time::SystemTime::now()
+        .duration_since(std::time::UNIX_EPOCH)
+        .unwrap_or_default()
+        .as_micros() as u64
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn wire_24_size_is_stable() {
+        let sample = WireBookTop24 {
+            ts_micros: 1,
+            bid: 100.25,
+            ask: 100.75,
+        };
+        let bytes = wire_options()
+            .serialize(&sample)
+            .expect("serialize WireBookTop24");
+        assert_eq!(bytes.len(), WIRE_BOOK_TOP24_SIZE);
+    }
+
+    #[test]
+    fn wire_24_roundtrip() {
+        let sample = WireBookTop24 {
+            ts_micros: 42,
+            bid: 61321.5,
+            ask: 61322.0,
+        };
+        let mut out = [0u8; WIRE_BOOK_TOP24_SIZE];
+        encode_book_top24(&sample, &mut out).expect("encode");
+        let decoded = decode_book_top24(&out).expect("decode");
+        assert_eq!(decoded, sample);
+    }
+
+    #[test]
+    fn wire_32_roundtrip() {
+        let sample = WireMomentumTick32 {
+            ts_micros: 42,
+            bid: 61321.5,
+            ask: 61322.0,
+            velocity_bps_per_sec: 7.5,
+        };
+        let mut out = [0u8; WIRE_MOMENTUM_TICK32_SIZE];
+        encode_momentum_tick32(&sample, &mut out).expect("encode 32");
+        let decoded = decode_momentum_tick32(&out).expect("decode 32");
+        assert_eq!(decoded, sample);
+    }
+
+    #[test]
+    fn wire_decode_auto_handles_24_and_32() {
+        let book24 = WireBookTop24 {
+            ts_micros: 10,
+            bid: 100.1,
+            ask: 100.2,
+        };
+        let mut raw24 = [0u8; WIRE_BOOK_TOP24_SIZE];
+        encode_book_top24(&book24, &mut raw24).expect("encode 24");
+        match decode_auto(&raw24).expect("decode auto 24") {
+            WirePacket::BookTop24(v) => assert_eq!(v, book24),
+            _ => panic!("expected WirePacket::BookTop24"),
+        }
+
+        let mut raw32 = [0u8; WIRE_MAX_PACKET_SIZE];
+        let n = encode_with_mode(&book24, 3.2, None, WireMode::Fixed32, &mut raw32)
+            .expect("encode mode");
+        assert_eq!(n, WIRE_MOMENTUM_TICK32_SIZE);
+        match decode_auto(&raw32[..n]).expect("decode auto 32") {
+            WirePacket::MomentumTick32(v) => {
+                assert_eq!(v.ts_micros, book24.ts_micros);
+                assert_eq!(v.bid, book24.bid);
+                assert_eq!(v.ask, book24.ask);
+                assert_eq!(v.velocity_bps_per_sec, 3.2);
+            }
+            _ => panic!("expected WirePacket::MomentumTick32"),
+        }
+
+        let mut raw40 = [0u8; WIRE_MAX_PACKET_SIZE];
+        let n = encode_with_mode(&book24, 5.4, Some(123456), WireMode::Auto, &mut raw40)
+            .expect("encode mode auto");
+        assert_eq!(n, WIRE_RELAY_TICK40_SIZE);
+        match decode_auto(&raw40[..n]).expect("decode auto 40") {
+            WirePacket::RelayTick40(v) => {
+                assert_eq!(v.ts_micros, book24.ts_micros);
+                assert_eq!(v.bid, book24.bid);
+                assert_eq!(v.ask, book24.ask);
+                assert_eq!(v.velocity_bps_per_sec, 5.4);
+                assert_eq!(v.ts_first_hop_ms, 123456);
+            }
+            _ => panic!("expected WirePacket::RelayTick40"),
+        }
+    }
+
+    #[test]
+    fn wire_mode_parse_default_auto() {
+        assert_eq!(WireMode::parse("24"), WireMode::Fixed24);
+        assert_eq!(WireMode::parse("32"), WireMode::Fixed32);
+        assert_eq!(WireMode::parse("auto"), WireMode::Auto);
+        assert_eq!(WireMode::parse("unknown"), WireMode::Auto);
+    }
+}
diff --git a/crates/portfolio/src/lib.rs b/crates/portfolio/src/lib.rs
index 05bcd6c..a69e40e 100644
--- a/crates/portfolio/src/lib.rs
+++ b/crates/portfolio/src/lib.rs
@@ -37,18 +37,22 @@ impl PortfolioBook {
                 pos.yes += fill.size;
             }
             OrderSide::SellYes => {
+                // Use min to prevent negative position: only close up to existing position
                 let closed = fill.size.min(pos.yes);
                 *self.realized.write() += (fill.price - pos.avg_yes) * closed - fill.fee;
-                pos.yes -= fill.size;
+                // Only reduce by actual closed amount, not full fill size
+                pos.yes = (pos.yes - closed).max(0.0);
             }
             OrderSide::BuyNo => {
                 pos.avg_no = weighted_avg(pos.avg_no, pos.no, fill.price, fill.size);
                 pos.no += fill.size;
             }
             OrderSide::SellNo => {
+                // Use min to prevent negative position: only close up to existing position
                 let closed = fill.size.min(pos.no);
                 *self.realized.write() += (fill.price - pos.avg_no) * closed - fill.fee;
-                pos.no -= fill.size;
+                // Only reduce by actual closed amount, not full fill size
+                pos.no = (pos.no - closed).max(0.0);
             }
         }
     }
@@ -57,9 +61,25 @@ impl PortfolioBook {
         self.positions.read().clone()
     }
 
-    pub fn snapshot(&self) -> PnLSnapshot {
+    /// Calculate unrealized PnL based on current market prices
+    /// If no prices provided, unrealized is treated as 0
+    pub fn snapshot_with_prices(&self, prices: &HashMap<String, f64>) -> PnLSnapshot {
         let realized = *self.realized.read();
-        let unrealized = 0.0;
+
+        // Calculate unrealized PnL using current market prices
+        let positions = self.positions.read();
+        let mut unrealized = 0.0;
+        for (market_id, pos) in positions.iter() {
+            if let Some(&current_price) = prices.get(market_id) {
+                // Unrealized = (current_price - avg_price) * position_size
+                // For yes position: (current - avg_yes) * yes
+                // For no position: (current - (1-avg_no)) * no = (avg_no - (1-current)) * no
+                unrealized += (current_price - pos.avg_yes).max(0.0) * pos.yes;
+                unrealized += ((1.0 - pos.avg_no) - (1.0 - current_price)).max(0.0) * pos.no;
+            }
+        }
+        drop(positions);
+
         let equity = realized + unrealized;
 
         let mut peak = self.equity_peak.write();
@@ -80,6 +100,11 @@ impl PortfolioBook {
             daily_pnl: equity,
         }
     }
+
+    /// Legacy snapshot without price info (unrealized = 0)
+    pub fn snapshot(&self) -> PnLSnapshot {
+        self.snapshot_with_prices(&HashMap::new())
+    }
 }
 
 fn weighted_avg(current_avg: f64, current_qty: f64, px: f64, qty: f64) -> f64 {
diff --git a/crates/probability_engine/Cargo.toml b/crates/probability_engine/Cargo.toml
new file mode 100644
index 0000000..7328ec1
--- /dev/null
+++ b/crates/probability_engine/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "probability_engine"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+core_types = { path = "../core_types" }
+serde.workspace = true
+
diff --git a/crates/probability_engine/src/lib.rs b/crates/probability_engine/src/lib.rs
new file mode 100644
index 0000000..ee866f5
--- /dev/null
+++ b/crates/probability_engine/src/lib.rs
@@ -0,0 +1,208 @@
+use core_types::{Direction, DirectionSignal, ProbabilityEstimate, Signal};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ProbabilityEngineConfig {
+    pub momentum_gain: f64,
+    pub lag_penalty_per_ms: f64,
+    pub confidence_floor: f64,
+    /// Black-Scholes/GBM annualized sigma.
+    pub sigma_annual: f64,
+    /// Horizon for near-term digital direction probability.
+    pub horizon_sec: f64,
+    /// Base annualized drift component.
+    pub drift_annual: f64,
+    /// Scale from velocity (bps/s) to annualized drift component.
+    pub velocity_drift_gain: f64,
+    /// Scale from acceleration ((bps/s)/s) to annualized drift component.
+    pub acceleration_drift_gain: f64,
+    /// Blend weight for fair-value prior (0..1). Remaining weight uses BS/GBM model.
+    pub fair_blend_weight: f64,
+}
+
+impl Default for ProbabilityEngineConfig {
+    fn default() -> Self {
+        Self {
+            momentum_gain: 2.0,
+            lag_penalty_per_ms: 0.0002,
+            confidence_floor: 0.05,
+            sigma_annual: 0.90,
+            horizon_sec: 30.0,
+            drift_annual: 0.0,
+            velocity_drift_gain: 0.35,
+            acceleration_drift_gain: 0.02,
+            fair_blend_weight: 0.35,
+        }
+    }
+}
+
+#[derive(Debug, Clone)]
+pub struct ProbabilityEngine {
+    cfg: ProbabilityEngineConfig,
+}
+
+impl Default for ProbabilityEngine {
+    fn default() -> Self {
+        Self::new(ProbabilityEngineConfig::default())
+    }
+}
+
+impl ProbabilityEngine {
+    pub fn new(cfg: ProbabilityEngineConfig) -> Self {
+        Self { cfg }
+    }
+
+    pub fn cfg(&self) -> &ProbabilityEngineConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, cfg: ProbabilityEngineConfig) {
+        self.cfg = cfg;
+    }
+
+    pub fn estimate(
+        &self,
+        signal: &Signal,
+        direction_signal: &DirectionSignal,
+        settlement_prob_yes: Option<f64>,
+        book_top_lag_ms: f64,
+        now_ms: i64,
+    ) -> ProbabilityEstimate {
+        let base_fast = signal.fair_yes.clamp(0.0, 1.0);
+        let p_bs = bs_directional_probability(direction_signal, &self.cfg);
+        let blend_w = self.cfg.fair_blend_weight.clamp(0.0, 1.0);
+        let p_fast = ((base_fast * blend_w) + (p_bs * (1.0 - blend_w))).clamp(0.0, 1.0);
+        let p_settle = settlement_prob_yes.unwrap_or(p_fast).clamp(0.0, 1.0);
+
+        let lag_penalty = (book_top_lag_ms.max(0.0) * self.cfg.lag_penalty_per_ms).clamp(0.0, 0.60);
+        let settle_alignment = 1.0 - (p_fast - p_settle).abs().min(1.0);
+        let confidence = (direction_signal.confidence * settle_alignment - lag_penalty)
+            .clamp(self.cfg.confidence_floor, 1.0);
+
+        ProbabilityEstimate {
+            p_fast,
+            p_settle,
+            confidence,
+            settlement_source_degraded: settlement_prob_yes.is_none(),
+            ts_ms: now_ms,
+        }
+    }
+}
+
+#[inline]
+fn bs_directional_probability(
+    direction_signal: &DirectionSignal,
+    cfg: &ProbabilityEngineConfig,
+) -> f64 {
+    const SEC_PER_YEAR: f64 = 31_536_000.0;
+    let t = (cfg.horizon_sec.max(0.1) / SEC_PER_YEAR).clamp(1e-9, 1.0);
+    let sigma = cfg.sigma_annual.max(1e-6);
+    let sign = match direction_signal.direction {
+        Direction::Up => 1.0,
+        Direction::Down => -1.0,
+        Direction::Neutral => 0.0,
+    };
+    let momentum_component =
+        sign * (direction_signal.magnitude_pct.abs() / 100.0) * cfg.momentum_gain * 0.25;
+    let velocity_component =
+        sign * (direction_signal.velocity_bps_per_sec / 10_000.0) * cfg.velocity_drift_gain;
+    let acceleration_component =
+        sign * (direction_signal.acceleration / 10_000.0) * cfg.acceleration_drift_gain;
+    let drift = cfg.drift_annual + momentum_component + velocity_component + acceleration_component;
+    let denom = sigma * t.sqrt();
+    let d2 = ((drift - 0.5 * sigma * sigma) * t) / denom.max(1e-9);
+    normal_cdf(d2)
+}
+
+#[inline]
+fn normal_cdf(x: f64) -> f64 {
+    0.5 * (1.0 + erf_approx(x / std::f64::consts::SQRT_2))
+}
+
+// Abramowitz and Stegun 7.1.26 approximation, sufficient for strategy gating.
+#[inline]
+fn erf_approx(x: f64) -> f64 {
+    let sign = if x < 0.0 { -1.0 } else { 1.0 };
+    let x = x.abs();
+    let t = 1.0 / (1.0 + 0.327_591_1 * x);
+    let a1 = 0.254_829_592;
+    let a2 = -0.284_496_736;
+    let a3 = 1.421_413_741;
+    let a4 = -1.453_152_027;
+    let a5 = 1.061_405_429;
+    let y = 1.0 - (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * (-x * x).exp());
+    sign * y
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use core_types::{Direction, TimeframeClass};
+
+    fn signal() -> Signal {
+        Signal {
+            market_id: "m1".to_string(),
+            fair_yes: 0.52,
+            edge_bps_bid: 0.0,
+            edge_bps_ask: 0.0,
+            confidence: 0.7,
+        }
+    }
+
+    fn direction(up: bool) -> DirectionSignal {
+        DirectionSignal {
+            symbol: "BTCUSDT".to_string(),
+            direction: if up { Direction::Up } else { Direction::Down },
+            magnitude_pct: 0.40,
+            confidence: 0.9,
+            recommended_tf: TimeframeClass::Tf15m,
+            velocity_bps_per_sec: 6.0,
+            acceleration: 0.7,
+            tick_consistency: 3,
+            triple_confirm: true,
+            momentum_spike: false,
+            ts_ns: 1,
+        }
+    }
+
+    #[test]
+    fn estimate_marks_degraded_when_settlement_missing() {
+        let engine = ProbabilityEngine::default();
+        let p = engine.estimate(&signal(), &direction(true), None, 10.0, 123);
+        assert!(p.settlement_source_degraded);
+        assert!((0.0..=1.0).contains(&p.p_fast));
+        assert!((0.0..=1.0).contains(&p.p_settle));
+    }
+
+    #[test]
+    fn estimate_uses_settlement_when_provided() {
+        let engine = ProbabilityEngine::default();
+        let p = engine.estimate(&signal(), &direction(true), Some(0.61), 5.0, 123);
+        assert!(!p.settlement_source_degraded);
+        assert!((p.p_settle - 0.61).abs() < 1e-9);
+    }
+
+    #[test]
+    fn lag_penalty_reduces_confidence() {
+        let engine = ProbabilityEngine::default();
+        let p_low = engine.estimate(&signal(), &direction(true), None, 2.0, 123);
+        let p_high = engine.estimate(&signal(), &direction(true), None, 200.0, 123);
+        assert!(p_high.confidence < p_low.confidence);
+    }
+
+    #[test]
+    fn bs_probability_respects_direction() {
+        let engine = ProbabilityEngine::default();
+        let p_up = engine.estimate(&signal(), &direction(true), None, 5.0, 123);
+        let p_dn = engine.estimate(&signal(), &direction(false), None, 5.0, 123);
+        assert!(p_up.p_fast > p_dn.p_fast);
+    }
+
+    #[test]
+    fn confidence_penalized_when_settlement_diverges() {
+        let engine = ProbabilityEngine::default();
+        let aligned = engine.estimate(&signal(), &direction(true), Some(0.60), 5.0, 123);
+        let diverged = engine.estimate(&signal(), &direction(true), Some(0.10), 5.0, 123);
+        assert!(diverged.confidence < aligned.confidence);
+    }
+}
diff --git a/crates/replay_engine/src/lib.rs b/crates/replay_engine/src/lib.rs
index e98e921..1ceb453 100644
--- a/crates/replay_engine/src/lib.rs
+++ b/crates/replay_engine/src/lib.rs
@@ -99,8 +99,11 @@ mod tests {
                     symbol: "BTCUSDT".to_string(),
                     event_ts_ms: 1,
                     recv_ts_ms: 1,
+                    source_seq: 0,
                     event_ts_exchange_ms: 1,
                     recv_ts_local_ns: 1_000_000,
+                    ingest_ts_local_ns: 1_000_000,
+                    ts_first_hop_ms: None,
                     price: 1.0,
                 }),
             })
diff --git a/crates/risk_engine/src/lib.rs b/crates/risk_engine/src/lib.rs
index 4414f7e..67d2fe9 100644
--- a/crates/risk_engine/src/lib.rs
+++ b/crates/risk_engine/src/lib.rs
@@ -11,6 +11,11 @@ pub struct RiskLimits {
     pub max_drawdown_pct: f64,
     pub max_loss_streak: u32,
     pub cooldown_sec: u64,
+    pub progressive_enabled: bool,
+    pub drawdown_tier1_ratio: f64,
+    pub drawdown_tier2_ratio: f64,
+    pub tier1_size_scale: f64,
+    pub tier2_size_scale: f64,
 }
 
 impl Default for RiskLimits {
@@ -22,6 +27,11 @@ impl Default for RiskLimits {
             max_drawdown_pct: 0.015,
             max_loss_streak: 5,
             cooldown_sec: 60,
+            progressive_enabled: true,
+            drawdown_tier1_ratio: 0.50,
+            drawdown_tier2_ratio: 0.80,
+            tier1_size_scale: 0.70,
+            tier2_size_scale: 0.40,
         }
     }
 }
@@ -47,40 +57,68 @@ impl DefaultRiskManager {
 
 impl RiskManager for DefaultRiskManager {
     fn evaluate(&self, ctx: &RiskContext) -> RiskDecision {
-        let limits = self
-            .limits
-            .read()
-            .map(|g| g.clone())
-            .unwrap_or_else(|_| RiskLimits::default());
-
-        let now_ms = ctx.now_ms;
-
-        // Cooldown gate (e.g. after a loss streak trigger).
-        if let Ok(st) = self.state.lock() {
-            if now_ms > 0 && now_ms < st.cooldown_until_ms {
+        let limits = match self.limits.read() {
+            Ok(guard) => guard.clone(),
+            Err(_) => {
+                // Lock poisoned - fail closed for safety
                 return RiskDecision {
                     allow: false,
-                    reason: "cooldown".to_string(),
+                    reason: "risk_lock_poisoned".to_string(),
                     capped_size: 0.0,
                 };
             }
+        };
+
+        let now_ms = ctx.now_ms;
+
+        // Cooldown gate (e.g. after a loss streak trigger).
+        let cooldown_active = self
+            .state
+            .lock()
+            .map(|st| now_ms > 0 && now_ms < st.cooldown_until_ms)
+            .unwrap_or(false); // Fail closed if lock fails
+
+        if cooldown_active {
+            return RiskDecision {
+                allow: false,
+                reason: "cooldown".to_string(),
+                capped_size: 0.0,
+            };
         }
 
-        // Hard drawdown stop.
-        if ctx.drawdown_pct >= limits.max_drawdown_pct {
+        let drawdown_abs = ctx.drawdown_pct.abs();
+        // Hard drawdown stop - use abs to handle negative drawdown values
+        if drawdown_abs >= limits.max_drawdown_pct {
             return RiskDecision {
                 allow: false,
                 reason: "drawdown_stop".to_string(),
                 capped_size: 0.0,
             };
         }
+        let mut progressive_scale: f64 = 1.0;
+        let mut progressive_reason: Option<&'static str> = None;
+        if limits.progressive_enabled && limits.max_drawdown_pct > 0.0 {
+            let tier1 = limits.max_drawdown_pct * limits.drawdown_tier1_ratio.clamp(0.05, 0.99);
+            let tier2 = limits.max_drawdown_pct
+                * limits
+                    .drawdown_tier2_ratio
+                    .clamp(limits.drawdown_tier1_ratio.clamp(0.05, 0.99), 0.999);
+            if drawdown_abs >= tier2 {
+                progressive_scale = progressive_scale.min(limits.tier2_size_scale.clamp(0.01, 1.0));
+                progressive_reason = Some("drawdown_tier2");
+            } else if drawdown_abs >= tier1 {
+                progressive_scale = progressive_scale.min(limits.tier1_size_scale.clamp(0.01, 1.0));
+                progressive_reason = Some("drawdown_tier1");
+            }
+        }
 
         // Loss streak stop: once tripped, enter cooldown window.
         if ctx.loss_streak >= limits.max_loss_streak && limits.max_loss_streak > 0 {
             if let Ok(mut st) = self.state.lock() {
                 if now_ms > 0 {
+                    // Start cooldown window from "now", not from previous value.
                     st.cooldown_until_ms =
-                        st.cooldown_until_ms.max(now_ms + (limits.cooldown_sec as i64) * 1_000);
+                        now_ms.saturating_add((limits.cooldown_sec as i64).saturating_mul(1_000));
                 }
             }
             return RiskDecision {
@@ -102,23 +140,28 @@ impl RiskManager for DefaultRiskManager {
         // Notional caps. RiskContext carries precomputed notional in USDC.
         let proposed_notional = ctx.proposed_notional_usdc.max(0.0);
 
-        if ctx.market_notional + proposed_notional > limits.max_market_notional {
-            let remaining = (limits.max_market_notional - ctx.market_notional).max(0.0);
+        // Normalize existing notional to handle potential negative values
+        let market_notional = ctx.market_notional.max(0.0);
+        let asset_notional = ctx.asset_notional.max(0.0);
+
+        if market_notional + proposed_notional > limits.max_market_notional {
+            let remaining = (limits.max_market_notional - market_notional).max(0.0);
             let capped_size = if proposed_notional <= 0.0 {
                 0.0
             } else {
                 // Scale down size proportionally; caller uses it as a cap.
+                // Use epsilon to prevent division by zero
                 (ctx.proposed_size * (remaining / proposed_notional)).max(0.0)
             };
             return RiskDecision {
                 allow: capped_size > 0.0,
                 reason: "market_notional_limit".to_string(),
-                capped_size,
+                capped_size: (capped_size * progressive_scale).max(0.0),
             };
         }
 
-        if ctx.asset_notional + proposed_notional > limits.max_asset_notional {
-            let remaining = (limits.max_asset_notional - ctx.asset_notional).max(0.0);
+        if asset_notional + proposed_notional > limits.max_asset_notional {
+            let remaining = (limits.max_asset_notional - asset_notional).max(0.0);
             let capped_size = if proposed_notional <= 0.0 {
                 0.0
             } else {
@@ -127,15 +170,106 @@ impl RiskManager for DefaultRiskManager {
             return RiskDecision {
                 allow: capped_size > 0.0,
                 reason: "asset_notional_limit".to_string(),
-                capped_size,
+                capped_size: (capped_size * progressive_scale).max(0.0),
             };
         }
 
+        let capped = (ctx.proposed_size.max(0.0) * progressive_scale).max(0.0);
         RiskDecision {
-            allow: true,
-            reason: "ok".to_string(),
-            capped_size: ctx.proposed_size.max(0.0),
+            allow: capped > 0.0,
+            reason: progressive_reason.unwrap_or("ok").to_string(),
+            capped_size: capped,
         }
     }
 }
 
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn ctx(now_ms: i64) -> RiskContext {
+        RiskContext {
+            market_id: "m1".to_string(),
+            symbol: "BTCUSDT".to_string(),
+            order_count: 0,
+            proposed_size: 1.0,
+            proposed_notional_usdc: 1.0,
+            market_notional: 0.0,
+            asset_notional: 0.0,
+            drawdown_pct: 0.0,
+            loss_streak: 0,
+            now_ms,
+        }
+    }
+
+    #[test]
+    fn loss_streak_sets_cooldown_from_current_time() {
+        let limits = Arc::new(RwLock::new(RiskLimits {
+            max_loss_streak: 1,
+            cooldown_sec: 60,
+            ..RiskLimits::default()
+        }));
+        let rm = DefaultRiskManager::new(limits);
+
+        let mut tripped = ctx(1_000_000);
+        tripped.loss_streak = 1;
+        let d = rm.evaluate(&tripped);
+        assert!(!d.allow);
+        assert_eq!(d.reason, "loss_streak");
+
+        // Should be blocked by cooldown at +59s.
+        let d = rm.evaluate(&ctx(1_059_000));
+        assert!(!d.allow);
+        assert_eq!(d.reason, "cooldown");
+
+        // Cooldown should end at +60s.
+        let d = rm.evaluate(&ctx(1_060_000));
+        assert!(d.allow);
+        assert_eq!(d.reason, "ok");
+    }
+
+    #[test]
+    fn notional_cap_scales_size_proportionally() {
+        let limits = Arc::new(RwLock::new(RiskLimits {
+            max_market_notional: 10.0,
+            ..RiskLimits::default()
+        }));
+        let rm = DefaultRiskManager::new(limits);
+        let d = rm.evaluate(&RiskContext {
+            market_notional: 8.0,
+            proposed_notional_usdc: 4.0,
+            proposed_size: 2.0,
+            ..ctx(1_000_000)
+        });
+        assert!(d.allow);
+        // Remaining notional is 2.0 out of requested 4.0 => 50% size cap.
+        assert!((d.capped_size - 1.0).abs() < 1e-9);
+    }
+
+    #[test]
+    fn progressive_drawdown_scales_size_before_hard_stop() {
+        let limits = Arc::new(RwLock::new(RiskLimits {
+            max_drawdown_pct: 0.20,
+            drawdown_tier1_ratio: 0.50,
+            drawdown_tier2_ratio: 0.80,
+            tier1_size_scale: 0.70,
+            tier2_size_scale: 0.40,
+            progressive_enabled: true,
+            ..RiskLimits::default()
+        }));
+        let rm = DefaultRiskManager::new(limits);
+        let mut low = ctx(1_000_000);
+        low.drawdown_pct = 0.11;
+        let d_low = rm.evaluate(&low);
+        assert!(d_low.allow);
+        assert_eq!(d_low.reason, "drawdown_tier1");
+        assert!((d_low.capped_size - 0.70).abs() < 1e-9);
+
+        let mut high = ctx(1_000_100);
+        high.drawdown_pct = 0.17;
+        let d_high = rm.evaluate(&high);
+        assert!(d_high.allow);
+        assert_eq!(d_high.reason, "drawdown_tier2");
+        assert!((d_high.capped_size - 0.40).abs() < 1e-9);
+    }
+}
diff --git a/crates/settlement_compounder/Cargo.toml b/crates/settlement_compounder/Cargo.toml
new file mode 100644
index 0000000..730072c
--- /dev/null
+++ b/crates/settlement_compounder/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "settlement_compounder"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+core_types = { path = "../core_types" }
+serde.workspace = true
+
diff --git a/crates/settlement_compounder/src/lib.rs b/crates/settlement_compounder/src/lib.rs
new file mode 100644
index 0000000..13615ef
--- /dev/null
+++ b/crates/settlement_compounder/src/lib.rs
@@ -0,0 +1,274 @@
+use core_types::CapitalUpdate;
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct CompounderConfig {
+    pub enabled: bool,
+    pub initial_capital_usdc: f64,
+    /// Share of profits to compound (1.0 = 100%).
+    pub compound_ratio: f64,
+    /// Recommended per-order notional = available * position_fraction (bounded by min_quote_size).
+    pub position_fraction: f64,
+    /// Minimum per-order notional in USDC.
+    pub min_quote_size: f64,
+    /// Hard-stop threshold (USDC). If daily_pnl <= -cap, compounder marks halted.
+    pub daily_loss_cap_usdc: f64,
+}
+
+impl Default for CompounderConfig {
+    fn default() -> Self {
+        Self {
+            enabled: false,
+            initial_capital_usdc: 100.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 1.0,
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct SettlementCompounder {
+    cfg: CompounderConfig,
+    available_usdc: f64,
+    initial_usdc: f64,
+    total_pnl: f64,
+    daily_pnl: f64,
+    daily_epoch_day: i64,
+    win_count: u64,
+    loss_count: u64,
+    halted: bool,
+}
+
+impl SettlementCompounder {
+    pub fn new(cfg: CompounderConfig) -> Self {
+        let initial = cfg.initial_capital_usdc.max(0.0);
+        let now = now_ms();
+        Self {
+            cfg,
+            available_usdc: initial,
+            initial_usdc: initial,
+            total_pnl: 0.0,
+            daily_pnl: 0.0,
+            daily_epoch_day: epoch_day_from_ms(now),
+            win_count: 0,
+            loss_count: 0,
+            halted: false,
+        }
+    }
+
+    pub fn cfg(&self) -> &CompounderConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, mut cfg: CompounderConfig) {
+        // Validate and clamp config values to valid ranges
+        cfg.compound_ratio = cfg.compound_ratio.clamp(0.0, 1.0);
+        cfg.position_fraction = cfg.position_fraction.clamp(0.0, 1.0);
+        cfg.min_quote_size = cfg.min_quote_size.max(0.0);
+        cfg.daily_loss_cap_usdc = cfg.daily_loss_cap_usdc.max(0.0);
+        self.cfg = cfg;
+        if self.initial_usdc <= 0.0 {
+            self.initial_usdc = self.cfg.initial_capital_usdc.max(0.0);
+        }
+    }
+
+    pub fn available(&self) -> f64 {
+        self.available_usdc
+    }
+
+    pub fn total_pnl(&self) -> f64 {
+        self.total_pnl
+    }
+
+    pub fn daily_pnl(&self) -> f64 {
+        self.daily_pnl
+    }
+
+    pub fn win_rate(&self) -> f64 {
+        let total = self.win_count + self.loss_count;
+        if total == 0 {
+            0.0
+        } else {
+            (self.win_count as f64 / total as f64).clamp(0.0, 1.0)
+        }
+    }
+
+    pub fn halted(&self) -> bool {
+        self.halted
+    }
+
+    pub fn recommended_quote_notional_usdc(&self) -> f64 {
+        if !self.cfg.enabled {
+            return 0.0;
+        }
+        (self.available_usdc.max(0.0) * self.cfg.position_fraction.clamp(0.0, 1.0))
+            .max(self.cfg.min_quote_size.max(0.0))
+    }
+
+    pub fn on_markout(&mut self, pnl_usdc: f64) -> CapitalUpdate {
+        let ts_ms = now_ms();
+        self.on_markout_at(pnl_usdc, ts_ms)
+    }
+
+    fn on_markout_at(&mut self, pnl_usdc: f64, ts_ms: i64) -> CapitalUpdate {
+        self.rollover_day_if_needed(ts_ms);
+        if !self.cfg.enabled {
+            return CapitalUpdate {
+                available_usdc: self.available_usdc,
+                base_quote_size: 0.0,
+                ts_ms,
+            };
+        }
+
+        self.total_pnl += pnl_usdc;
+        self.daily_pnl += pnl_usdc;
+
+        if pnl_usdc > 0.0 {
+            self.win_count = self.win_count.saturating_add(1);
+            self.available_usdc += pnl_usdc * self.cfg.compound_ratio.clamp(0.0, 1.0);
+        } else if pnl_usdc < 0.0 {
+            self.loss_count = self.loss_count.saturating_add(1);
+            self.available_usdc += pnl_usdc;
+        }
+
+        if self.available_usdc < 0.0 {
+            self.available_usdc = 0.0;
+        }
+
+        if self.cfg.daily_loss_cap_usdc > 0.0 && self.daily_pnl <= -self.cfg.daily_loss_cap_usdc {
+            self.halted = true;
+        }
+
+        CapitalUpdate {
+            available_usdc: self.available_usdc,
+            base_quote_size: self.recommended_quote_notional_usdc(),
+            ts_ms,
+        }
+    }
+
+    pub fn reset_daily(&mut self) {
+        self.daily_pnl = 0.0;
+        self.halted = false;
+        self.daily_epoch_day = epoch_day_from_ms(now_ms());
+    }
+
+    fn rollover_day_if_needed(&mut self, ts_ms: i64) {
+        let day = epoch_day_from_ms(ts_ms);
+        if day != self.daily_epoch_day {
+            self.daily_pnl = 0.0;
+            self.halted = false;
+            self.daily_epoch_day = day;
+        }
+    }
+}
+
+fn now_ms() -> i64 {
+    use std::time::{SystemTime, UNIX_EPOCH};
+    SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .ok()
+        .map(|d| d.as_millis() as i64)
+        .unwrap_or(0)
+}
+
+#[inline]
+fn epoch_day_from_ms(ts_ms: i64) -> i64 {
+    ts_ms.div_euclid(86_400_000)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn compound_increases_available() {
+        let mut c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 100.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 0.0,
+        });
+        let u = c.on_markout(10.0);
+        assert!((u.available_usdc - 110.0).abs() < 1e-9);
+    }
+
+    #[test]
+    fn loss_decreases_available() {
+        let mut c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 100.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 0.0,
+        });
+        let u = c.on_markout(-20.0);
+        assert!((u.available_usdc - 80.0).abs() < 1e-9);
+    }
+
+    #[test]
+    fn quote_notional_scales_with_capital() {
+        let c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 200.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 0.0,
+        });
+        assert!((c.recommended_quote_notional_usdc() - 30.0).abs() < 1e-9);
+    }
+
+    #[test]
+    fn halt_on_daily_cap() {
+        let mut c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 100.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 10.0,
+        });
+        c.on_markout(-11.0);
+        assert!(c.halted());
+    }
+
+    #[test]
+    fn never_negative_available() {
+        let mut c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 5.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 0.0,
+        });
+        c.on_markout(-20.0);
+        assert!(c.available() >= 0.0);
+    }
+
+    #[test]
+    fn daily_halt_auto_recovers_after_day_rollover() {
+        let mut c = SettlementCompounder::new(CompounderConfig {
+            enabled: true,
+            initial_capital_usdc: 100.0,
+            compound_ratio: 1.0,
+            position_fraction: 0.15,
+            min_quote_size: 1.0,
+            daily_loss_cap_usdc: 10.0,
+        });
+
+        // Day 0: trigger halt.
+        let _ = c.on_markout_at(-11.0, 1_000);
+        assert!(c.halted());
+
+        // Day 1: a new markout should roll daily state and clear halt.
+        let _ = c.on_markout_at(1.0, 86_400_000 + 2_000);
+        assert!(!c.halted());
+        assert!(c.daily_pnl() > 0.0);
+    }
+}
diff --git a/crates/strategy_maker/src/lib.rs b/crates/strategy_maker/src/lib.rs
index 94a5407..7144c61 100644
--- a/crates/strategy_maker/src/lib.rs
+++ b/crates/strategy_maker/src/lib.rs
@@ -30,7 +30,8 @@ impl Default for MakerConfig {
             ttl_ms: 400,
             taker_trigger_bps: 8.0,
             taker_max_slippage_bps: 25.0,
-            stale_tick_filter_ms: 2_000.0,
+            // SEAT Latency Fabric v1.0: Êõ¥ÊøÄËøõÁöÑËøáÊúüËøáÊª§
+            stale_tick_filter_ms: 120.0, // ‰ªé 2000ms ÈôçÂà∞ 120ms
             market_tier_profile: "balanced".to_string(),
             capital_fraction_kelly: 0.35,
             variance_penalty_lambda: 0.25,
diff --git a/crates/taker_sniper/Cargo.toml b/crates/taker_sniper/Cargo.toml
new file mode 100644
index 0000000..a7327ed
--- /dev/null
+++ b/crates/taker_sniper/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "taker_sniper"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+core_types = { path = "../core_types" }
+serde.workspace = true
+
diff --git a/crates/taker_sniper/src/lib.rs b/crates/taker_sniper/src/lib.rs
new file mode 100644
index 0000000..5af4a4e
--- /dev/null
+++ b/crates/taker_sniper/src/lib.rs
@@ -0,0 +1,754 @@
+use std::collections::HashMap;
+
+use core_types::{Direction, DirectionSignal, TimeframeClass, TimeframeOpp};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
+pub struct SymbolGatlingConfig {
+    #[serde(default)]
+    pub enabled: Option<bool>,
+    #[serde(default)]
+    pub chunk_notional_usdc: Option<f64>,
+    #[serde(default)]
+    pub min_chunks: Option<usize>,
+    #[serde(default)]
+    pub max_chunks: Option<usize>,
+    #[serde(default)]
+    pub spacing_ms: Option<u64>,
+    #[serde(default)]
+    pub stop_on_reject: Option<bool>,
+}
+
+#[derive(Debug, Clone, Copy)]
+struct GatlingResolved {
+    enabled: bool,
+    chunk_notional_usdc: f64,
+    min_chunks: usize,
+    max_chunks: usize,
+    spacing_ms: u64,
+    stop_on_reject: bool,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct TakerSniperConfig {
+    pub min_direction_confidence: f64,
+    pub min_edge_net_bps: f64,
+    pub max_spread: f64,
+    pub cooldown_ms_per_market: u64,
+    pub gatling_enabled: bool,
+    pub gatling_chunk_notional_usdc: f64,
+    pub gatling_min_chunks: usize,
+    pub gatling_max_chunks: usize,
+    pub gatling_spacing_ms: u64,
+    pub gatling_stop_on_reject: bool,
+    #[serde(default)]
+    pub gatling_by_symbol: HashMap<String, SymbolGatlingConfig>,
+    /// Minimum quality score (0..100) required to fire.
+    /// Score = signal (0..40) + market (0..35) + timing (0..25).
+    #[serde(default = "default_min_win_rate_score")]
+    pub min_win_rate_score: f64,
+}
+
+fn default_min_win_rate_score() -> f64 {
+    55.0
+}
+
+impl Default for TakerSniperConfig {
+    fn default() -> Self {
+        Self {
+            min_direction_confidence: 0.60,
+            // Conservative default for taker path; config can override this.
+            min_edge_net_bps: 200.0,
+            max_spread: 0.08,
+            cooldown_ms_per_market: 800,
+            gatling_enabled: true,
+            gatling_chunk_notional_usdc: 5.0,
+            gatling_min_chunks: 1,
+            gatling_max_chunks: 4,
+            gatling_spacing_ms: 12,
+            gatling_stop_on_reject: true,
+            gatling_by_symbol: HashMap::new(),
+            min_win_rate_score: 55.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub enum TakerAction {
+    Fire,
+    Skip,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct FireChunk {
+    pub size: f64,
+    pub send_delay_ms: u64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct FirePlan {
+    pub opportunity: TimeframeOpp,
+    pub chunks: Vec<FireChunk>,
+    pub stop_on_reject: bool,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct TakerDecision {
+    pub action: TakerAction,
+    pub fire_plan: Option<FirePlan>,
+    pub reason: String,
+}
+
+// Inputs for a single taker decision.
+#[derive(Debug, Clone)]
+pub struct EvaluateCtx<'a> {
+    pub market_id: &'a str,
+    pub symbol: &'a str,
+    pub timeframe: TimeframeClass,
+    pub direction_signal: &'a DirectionSignal,
+    pub entry_price: f64,
+    pub spread: f64,
+    pub fee_bps: f64,
+    pub edge_gross_bps: f64,
+    pub edge_net_bps: f64,
+    pub size: f64,
+    pub now_ms: i64,
+}
+
+#[derive(Debug)]
+pub struct TakerSniper {
+    cfg: TakerSniperConfig,
+    last_fire_ms_by_market: HashMap<String, i64>,
+}
+
+impl TakerSniper {
+    pub fn new(cfg: TakerSniperConfig) -> Self {
+        Self {
+            cfg,
+            last_fire_ms_by_market: HashMap::new(),
+        }
+    }
+
+    pub fn cfg(&self) -> &TakerSniperConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, cfg: TakerSniperConfig) {
+        self.cfg = cfg;
+    }
+
+    pub fn evaluate(&mut self, ctx: &EvaluateCtx<'_>) -> TakerDecision {
+        if matches!(ctx.direction_signal.direction, Direction::Neutral) {
+            return skip_static("neutral_direction");
+        }
+        if ctx.direction_signal.confidence < self.cfg.min_direction_confidence {
+            return skip_static("low_confidence");
+        }
+        if ctx.entry_price <= 0.0 {
+            return skip_static("bad_price");
+        }
+        if ctx.spread > self.cfg.max_spread {
+            return skip_static("spread_too_wide");
+        }
+        let dynamic_min_edge =
+            dynamic_fee_gate_min_edge_bps(ctx.entry_price, ctx.direction_signal.confidence);
+        let min_edge_required = self.cfg.min_edge_net_bps.max(dynamic_min_edge);
+        if ctx.edge_net_bps < min_edge_required {
+            return skip_static("fee_gate_too_expensive");
+        }
+        if ctx.size <= 0.0 {
+            return skip_static("size_zero");
+        }
+        if self.cfg.cooldown_ms_per_market > 0 {
+            if let Some(last) = self.last_fire_ms_by_market.get(ctx.market_id) {
+                let age = ctx.now_ms.saturating_sub(*last);
+                if (age as u64) < self.cfg.cooldown_ms_per_market {
+                    return skip_static("cooldown_active");
+                }
+            }
+        }
+
+        // Quality gate: skip weak opportunities.
+        if self.cfg.min_win_rate_score > 0.0 {
+            let score = compute_win_rate_score(ctx);
+            if score < self.cfg.min_win_rate_score {
+                return skip_dynamic(format!("win_rate_score_too_low:{score:.1}"));
+            }
+        }
+
+        let lock_minutes = lock_minutes_for_timeframe(&ctx.timeframe);
+        let notional_usdc = (ctx.entry_price.max(0.0) * ctx.size.max(0.0)).max(0.0);
+        let edge_net_usdc = (ctx.edge_net_bps / 10_000.0) * notional_usdc;
+        let density = if lock_minutes <= 0.0 {
+            0.0
+        } else {
+            edge_net_usdc / lock_minutes
+        };
+        let opp = TimeframeOpp {
+            timeframe: ctx.timeframe.clone(),
+            market_id: ctx.market_id.to_string(),
+            symbol: ctx.symbol.to_string(),
+            direction: ctx.direction_signal.direction.clone(),
+            side: direction_to_side(&ctx.direction_signal.direction),
+            entry_price: ctx.entry_price,
+            size: ctx.size,
+            edge_gross_bps: ctx.edge_gross_bps,
+            edge_net_bps: ctx.edge_net_bps,
+            edge_net_usdc,
+            fee_bps: ctx.fee_bps,
+            lock_minutes,
+            density,
+            confidence: ctx.direction_signal.confidence,
+            ts_ms: ctx.now_ms,
+        };
+        self.last_fire_ms_by_market
+            .insert(ctx.market_id.to_string(), ctx.now_ms);
+        let gatling = self.cfg.gatling_for_symbol(ctx.symbol);
+        let fire_plan = build_fire_plan(&gatling, opp);
+        TakerDecision {
+            action: TakerAction::Fire,
+            fire_plan: Some(fire_plan),
+            reason: "fire".to_string(),
+        }
+    }
+}
+
+// ============================================================
+// skip ËæÖÂä©ÂáΩÊï∞ ‚Äî ‰∏§‰∏™ÁâàÊú¨Ê∂àÈô§‰∏çÂøÖË¶ÅÁöÑÂ†ÜÂàÜÈÖç
+//   skip_static: Âõ∫ÂÆöÂéüÂõ†ÔºåÈõ∂ÂàÜÈÖçÔºàÁÉ≠Ë∑ØÂæÑ‰∏ìÁî®Ôºâ
+//   skip_dynamic: Âä®ÊÄÅÂéüÂõ†ÔºåÂè™Âú®ÂøÖË¶ÅÊó∂ÂàÜÈÖç
+// ============================================================
+#[inline]
+fn skip_static(reason: &'static str) -> TakerDecision {
+    TakerDecision {
+        action: TakerAction::Skip,
+        fire_plan: None,
+        reason: reason.to_string(),
+    }
+}
+
+#[inline]
+fn skip_dynamic(reason: String) -> TakerDecision {
+    TakerDecision {
+        action: TakerAction::Skip,
+        fire_plan: None,
+        reason,
+    }
+}
+
+// ============================================================
+// ËÉúÁéáËØÑÂàÜÁ≥ªÁªü (0-100ÂàÜ)
+// ‰∏â‰∏™Áª¥Â∫¶ÂàÜÂà´ËØÑ‰º∞‰ø°Âè∑„ÄÅÂ∏ÇÂú∫„ÄÅÊó∂Â∫èË¥®Èáè
+// Âè™ÊúâÊÄªÂàÜ ‚â• min_win_rate_score ÊâçËß¶ÂèëÔºåÂÖ∂‰ΩôË∑≥Ëøá
+// ============================================================
+fn compute_win_rate_score(ctx: &EvaluateCtx<'_>) -> f64 {
+    let sig = ctx.direction_signal;
+
+    // --- ‰ø°Âè∑Ë¥®Èáè (0-40ÂàÜ) ---
+    // velocity: Âä®ÈáèË∂äÂº∫Ôºå‰ø°Âè∑Ë∂äÂèØÈù†
+    let velocity_score = match sig.velocity_bps_per_sec.abs() {
+        v if v >= 100.0 => 20.0,
+        v if v >= 50.0 => 14.0,
+        v if v >= 20.0 => 8.0,
+        v if v >= 5.0 => 3.0,
+        _ => 0.0,
+    };
+    // acceleration: Ë∂ãÂäøÂä†Âº∫‰∏≠Ôºå‰∏çÊòØÂáèÈÄü
+    let accel_score = if sig.acceleration > 0.0 { 10.0 } else { 0.0 };
+    // tick_consistency: ËøûÁª≠ÂêåÂêë Tick Ë∂äÂ§öÔºåÊñπÂêëË∂äÁ°ÆÂÆö
+    let tick_score = match sig.tick_consistency {
+        t if t >= 3 => 10.0,
+        2 => 5.0,
+        1 => 2.0,
+        _ => 0.0,
+    };
+    let signal_quality = velocity_score + accel_score + tick_score;
+
+    // --- Â∏ÇÂú∫Ë¥®Èáè (0-35ÂàÜ) ---
+    // price_zone: ÊûÅÁ´Ø‰ª∑Ê†ºÂå∫ Gamma ÊúÄÈ´òÔºåË¥πÁéáÊúÄ‰ΩéÔºåÊúÄÂÆπÊòìÁõàÂà©
+    let p = ctx.entry_price.clamp(0.0, 1.0);
+    let dist = (p - 0.5).abs(); // 0=‰∏≠Èó¥, 0.5=ÊûÅÁ´Ø
+    let zone_score = match dist {
+        d if d >= 0.42 => 20.0, // >0.92 Êàñ <0.08: ÊúÄÈ´ò Gamma
+        d if d >= 0.35 => 13.0, // 0.85-0.92
+        d if d >= 0.25 => 6.0,  // 0.75-0.85
+        _ => 0.0,               // ‰∏≠Èó¥Âå∫Èó¥: Ë¥πÁéáÂ§™È´ò
+    };
+    // spread: ÁõòÂè£Ë∂äÁ¥ßÔºåÊªëÁÇπË∂äÂ∞è
+    let spread_score = match ctx.spread {
+        s if s < 0.01 => 10.0,
+        s if s < 0.03 => 5.0,
+        s if s < 0.05 => 2.0,
+        _ => 0.0,
+    };
+    // triple_confirm: ‰∏âÈáçÁ°ÆËÆ§ÈÄöËøáÊòØÈ´òË¥®Èáè‰ø°Âè∑ÁöÑÊ†áÂøó
+    let confirm_score = if sig.triple_confirm { 5.0 } else { 0.0 };
+    let market_quality = zone_score + spread_score + confirm_score;
+
+    // --- Êó∂Â∫èË¥®Èáè (0-25ÂàÜ) ---
+    // momentum_spike: Âä®ÈáèÁ™ÅÂà∫ÊòØÊúÄÂº∫ÁöÑÂÖ•Âú∫‰ø°Âè∑
+    let spike_score = if sig.momentum_spike { 15.0 } else { 0.0 };
+    // edge: È¢ÑÊúüÁõàÂà©Ë∂äÈ´òÔºåÊó∂Â∫è‰ª∑ÂÄºË∂äÂ§ß
+    let edge_score = match ctx.edge_net_bps {
+        e if e >= 200.0 => 10.0,
+        e if e >= 100.0 => 7.0,
+        e if e >= 50.0 => 4.0,
+        e if e >= 30.0 => 2.0,
+        _ => 0.0,
+    };
+    let timing_quality = spike_score + edge_score;
+
+    signal_quality + market_quality + timing_quality
+}
+
+fn build_fire_plan(gatling: &GatlingResolved, opportunity: TimeframeOpp) -> FirePlan {
+    let total_size = opportunity.size.max(0.0);
+    let notional = (opportunity.entry_price.max(0.0) * total_size).max(0.0);
+    let min_chunks = gatling.min_chunks.max(1);
+    let max_chunks = gatling.max_chunks.max(min_chunks);
+    let desired_chunks = if gatling.enabled && gatling.chunk_notional_usdc > 0.0 {
+        ((notional / gatling.chunk_notional_usdc).ceil() as usize).clamp(min_chunks, max_chunks)
+    } else {
+        1
+    };
+
+    let mut chunks = Vec::with_capacity(desired_chunks);
+    if desired_chunks == 1 {
+        chunks.push(FireChunk {
+            size: total_size,
+            send_delay_ms: 0,
+        });
+    } else {
+        let mut remain = total_size;
+        let base = total_size / desired_chunks as f64;
+        for idx in 0..desired_chunks {
+            let mut size = if idx + 1 == desired_chunks {
+                remain
+            } else {
+                base
+            };
+            if idx + 1 != desired_chunks {
+                size = size.max(0.01);
+                remain = (remain - size).max(0.0);
+            }
+            chunks.push(FireChunk {
+                size,
+                send_delay_ms: if idx == 0 { 0 } else { gatling.spacing_ms },
+            });
+        }
+    }
+
+    FirePlan {
+        opportunity,
+        chunks,
+        stop_on_reject: gatling.stop_on_reject,
+    }
+}
+
+impl TakerSniperConfig {
+    fn gatling_for_symbol(&self, symbol: &str) -> GatlingResolved {
+        let mut resolved = GatlingResolved {
+            enabled: self.gatling_enabled,
+            chunk_notional_usdc: self.gatling_chunk_notional_usdc,
+            min_chunks: self.gatling_min_chunks.max(1),
+            max_chunks: self.gatling_max_chunks.max(self.gatling_min_chunks.max(1)),
+            spacing_ms: self.gatling_spacing_ms,
+            stop_on_reject: self.gatling_stop_on_reject,
+        };
+        let key = symbol.to_ascii_uppercase();
+        if let Some(override_cfg) = self.gatling_by_symbol.get(&key) {
+            if let Some(v) = override_cfg.enabled {
+                resolved.enabled = v;
+            }
+            if let Some(v) = override_cfg.chunk_notional_usdc {
+                resolved.chunk_notional_usdc = v.max(0.01);
+            }
+            if let Some(v) = override_cfg.min_chunks {
+                resolved.min_chunks = v.max(1);
+            }
+            if let Some(v) = override_cfg.max_chunks {
+                resolved.max_chunks = v.max(resolved.min_chunks);
+            }
+            if let Some(v) = override_cfg.spacing_ms {
+                resolved.spacing_ms = v.min(1_000);
+            }
+            if let Some(v) = override_cfg.stop_on_reject {
+                resolved.stop_on_reject = v;
+            }
+        }
+        resolved
+    }
+}
+
+fn lock_minutes_for_timeframe(tf: &TimeframeClass) -> f64 {
+    match tf {
+        TimeframeClass::Tf5m => 5.0,
+        TimeframeClass::Tf15m => 15.0,
+        TimeframeClass::Tf1h => 60.0,
+        TimeframeClass::Tf1d => 1440.0,
+    }
+}
+
+fn direction_to_side(dir: &Direction) -> core_types::OrderSide {
+    match dir {
+        Direction::Up => core_types::OrderSide::BuyYes,
+        Direction::Down => core_types::OrderSide::BuyNo,
+        Direction::Neutral => core_types::OrderSide::BuyYes,
+    }
+}
+
+/// Dynamic edge gate by entry price bucket.
+/// Near 0.50 prices require much larger edge due fee drag and toxicity.
+#[inline]
+fn dynamic_fee_gate_min_edge_bps(entry_price: f64, confidence: f64) -> f64 {
+    let p = entry_price.clamp(0.0, 1.0);
+    // Fee behavior is approximately symmetric around 0.50.
+    let base_gate = if p >= 0.92 || p <= 0.08 {
+        80.0
+    } else if p >= 0.85 || p <= 0.15 {
+        150.0
+    } else if p >= 0.75 || p <= 0.25 {
+        300.0
+    } else if p >= 0.60 || p <= 0.40 {
+        600.0
+    } else {
+        // Around 0.50, require a much larger edge.
+        1200.0
+    };
+    // High confidence can relax at most 25%.
+    let confidence_relax =
+        (1.0 - (confidence.clamp(0.0, 1.0) - 0.5).max(0.0) * 0.4).clamp(0.75, 1.0);
+    base_gate * confidence_relax
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use core_types::{Direction, DirectionSignal, TimeframeClass};
+
+    fn up_signal(confidence: f64) -> DirectionSignal {
+        DirectionSignal {
+            symbol: "BTCUSDT".to_string(),
+            direction: Direction::Up,
+            magnitude_pct: 0.20,
+            confidence,
+            recommended_tf: TimeframeClass::Tf15m,
+            velocity_bps_per_sec: 7.5,
+            acceleration: 0.8,
+            tick_consistency: 3,
+            triple_confirm: true,
+            momentum_spike: false,
+            ts_ns: 1,
+        }
+    }
+
+    #[test]
+    fn fires_on_strong_signal() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_direction_confidence: 0.7,
+            min_edge_net_bps: 5.0,
+            max_spread: 0.08,
+            cooldown_ms_per_market: 0,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.95,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 80.0,
+            edge_net_bps: 80.0, // 0.95 Âå∫Èó¥ÈúÄË¶Å > 67.2 bps (80*0.84)
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Fire));
+        assert!(d.fire_plan.is_some());
+    }
+
+    #[test]
+    fn skips_low_confidence() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig::default());
+        let sig = up_signal(0.5);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.52,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 30.0,
+            edge_net_bps: 32.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Skip));
+        assert_eq!(d.reason, "low_confidence");
+    }
+
+    #[test]
+    fn skips_edge_below_threshold() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 25.0,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.52,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 30.0,
+            edge_net_bps: 24.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Skip));
+        assert_eq!(d.reason, "fee_gate_too_expensive");
+    }
+
+    #[test]
+    fn cooldown_blocks_repeated_fire() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 5.0,
+            cooldown_ms_per_market: 1_000,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d1 = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.95,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 80.0,
+            edge_net_bps: 80.0, // 0.95 Âå∫Èó¥ÈúÄË¶Å > 67.2 bps
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d1.action, TakerAction::Fire));
+        let d2 = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.95,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 80.0,
+            edge_net_bps: 80.0,
+            size: 10.0,
+            now_ms: 1_000_500,
+        });
+        assert!(matches!(d2.action, TakerAction::Skip));
+        assert_eq!(d2.reason, "cooldown_active");
+    }
+
+    #[test]
+    fn dynamic_fee_gate_blocks_mid_price_without_large_edge() {
+        // 50¬¢ Âå∫Èó¥ÈúÄË¶Å 800 bps (ÁΩÆ‰ø°Â∫¶ 0.9 ÊîæÂÆΩ 25% ‚Üí 600 bps)
+        // ‰º†ÂÖ• edge_net_bps=95 Ëøú‰Ωé‰∫é 600 bps, Â∫îËØ•Ë¢´Êã¶Êà™
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 10.0,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.50,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 60.0,
+            edge_net_bps: 95.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Skip));
+        assert_eq!(d.reason, "fee_gate_too_expensive");
+    }
+
+    #[test]
+    fn dynamic_fee_gate_blocks_mid_price_even_with_moderate_edge() {
+        // Âç≥‰Ωø edge=500 bps, 50¬¢ Âå∫Èó¥ (ÈúÄË¶Å ~600 bps) ‰πüÂ∫îË¢´Êã¶Êà™
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 10.0,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.50,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 500.0,
+            edge_net_bps: 500.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Skip));
+        assert_eq!(d.reason, "fee_gate_too_expensive");
+    }
+
+    #[test]
+    fn dynamic_fee_gate_allows_extreme_price_with_small_edge() {
+        // 0.95 Âå∫Èó¥: 80 bps base * 0.84 (confidence=0.9 ÊîæÂÆΩ) = 67.2 bps
+        // edge_net_bps=80 > 67.2, Â∫îËØ• Fire
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 10.0,
+            min_win_rate_score: 0.0, // Âè™ÊµãËØï fee gate Ë°å‰∏∫
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.95,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 80.0,
+            edge_net_bps: 80.0, // 80 > 67.2 bps ‚Üí Fire
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Fire));
+    }
+
+    #[test]
+    fn dynamic_fee_gate_relaxes_with_higher_confidence() {
+        // È™åËØÅÈ´òÁΩÆ‰ø°Â∫¶Á°ÆÂÆûËÉΩÊîæÂÆΩÈó®Êßõ (Âú®ÊûÅÁ´Ø‰ª∑Ê†ºÂå∫Èó¥)
+        // 0.85 Âå∫Èó¥: 150 bps base
+        //   confidence=0.55: relax = 1 - (0.55-0.5)*0.4 = 0.98 ‚Üí ÈúÄË¶Å 147 bps
+        //   confidence=0.95: relax = 1 - (0.95-0.5)*0.4 = 0.82 ‚Üí ÈúÄË¶Å 123 bps
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 10.0,
+            min_win_rate_score: 0.0, // Âè™ÊµãËØï fee gate Ë°å‰∏∫ÔºåÁ¶ÅÁî®ËÉúÁéáËøáÊª§
+            ..TakerSniperConfig::default()
+        });
+        let low = up_signal(0.55);
+        let high = up_signal(0.95);
+        // ‰ΩéÁΩÆ‰ø°Â∫¶: edge=130 bps < 147 bps ‚Üí Skip
+        let d_low = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &low,
+            entry_price: 0.85,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 130.0,
+            edge_net_bps: 130.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d_low.action, TakerAction::Skip));
+        // È´òÁΩÆ‰ø°Â∫¶: edge=130 bps > 123 bps ‚Üí Fire
+        let d_high = sniper.evaluate(&EvaluateCtx {
+            market_id: "m2",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &high,
+            entry_price: 0.85,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 130.0,
+            edge_net_bps: 130.0,
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d_high.action, TakerAction::Fire));
+    }
+
+    #[test]
+    fn gatling_plan_splits_into_chunks() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            gatling_enabled: true,
+            gatling_chunk_notional_usdc: 2.0,
+            gatling_min_chunks: 2,
+            gatling_max_chunks: 5,
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.90,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 200.0,
+            edge_net_bps: 200.0, // 0.90 Âå∫Èó¥ÈúÄË¶Å > 150 bps
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Fire));
+        let Some(plan) = d.fire_plan else {
+            panic!("expected fire plan");
+        };
+        assert!(plan.chunks.len() >= 2);
+        assert!(plan.stop_on_reject);
+        let total: f64 = plan.chunks.iter().map(|c| c.size).sum();
+        assert!((total - 10.0).abs() < 1e-6);
+    }
+
+    #[test]
+    fn symbol_level_gatling_override_applied() {
+        let mut sniper = TakerSniper::new(TakerSniperConfig {
+            min_edge_net_bps: 5.0, // ÊµãËØï gatling Ë°å‰∏∫Ôºå‰∏çÊµãËØï edge Èó®Êßõ
+            gatling_enabled: false,
+            gatling_chunk_notional_usdc: 10.0,
+            gatling_min_chunks: 1,
+            gatling_max_chunks: 2,
+            gatling_by_symbol: HashMap::from([(
+                "BTCUSDT".to_string(),
+                SymbolGatlingConfig {
+                    enabled: Some(true),
+                    chunk_notional_usdc: Some(2.0),
+                    min_chunks: Some(2),
+                    max_chunks: Some(4),
+                    spacing_ms: Some(7),
+                    stop_on_reject: Some(false),
+                },
+            )]),
+            ..TakerSniperConfig::default()
+        });
+        let sig = up_signal(0.9);
+        let d = sniper.evaluate(&EvaluateCtx {
+            market_id: "m1",
+            symbol: "BTCUSDT",
+            timeframe: TimeframeClass::Tf15m,
+            direction_signal: &sig,
+            entry_price: 0.90,
+            spread: 0.01,
+            fee_bps: 2.0,
+            edge_gross_bps: 200.0,
+            edge_net_bps: 200.0, // 0.90 Âå∫Èó¥ÈúÄË¶Å > 150 bps
+            size: 10.0,
+            now_ms: 1_000_000,
+        });
+        assert!(matches!(d.action, TakerAction::Fire));
+        let Some(plan) = d.fire_plan else {
+            panic!("expected fire plan");
+        };
+        assert!(plan.chunks.len() >= 2);
+        assert_eq!(plan.chunks[1].send_delay_ms, 7);
+        assert!(!plan.stop_on_reject);
+    }
+}
diff --git a/crates/timeframe_router/Cargo.toml b/crates/timeframe_router/Cargo.toml
new file mode 100644
index 0000000..055bd09
--- /dev/null
+++ b/crates/timeframe_router/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "timeframe_router"
+version.workspace = true
+edition.workspace = true
+license.workspace = true
+
+[dependencies]
+core_types = { path = "../core_types" }
+serde.workspace = true
+
diff --git a/crates/timeframe_router/src/lib.rs b/crates/timeframe_router/src/lib.rs
new file mode 100644
index 0000000..75e806f
--- /dev/null
+++ b/crates/timeframe_router/src/lib.rs
@@ -0,0 +1,334 @@
+use std::collections::HashMap;
+
+use core_types::{TimeframeClass, TimeframeOpp};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct RouterConfig {
+    pub max_locked_pct_5m: f64,
+    pub max_locked_pct_15m: f64,
+    pub max_locked_pct_1h: f64,
+    pub max_locked_pct_1d: f64,
+    pub max_concurrent_positions: usize,
+    pub liquidity_reserve_pct: f64,
+    /// Hard caps for micro-live and safety. Defaults are permissive for paper/shadow.
+    pub max_order_notional_usdc: f64,
+    pub max_total_notional_usdc: f64,
+}
+
+impl Default for RouterConfig {
+    fn default() -> Self {
+        Self {
+            max_locked_pct_5m: 0.30,
+            max_locked_pct_15m: 0.40,
+            max_locked_pct_1h: 0.50,
+            max_locked_pct_1d: 0.30,
+            max_concurrent_positions: 8,
+            liquidity_reserve_pct: 0.20,
+            max_order_notional_usdc: 1_000_000.0,
+            max_total_notional_usdc: 1_000_000.0,
+        }
+    }
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct RouterLock {
+    pub market_id: String,
+    pub timeframe: TimeframeClass,
+    pub notional_usdc: f64,
+    pub locked_at_ms: i64,
+    pub unlock_at_ms: i64,
+}
+
+#[derive(Debug)]
+pub struct TimeframeRouter {
+    cfg: RouterConfig,
+    locks_by_market: HashMap<String, RouterLock>,
+}
+
+impl TimeframeRouter {
+    pub fn new(cfg: RouterConfig) -> Self {
+        Self {
+            cfg,
+            locks_by_market: HashMap::new(),
+        }
+    }
+
+    pub fn cfg(&self) -> &RouterConfig {
+        &self.cfg
+    }
+
+    pub fn set_cfg(&mut self, cfg: RouterConfig) {
+        self.cfg = cfg;
+    }
+
+    pub fn prune_expired(&mut self, now_ms: i64) {
+        self.locks_by_market.retain(|_, l| l.unlock_at_ms > now_ms);
+    }
+
+    pub fn active_positions(&mut self, now_ms: i64) -> usize {
+        self.prune_expired(now_ms);
+        self.locks_by_market.len()
+    }
+
+    pub fn locked_total_usdc(&mut self, now_ms: i64) -> f64 {
+        self.prune_expired(now_ms);
+        self.locks_by_market.values().map(|l| l.notional_usdc).sum()
+    }
+
+    pub fn locked_by_tf_usdc(&mut self, now_ms: i64) -> HashMap<TimeframeClass, f64> {
+        self.prune_expired(now_ms);
+        let mut out: HashMap<TimeframeClass, f64> = HashMap::new();
+        for l in self.locks_by_market.values() {
+            *out.entry(l.timeframe.clone()).or_insert(0.0) += l.notional_usdc;
+        }
+        out
+    }
+
+    pub fn snapshot_locks(&mut self, now_ms: i64) -> Vec<RouterLock> {
+        self.prune_expired(now_ms);
+        self.locks_by_market.values().cloned().collect()
+    }
+
+    pub fn route(
+        &mut self,
+        mut candidates: Vec<TimeframeOpp>,
+        total_capital_usdc: f64,
+        now_ms: i64,
+    ) -> Vec<TimeframeOpp> {
+        self.prune_expired(now_ms);
+
+        if candidates.is_empty() {
+            return Vec::new();
+        }
+        if total_capital_usdc <= 0.0 {
+            return Vec::new();
+        }
+
+        if self.locks_by_market.len() >= self.cfg.max_concurrent_positions {
+            return Vec::new();
+        }
+
+        let locked_total = self
+            .locks_by_market
+            .values()
+            .map(|l| l.notional_usdc)
+            .sum::<f64>();
+        let reserve =
+            (total_capital_usdc * self.cfg.liquidity_reserve_pct.clamp(0.0, 0.95)).max(0.0);
+        let mut deployable = (total_capital_usdc - reserve - locked_total).max(0.0);
+        if deployable < 1e-9 {
+            return Vec::new();
+        }
+
+        // Highest density first.
+        candidates.sort_by(|a, b| b.density.total_cmp(&a.density));
+
+        let mut out: Vec<TimeframeOpp> = Vec::new();
+        let max_new = self
+            .cfg
+            .max_concurrent_positions
+            .saturating_sub(self.locks_by_market.len())
+            .max(0);
+
+        let locked_by_tf = self.locked_by_tf_usdc(now_ms);
+
+        for opp in candidates {
+            if out.len() >= max_new {
+                break;
+            }
+            if self.locks_by_market.contains_key(&opp.market_id) {
+                continue;
+            }
+            let notional = (opp.entry_price.max(0.0) * opp.size.max(0.0)).max(0.0);
+            if notional <= 0.0 {
+                continue;
+            }
+            if notional > self.cfg.max_order_notional_usdc.max(0.0) {
+                continue;
+            }
+            if locked_total
+                + out
+                    .iter()
+                    .map(|o| (o.entry_price * o.size).max(0.0))
+                    .sum::<f64>()
+                + notional
+                > self.cfg.max_total_notional_usdc.max(0.0)
+            {
+                continue;
+            }
+
+            let tf_limit =
+                (self.max_locked_pct(&opp.timeframe).clamp(0.0, 1.0) * total_capital_usdc).max(0.0);
+            let tf_locked = *locked_by_tf.get(&opp.timeframe).unwrap_or(&0.0);
+            if tf_locked + notional > tf_limit {
+                continue;
+            }
+            if notional > deployable {
+                continue;
+            }
+
+            deployable -= notional;
+            out.push(opp);
+        }
+
+        out
+    }
+
+    pub fn lock(&mut self, opp: &TimeframeOpp, now_ms: i64) -> bool {
+        self.prune_expired(now_ms);
+        if self.locks_by_market.contains_key(&opp.market_id) {
+            return false;
+        }
+        let notional = (opp.entry_price.max(0.0) * opp.size.max(0.0)).max(0.0);
+        if notional <= 0.0 {
+            return false;
+        }
+        let lock_ms = (opp.lock_minutes.max(0.0) * 60_000.0).round() as i64;
+        let unlock_at = now_ms.saturating_add(lock_ms.max(0));
+        self.locks_by_market.insert(
+            opp.market_id.clone(),
+            RouterLock {
+                market_id: opp.market_id.clone(),
+                timeframe: opp.timeframe.clone(),
+                notional_usdc: notional,
+                locked_at_ms: now_ms,
+                unlock_at_ms: unlock_at,
+            },
+        );
+        true
+    }
+
+    pub fn unlock_market(&mut self, market_id: &str) -> bool {
+        self.locks_by_market.remove(market_id).is_some()
+    }
+
+    fn max_locked_pct(&self, tf: &TimeframeClass) -> f64 {
+        match tf {
+            TimeframeClass::Tf5m => self.cfg.max_locked_pct_5m,
+            TimeframeClass::Tf15m => self.cfg.max_locked_pct_15m,
+            TimeframeClass::Tf1h => self.cfg.max_locked_pct_1h,
+            TimeframeClass::Tf1d => self.cfg.max_locked_pct_1d,
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use core_types::{Direction, OrderSide};
+
+    fn opp(
+        tf: TimeframeClass,
+        density: f64,
+        market_id: &str,
+        entry_price: f64,
+        size: f64,
+    ) -> TimeframeOpp {
+        TimeframeOpp {
+            timeframe: tf,
+            market_id: market_id.to_string(),
+            symbol: "BTCUSDT".to_string(),
+            direction: Direction::Up,
+            side: OrderSide::BuyYes,
+            entry_price,
+            size,
+            edge_gross_bps: 20.0,
+            edge_net_bps: 10.0,
+            edge_net_usdc: 0.1,
+            fee_bps: 2.0,
+            lock_minutes: 15.0,
+            density,
+            confidence: 0.9,
+            ts_ms: 0,
+        }
+    }
+
+    #[test]
+    fn sorts_by_density_desc() {
+        let mut router = TimeframeRouter::new(RouterConfig {
+            max_concurrent_positions: 8,
+            liquidity_reserve_pct: 0.0,
+            ..RouterConfig::default()
+        });
+        let routed = router.route(
+            vec![
+                opp(TimeframeClass::Tf15m, 0.1, "m1", 0.5, 10.0),
+                opp(TimeframeClass::Tf15m, 0.2, "m2", 0.5, 10.0),
+            ],
+            100.0,
+            1_000,
+        );
+        assert_eq!(routed.len(), 2);
+        assert_eq!(routed[0].market_id, "m2");
+    }
+
+    #[test]
+    fn respects_max_positions() {
+        let mut router = TimeframeRouter::new(RouterConfig {
+            max_concurrent_positions: 1,
+            liquidity_reserve_pct: 0.0,
+            ..RouterConfig::default()
+        });
+        // Pre-lock one market.
+        router.locks_by_market.insert(
+            "m0".to_string(),
+            RouterLock {
+                market_id: "m0".to_string(),
+                timeframe: TimeframeClass::Tf15m,
+                notional_usdc: 10.0,
+                locked_at_ms: 0,
+                unlock_at_ms: 10_000,
+            },
+        );
+        let routed = router.route(
+            vec![opp(TimeframeClass::Tf15m, 0.2, "m1", 0.5, 10.0)],
+            100.0,
+            1_000,
+        );
+        assert!(routed.is_empty());
+    }
+
+    #[test]
+    fn respects_liquidity_reserve() {
+        let mut router = TimeframeRouter::new(RouterConfig {
+            max_concurrent_positions: 8,
+            liquidity_reserve_pct: 0.20,
+            ..RouterConfig::default()
+        });
+        // total=10, reserve=2 => deployable=8; order notional=9 => should skip.
+        let routed = router.route(
+            vec![opp(TimeframeClass::Tf15m, 0.2, "m1", 0.9, 10.0)],
+            10.0,
+            1_000,
+        );
+        assert!(routed.is_empty());
+    }
+
+    #[test]
+    fn respects_timeframe_lock_limit() {
+        let mut router = TimeframeRouter::new(RouterConfig {
+            max_locked_pct_5m: 0.30,
+            max_concurrent_positions: 8,
+            liquidity_reserve_pct: 0.0,
+            ..RouterConfig::default()
+        });
+        // 5m lock already 3 out of 10 => 30% cap reached.
+        router.locks_by_market.insert(
+            "m0".to_string(),
+            RouterLock {
+                market_id: "m0".to_string(),
+                timeframe: TimeframeClass::Tf5m,
+                notional_usdc: 3.0,
+                locked_at_ms: 0,
+                unlock_at_ms: 10_000,
+            },
+        );
+        let routed = router.route(
+            vec![opp(TimeframeClass::Tf5m, 0.2, "m1", 0.5, 10.0)],
+            10.0,
+            1_000,
+        );
+        assert!(routed.is_empty());
+    }
+}
